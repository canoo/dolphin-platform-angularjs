(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
(function (global){
"use strict";

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function (f) {
  if ((typeof exports === "undefined" ? "undefined" : _typeof2(exports)) === "object" && typeof module !== "undefined") {
    module.exports = f();
  } else if (typeof define === "function" && define.amd) {
    define([], f);
  } else {
    var g;if (typeof window !== "undefined") {
      g = window;
    } else if (typeof global !== "undefined") {
      g = global;
    } else if (typeof self !== "undefined") {
      g = self;
    } else {
      g = this;
    }g.dolphin = f();
  }
})(function () {
  var define, module, exports;return function e(t, n, r) {
    function s(o, u) {
      if (!n[o]) {
        if (!t[o]) {
          var a = typeof _dereq_ == "function" && _dereq_;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
        }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
          var n = t[o][1][e];return s(n ? n : e);
        }, l, l.exports, e, t, n, r);
      }return n[o].exports;
    }var i = typeof _dereq_ == "function" && _dereq_;for (var o = 0; o < r.length; o++) {
      s(r[o]);
    }return s;
  }({ 1: [function (_dereq_, module, exports) {
      'use strict';

      _dereq_('../modules/es6.object.to-string');
      _dereq_('../modules/es6.string.iterator');
      _dereq_('../modules/web.dom.iterable');
      _dereq_('../modules/es6.map');
      _dereq_('../modules/es7.map.to-json');
      module.exports = _dereq_('../modules/_core').Map;
    }, { "../modules/_core": 18, "../modules/es6.map": 72, "../modules/es6.object.to-string": 73, "../modules/es6.string.iterator": 76, "../modules/es7.map.to-json": 77, "../modules/web.dom.iterable": 79 }], 2: [function (_dereq_, module, exports) {
      'use strict';

      _dereq_('../modules/es6.object.to-string');
      _dereq_('../modules/es6.string.iterator');
      _dereq_('../modules/web.dom.iterable');
      _dereq_('../modules/es6.promise');
      module.exports = _dereq_('../modules/_core').Promise;
    }, { "../modules/_core": 18, "../modules/es6.object.to-string": 73, "../modules/es6.promise": 74, "../modules/es6.string.iterator": 76, "../modules/web.dom.iterable": 79 }], 3: [function (_dereq_, module, exports) {
      'use strict';

      _dereq_('../modules/es6.object.to-string');
      _dereq_('../modules/es6.string.iterator');
      _dereq_('../modules/web.dom.iterable');
      _dereq_('../modules/es6.set');
      _dereq_('../modules/es7.set.to-json');
      module.exports = _dereq_('../modules/_core').Set;
    }, { "../modules/_core": 18, "../modules/es6.object.to-string": 73, "../modules/es6.set": 75, "../modules/es6.string.iterator": 76, "../modules/es7.set.to-json": 78, "../modules/web.dom.iterable": 79 }], 4: [function (_dereq_, module, exports) {
      'use strict';

      module.exports = function (it) {
        if (typeof it != 'function') throw TypeError(it + ' is not a function!');
        return it;
      };
    }, {}], 5: [function (_dereq_, module, exports) {
      "use strict";

      module.exports = function () {/* empty */};
    }, {}], 6: [function (_dereq_, module, exports) {
      'use strict';

      module.exports = function (it, Constructor, name, forbiddenField) {
        if (!(it instanceof Constructor) || forbiddenField !== undefined && forbiddenField in it) {
          throw TypeError(name + ': incorrect invocation!');
        }return it;
      };
    }, {}], 7: [function (_dereq_, module, exports) {
      'use strict';

      var isObject = _dereq_('./_is-object');
      module.exports = function (it) {
        if (!isObject(it)) throw TypeError(it + ' is not an object!');
        return it;
      };
    }, { "./_is-object": 36 }], 8: [function (_dereq_, module, exports) {
      'use strict';

      var forOf = _dereq_('./_for-of');

      module.exports = function (iter, ITERATOR) {
        var result = [];
        forOf(iter, false, result.push, result, ITERATOR);
        return result;
      };
    }, { "./_for-of": 26 }], 9: [function (_dereq_, module, exports) {
      'use strict';

      // false -> Array#indexOf
      // true  -> Array#includes

      var toIObject = _dereq_('./_to-iobject'),
          toLength = _dereq_('./_to-length'),
          toIndex = _dereq_('./_to-index');
      module.exports = function (IS_INCLUDES) {
        return function ($this, el, fromIndex) {
          var O = toIObject($this),
              length = toLength(O.length),
              index = toIndex(fromIndex, length),
              value;
          // Array#includes uses SameValueZero equality algorithm
          if (IS_INCLUDES && el != el) while (length > index) {
            value = O[index++];
            if (value != value) return true;
            // Array#toIndex ignores holes, Array#includes - not
          } else for (; length > index; index++) {
            if (IS_INCLUDES || index in O) {
              if (O[index] === el) return IS_INCLUDES || index || 0;
            }
          }return !IS_INCLUDES && -1;
        };
      };
    }, { "./_to-index": 62, "./_to-iobject": 64, "./_to-length": 65 }], 10: [function (_dereq_, module, exports) {
      'use strict';

      // 0 -> Array#forEach
      // 1 -> Array#map
      // 2 -> Array#filter
      // 3 -> Array#some
      // 4 -> Array#every
      // 5 -> Array#find
      // 6 -> Array#findIndex

      var ctx = _dereq_('./_ctx'),
          IObject = _dereq_('./_iobject'),
          toObject = _dereq_('./_to-object'),
          toLength = _dereq_('./_to-length'),
          asc = _dereq_('./_array-species-create');
      module.exports = function (TYPE, $create) {
        var IS_MAP = TYPE == 1,
            IS_FILTER = TYPE == 2,
            IS_SOME = TYPE == 3,
            IS_EVERY = TYPE == 4,
            IS_FIND_INDEX = TYPE == 6,
            NO_HOLES = TYPE == 5 || IS_FIND_INDEX,
            create = $create || asc;
        return function ($this, callbackfn, that) {
          var O = toObject($this),
              self = IObject(O),
              f = ctx(callbackfn, that, 3),
              length = toLength(self.length),
              index = 0,
              result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined,
              val,
              res;
          for (; length > index; index++) {
            if (NO_HOLES || index in self) {
              val = self[index];
              res = f(val, index, O);
              if (TYPE) {
                if (IS_MAP) result[index] = res; // map
                else if (res) switch (TYPE) {
                    case 3:
                      return true; // some
                    case 5:
                      return val; // find
                    case 6:
                      return index; // findIndex
                    case 2:
                      result.push(val); // filter
                  } else if (IS_EVERY) return false; // every
              }
            }
          }return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
        };
      };
    }, { "./_array-species-create": 12, "./_ctx": 19, "./_iobject": 33, "./_to-length": 65, "./_to-object": 66 }], 11: [function (_dereq_, module, exports) {
      'use strict';

      var isObject = _dereq_('./_is-object'),
          isArray = _dereq_('./_is-array'),
          SPECIES = _dereq_('./_wks')('species');

      module.exports = function (original) {
        var C;
        if (isArray(original)) {
          C = original.constructor;
          // cross-realm fallback
          if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
          if (isObject(C)) {
            C = C[SPECIES];
            if (C === null) C = undefined;
          }
        }return C === undefined ? Array : C;
      };
    }, { "./_is-array": 35, "./_is-object": 36, "./_wks": 69 }], 12: [function (_dereq_, module, exports) {
      'use strict';

      // 9.4.2.3 ArraySpeciesCreate(originalArray, length)

      var speciesConstructor = _dereq_('./_array-species-constructor');

      module.exports = function (original, length) {
        return new (speciesConstructor(original))(length);
      };
    }, { "./_array-species-constructor": 11 }], 13: [function (_dereq_, module, exports) {
      'use strict';

      // getting tag from 19.1.3.6 Object.prototype.toString()

      var cof = _dereq_('./_cof'),
          TAG = _dereq_('./_wks')('toStringTag')
      // ES3 wrong here

      ,
          ARG = cof(function () {
        return arguments;
      }()) == 'Arguments';

      // fallback for IE11 Script Access Denied error
      var tryGet = function tryGet(it, key) {
        try {
          return it[key];
        } catch (e) {/* empty */}
      };

      module.exports = function (it) {
        var O, T, B;
        return it === undefined ? 'Undefined' : it === null ? 'Null'
        // @@toStringTag case
        : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
        // builtinTag case
        : ARG ? cof(O)
        // ES3 arguments fallback
        : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
      };
    }, { "./_cof": 14, "./_wks": 69 }], 14: [function (_dereq_, module, exports) {
      "use strict";

      var toString = {}.toString;

      module.exports = function (it) {
        return toString.call(it).slice(8, -1);
      };
    }, {}], 15: [function (_dereq_, module, exports) {
      'use strict';

      var dP = _dereq_('./_object-dp').f,
          create = _dereq_('./_object-create'),
          redefineAll = _dereq_('./_redefine-all'),
          ctx = _dereq_('./_ctx'),
          anInstance = _dereq_('./_an-instance'),
          defined = _dereq_('./_defined'),
          forOf = _dereq_('./_for-of'),
          $iterDefine = _dereq_('./_iter-define'),
          step = _dereq_('./_iter-step'),
          setSpecies = _dereq_('./_set-species'),
          DESCRIPTORS = _dereq_('./_descriptors'),
          fastKey = _dereq_('./_meta').fastKey,
          SIZE = DESCRIPTORS ? '_s' : 'size';

      var getEntry = function getEntry(that, key) {
        // fast case
        var index = fastKey(key),
            entry;
        if (index !== 'F') return that._i[index];
        // frozen object case
        for (entry = that._f; entry; entry = entry.n) {
          if (entry.k == key) return entry;
        }
      };

      module.exports = {
        getConstructor: function getConstructor(wrapper, NAME, IS_MAP, ADDER) {
          var C = wrapper(function (that, iterable) {
            anInstance(that, C, NAME, '_i');
            that._i = create(null); // index
            that._f = undefined; // first entry
            that._l = undefined; // last entry
            that[SIZE] = 0; // size
            if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
          });
          redefineAll(C.prototype, {
            // 23.1.3.1 Map.prototype.clear()
            // 23.2.3.2 Set.prototype.clear()
            clear: function clear() {
              for (var that = this, data = that._i, entry = that._f; entry; entry = entry.n) {
                entry.r = true;
                if (entry.p) entry.p = entry.p.n = undefined;
                delete data[entry.i];
              }
              that._f = that._l = undefined;
              that[SIZE] = 0;
            },
            // 23.1.3.3 Map.prototype.delete(key)
            // 23.2.3.4 Set.prototype.delete(value)
            'delete': function _delete(key) {
              var that = this,
                  entry = getEntry(that, key);
              if (entry) {
                var next = entry.n,
                    prev = entry.p;
                delete that._i[entry.i];
                entry.r = true;
                if (prev) prev.n = next;
                if (next) next.p = prev;
                if (that._f == entry) that._f = next;
                if (that._l == entry) that._l = prev;
                that[SIZE]--;
              }return !!entry;
            },
            // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
            // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
            forEach: function forEach(callbackfn /*, that = undefined */) {
              anInstance(this, C, 'forEach');
              var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3),
                  entry;
              while (entry = entry ? entry.n : this._f) {
                f(entry.v, entry.k, this);
                // revert to the last existing entry
                while (entry && entry.r) {
                  entry = entry.p;
                }
              }
            },
            // 23.1.3.7 Map.prototype.has(key)
            // 23.2.3.7 Set.prototype.has(value)
            has: function has(key) {
              return !!getEntry(this, key);
            }
          });
          if (DESCRIPTORS) dP(C.prototype, 'size', {
            get: function get() {
              return defined(this[SIZE]);
            }
          });
          return C;
        },
        def: function def(that, key, value) {
          var entry = getEntry(that, key),
              prev,
              index;
          // change existing entry
          if (entry) {
            entry.v = value;
            // create new entry
          } else {
            that._l = entry = {
              i: index = fastKey(key, true), // <- index
              k: key, // <- key
              v: value, // <- value
              p: prev = that._l, // <- previous entry
              n: undefined, // <- next entry
              r: false // <- removed
            };
            if (!that._f) that._f = entry;
            if (prev) prev.n = entry;
            that[SIZE]++;
            // add to index
            if (index !== 'F') that._i[index] = entry;
          }return that;
        },
        getEntry: getEntry,
        setStrong: function setStrong(C, NAME, IS_MAP) {
          // add .keys, .values, .entries, [@@iterator]
          // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
          $iterDefine(C, NAME, function (iterated, kind) {
            this._t = iterated; // target
            this._k = kind; // kind
            this._l = undefined; // previous
          }, function () {
            var that = this,
                kind = that._k,
                entry = that._l;
            // revert to the last existing entry
            while (entry && entry.r) {
              entry = entry.p;
            } // get next entry
            if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
              // or finish the iteration
              that._t = undefined;
              return step(1);
            }
            // return step by kind
            if (kind == 'keys') return step(0, entry.k);
            if (kind == 'values') return step(0, entry.v);
            return step(0, [entry.k, entry.v]);
          }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

          // add [@@species], 23.1.2.2, 23.2.2.2
          setSpecies(NAME);
        }
      };
    }, { "./_an-instance": 6, "./_ctx": 19, "./_defined": 20, "./_descriptors": 21, "./_for-of": 26, "./_iter-define": 39, "./_iter-step": 41, "./_meta": 44, "./_object-create": 46, "./_object-dp": 47, "./_redefine-all": 53, "./_set-species": 55 }], 16: [function (_dereq_, module, exports) {
      'use strict';

      // https://github.com/DavidBruant/Map-Set.prototype.toJSON

      var classof = _dereq_('./_classof'),
          from = _dereq_('./_array-from-iterable');
      module.exports = function (NAME) {
        return function toJSON() {
          if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
          return from(this);
        };
      };
    }, { "./_array-from-iterable": 8, "./_classof": 13 }], 17: [function (_dereq_, module, exports) {
      'use strict';

      var global = _dereq_('./_global'),
          $export = _dereq_('./_export'),
          meta = _dereq_('./_meta'),
          fails = _dereq_('./_fails'),
          hide = _dereq_('./_hide'),
          redefineAll = _dereq_('./_redefine-all'),
          forOf = _dereq_('./_for-of'),
          anInstance = _dereq_('./_an-instance'),
          isObject = _dereq_('./_is-object'),
          setToStringTag = _dereq_('./_set-to-string-tag'),
          dP = _dereq_('./_object-dp').f,
          each = _dereq_('./_array-methods')(0),
          DESCRIPTORS = _dereq_('./_descriptors');

      module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
        var Base = global[NAME],
            C = Base,
            ADDER = IS_MAP ? 'set' : 'add',
            proto = C && C.prototype,
            O = {};
        if (!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
          new C().entries().next();
        }))) {
          // create collection constructor
          C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
          redefineAll(C.prototype, methods);
          meta.NEED = true;
        } else {
          C = wrapper(function (target, iterable) {
            anInstance(target, C, NAME, '_c');
            target._c = new Base();
            if (iterable != undefined) forOf(iterable, IS_MAP, target[ADDER], target);
          });
          each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','), function (KEY) {
            var IS_ADDER = KEY == 'add' || KEY == 'set';
            if (KEY in proto && !(IS_WEAK && KEY == 'clear')) hide(C.prototype, KEY, function (a, b) {
              anInstance(this, C, KEY);
              if (!IS_ADDER && IS_WEAK && !isObject(a)) return KEY == 'get' ? undefined : false;
              var result = this._c[KEY](a === 0 ? 0 : a, b);
              return IS_ADDER ? this : result;
            });
          });
          if ('size' in proto) dP(C.prototype, 'size', {
            get: function get() {
              return this._c.size;
            }
          });
        }

        setToStringTag(C, NAME);

        O[NAME] = C;
        $export($export.G + $export.W + $export.F, O);

        if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

        return C;
      };
    }, { "./_an-instance": 6, "./_array-methods": 10, "./_descriptors": 21, "./_export": 24, "./_fails": 25, "./_for-of": 26, "./_global": 27, "./_hide": 29, "./_is-object": 36, "./_meta": 44, "./_object-dp": 47, "./_redefine-all": 53, "./_set-to-string-tag": 56 }], 18: [function (_dereq_, module, exports) {
      'use strict';

      var core = module.exports = { version: '2.4.0' };
      if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
    }, {}], 19: [function (_dereq_, module, exports) {
      'use strict';

      // optional / simple context binding

      var aFunction = _dereq_('./_a-function');
      module.exports = function (fn, that, length) {
        aFunction(fn);
        if (that === undefined) return fn;
        switch (length) {
          case 1:
            return function (a) {
              return fn.call(that, a);
            };
          case 2:
            return function (a, b) {
              return fn.call(that, a, b);
            };
          case 3:
            return function (a, b, c) {
              return fn.call(that, a, b, c);
            };
        }
        return function () /* ...args */{
          return fn.apply(that, arguments);
        };
      };
    }, { "./_a-function": 4 }], 20: [function (_dereq_, module, exports) {
      "use strict";

      // 7.2.1 RequireObjectCoercible(argument)

      module.exports = function (it) {
        if (it == undefined) throw TypeError("Can't call method on  " + it);
        return it;
      };
    }, {}], 21: [function (_dereq_, module, exports) {
      'use strict';

      // Thank's IE8 for his funny defineProperty

      module.exports = !_dereq_('./_fails')(function () {
        return Object.defineProperty({}, 'a', { get: function get() {
            return 7;
          } }).a != 7;
      });
    }, { "./_fails": 25 }], 22: [function (_dereq_, module, exports) {
      'use strict';

      var isObject = _dereq_('./_is-object'),
          document = _dereq_('./_global').document
      // in old IE typeof document.createElement is 'object'

      ,
          is = isObject(document) && isObject(document.createElement);
      module.exports = function (it) {
        return is ? document.createElement(it) : {};
      };
    }, { "./_global": 27, "./_is-object": 36 }], 23: [function (_dereq_, module, exports) {
      'use strict';

      // IE 8- don't enum bug keys

      module.exports = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');
    }, {}], 24: [function (_dereq_, module, exports) {
      'use strict';

      var global = _dereq_('./_global'),
          core = _dereq_('./_core'),
          ctx = _dereq_('./_ctx'),
          hide = _dereq_('./_hide'),
          PROTOTYPE = 'prototype';

      var $export = function $export(type, name, source) {
        var IS_FORCED = type & $export.F,
            IS_GLOBAL = type & $export.G,
            IS_STATIC = type & $export.S,
            IS_PROTO = type & $export.P,
            IS_BIND = type & $export.B,
            IS_WRAP = type & $export.W,
            exports = IS_GLOBAL ? core : core[name] || (core[name] = {}),
            expProto = exports[PROTOTYPE],
            target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE],
            key,
            own,
            out;
        if (IS_GLOBAL) source = name;
        for (key in source) {
          // contains in native
          own = !IS_FORCED && target && target[key] !== undefined;
          if (own && key in exports) continue;
          // export native or passed
          out = own ? target[key] : source[key];
          // prevent global pollution for namespaces
          exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
          // bind timers to global for call from export context
          : IS_BIND && own ? ctx(out, global)
          // wrap global constructors for prevent change them in library
          : IS_WRAP && target[key] == out ? function (C) {
            var F = function F(a, b, c) {
              if (this instanceof C) {
                switch (arguments.length) {
                  case 0:
                    return new C();
                  case 1:
                    return new C(a);
                  case 2:
                    return new C(a, b);
                }return new C(a, b, c);
              }return C.apply(this, arguments);
            };
            F[PROTOTYPE] = C[PROTOTYPE];
            return F;
            // make static versions for prototype methods
          }(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
          // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
          if (IS_PROTO) {
            (exports.virtual || (exports.virtual = {}))[key] = out;
            // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
            if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
          }
        }
      };
      // type bitmap
      $export.F = 1; // forced
      $export.G = 2; // global
      $export.S = 4; // static
      $export.P = 8; // proto
      $export.B = 16; // bind
      $export.W = 32; // wrap
      $export.U = 64; // safe
      $export.R = 128; // real proto method for `library` 
      module.exports = $export;
    }, { "./_core": 18, "./_ctx": 19, "./_global": 27, "./_hide": 29 }], 25: [function (_dereq_, module, exports) {
      "use strict";

      module.exports = function (exec) {
        try {
          return !!exec();
        } catch (e) {
          return true;
        }
      };
    }, {}], 26: [function (_dereq_, module, exports) {
      'use strict';

      var ctx = _dereq_('./_ctx'),
          call = _dereq_('./_iter-call'),
          isArrayIter = _dereq_('./_is-array-iter'),
          anObject = _dereq_('./_an-object'),
          toLength = _dereq_('./_to-length'),
          getIterFn = _dereq_('./core.get-iterator-method'),
          BREAK = {},
          RETURN = {};
      var _exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
        var iterFn = ITERATOR ? function () {
          return iterable;
        } : getIterFn(iterable),
            f = ctx(fn, that, entries ? 2 : 1),
            index = 0,
            length,
            step,
            iterator,
            result;
        if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
        // fast case for arrays with default iterator
        if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
          result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
          if (result === BREAK || result === RETURN) return result;
        } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
          result = call(iterator, f, step.value, entries);
          if (result === BREAK || result === RETURN) return result;
        }
      };
      _exports.BREAK = BREAK;
      _exports.RETURN = RETURN;
    }, { "./_an-object": 7, "./_ctx": 19, "./_is-array-iter": 34, "./_iter-call": 37, "./_to-length": 65, "./core.get-iterator-method": 70 }], 27: [function (_dereq_, module, exports) {
      'use strict';

      // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028

      var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
      if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
    }, {}], 28: [function (_dereq_, module, exports) {
      "use strict";

      var hasOwnProperty = {}.hasOwnProperty;
      module.exports = function (it, key) {
        return hasOwnProperty.call(it, key);
      };
    }, {}], 29: [function (_dereq_, module, exports) {
      'use strict';

      var dP = _dereq_('./_object-dp'),
          createDesc = _dereq_('./_property-desc');
      module.exports = _dereq_('./_descriptors') ? function (object, key, value) {
        return dP.f(object, key, createDesc(1, value));
      } : function (object, key, value) {
        object[key] = value;
        return object;
      };
    }, { "./_descriptors": 21, "./_object-dp": 47, "./_property-desc": 52 }], 30: [function (_dereq_, module, exports) {
      'use strict';

      module.exports = _dereq_('./_global').document && document.documentElement;
    }, { "./_global": 27 }], 31: [function (_dereq_, module, exports) {
      'use strict';

      module.exports = !_dereq_('./_descriptors') && !_dereq_('./_fails')(function () {
        return Object.defineProperty(_dereq_('./_dom-create')('div'), 'a', { get: function get() {
            return 7;
          } }).a != 7;
      });
    }, { "./_descriptors": 21, "./_dom-create": 22, "./_fails": 25 }], 32: [function (_dereq_, module, exports) {
      "use strict";

      // fast apply, http://jsperf.lnkit.com/fast-apply/5

      module.exports = function (fn, args, that) {
        var un = that === undefined;
        switch (args.length) {
          case 0:
            return un ? fn() : fn.call(that);
          case 1:
            return un ? fn(args[0]) : fn.call(that, args[0]);
          case 2:
            return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
          case 3:
            return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
          case 4:
            return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
        }return fn.apply(that, args);
      };
    }, {}], 33: [function (_dereq_, module, exports) {
      'use strict';

      // fallback for non-array-like ES3 and non-enumerable old V8 strings

      var cof = _dereq_('./_cof');
      module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
        return cof(it) == 'String' ? it.split('') : Object(it);
      };
    }, { "./_cof": 14 }], 34: [function (_dereq_, module, exports) {
      'use strict';

      // check on default Array iterator

      var Iterators = _dereq_('./_iterators'),
          ITERATOR = _dereq_('./_wks')('iterator'),
          ArrayProto = Array.prototype;

      module.exports = function (it) {
        return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
      };
    }, { "./_iterators": 42, "./_wks": 69 }], 35: [function (_dereq_, module, exports) {
      'use strict';

      // 7.2.2 IsArray(argument)

      var cof = _dereq_('./_cof');
      module.exports = Array.isArray || function isArray(arg) {
        return cof(arg) == 'Array';
      };
    }, { "./_cof": 14 }], 36: [function (_dereq_, module, exports) {
      'use strict';

      var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
        return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
      } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
      };

      module.exports = function (it) {
        return (typeof it === 'undefined' ? 'undefined' : _typeof(it)) === 'object' ? it !== null : typeof it === 'function';
      };
    }, {}], 37: [function (_dereq_, module, exports) {
      'use strict';

      // call something on iterator step with safe closing on error

      var anObject = _dereq_('./_an-object');
      module.exports = function (iterator, fn, value, entries) {
        try {
          return entries ? fn(anObject(value)[0], value[1]) : fn(value);
          // 7.4.6 IteratorClose(iterator, completion)
        } catch (e) {
          var ret = iterator['return'];
          if (ret !== undefined) anObject(ret.call(iterator));
          throw e;
        }
      };
    }, { "./_an-object": 7 }], 38: [function (_dereq_, module, exports) {
      'use strict';

      var create = _dereq_('./_object-create'),
          descriptor = _dereq_('./_property-desc'),
          setToStringTag = _dereq_('./_set-to-string-tag'),
          IteratorPrototype = {};

      // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
      _dereq_('./_hide')(IteratorPrototype, _dereq_('./_wks')('iterator'), function () {
        return this;
      });

      module.exports = function (Constructor, NAME, next) {
        Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
        setToStringTag(Constructor, NAME + ' Iterator');
      };
    }, { "./_hide": 29, "./_object-create": 46, "./_property-desc": 52, "./_set-to-string-tag": 56, "./_wks": 69 }], 39: [function (_dereq_, module, exports) {
      'use strict';

      var LIBRARY = _dereq_('./_library'),
          $export = _dereq_('./_export'),
          redefine = _dereq_('./_redefine'),
          hide = _dereq_('./_hide'),
          has = _dereq_('./_has'),
          Iterators = _dereq_('./_iterators'),
          $iterCreate = _dereq_('./_iter-create'),
          setToStringTag = _dereq_('./_set-to-string-tag'),
          getPrototypeOf = _dereq_('./_object-gpo'),
          ITERATOR = _dereq_('./_wks')('iterator'),
          BUGGY = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`

      ,
          FF_ITERATOR = '@@iterator',
          KEYS = 'keys',
          VALUES = 'values';

      var returnThis = function returnThis() {
        return this;
      };

      module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
        $iterCreate(Constructor, NAME, next);
        var getMethod = function getMethod(kind) {
          if (!BUGGY && kind in proto) return proto[kind];
          switch (kind) {
            case KEYS:
              return function keys() {
                return new Constructor(this, kind);
              };
            case VALUES:
              return function values() {
                return new Constructor(this, kind);
              };
          }return function entries() {
            return new Constructor(this, kind);
          };
        };
        var TAG = NAME + ' Iterator',
            DEF_VALUES = DEFAULT == VALUES,
            VALUES_BUG = false,
            proto = Base.prototype,
            $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT],
            $default = $native || getMethod(DEFAULT),
            $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined,
            $anyNative = NAME == 'Array' ? proto.entries || $native : $native,
            methods,
            key,
            IteratorPrototype;
        // Fix native
        if ($anyNative) {
          IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
          if (IteratorPrototype !== Object.prototype) {
            // Set @@toStringTag to native iterators
            setToStringTag(IteratorPrototype, TAG, true);
            // fix for some old engines
            if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);
          }
        }
        // fix Array#{values, @@iterator}.name in V8 / FF
        if (DEF_VALUES && $native && $native.name !== VALUES) {
          VALUES_BUG = true;
          $default = function values() {
            return $native.call(this);
          };
        }
        // Define iterator
        if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
          hide(proto, ITERATOR, $default);
        }
        // Plug for library
        Iterators[NAME] = $default;
        Iterators[TAG] = returnThis;
        if (DEFAULT) {
          methods = {
            values: DEF_VALUES ? $default : getMethod(VALUES),
            keys: IS_SET ? $default : getMethod(KEYS),
            entries: $entries
          };
          if (FORCED) for (key in methods) {
            if (!(key in proto)) redefine(proto, key, methods[key]);
          } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
        }
        return methods;
      };
    }, { "./_export": 24, "./_has": 28, "./_hide": 29, "./_iter-create": 38, "./_iterators": 42, "./_library": 43, "./_object-gpo": 49, "./_redefine": 54, "./_set-to-string-tag": 56, "./_wks": 69 }], 40: [function (_dereq_, module, exports) {
      'use strict';

      var ITERATOR = _dereq_('./_wks')('iterator'),
          SAFE_CLOSING = false;

      try {
        var riter = [7][ITERATOR]();
        riter['return'] = function () {
          SAFE_CLOSING = true;
        };
        Array.from(riter, function () {
          throw 2;
        });
      } catch (e) {/* empty */}

      module.exports = function (exec, skipClosing) {
        if (!skipClosing && !SAFE_CLOSING) return false;
        var safe = false;
        try {
          var arr = [7],
              iter = arr[ITERATOR]();
          iter.next = function () {
            return { done: safe = true };
          };
          arr[ITERATOR] = function () {
            return iter;
          };
          exec(arr);
        } catch (e) {/* empty */}
        return safe;
      };
    }, { "./_wks": 69 }], 41: [function (_dereq_, module, exports) {
      "use strict";

      module.exports = function (done, value) {
        return { value: value, done: !!done };
      };
    }, {}], 42: [function (_dereq_, module, exports) {
      "use strict";

      module.exports = {};
    }, {}], 43: [function (_dereq_, module, exports) {
      "use strict";

      module.exports = true;
    }, {}], 44: [function (_dereq_, module, exports) {
      'use strict';

      var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
        return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
      } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
      };

      var META = _dereq_('./_uid')('meta'),
          isObject = _dereq_('./_is-object'),
          has = _dereq_('./_has'),
          setDesc = _dereq_('./_object-dp').f,
          id = 0;
      var isExtensible = Object.isExtensible || function () {
        return true;
      };
      var FREEZE = !_dereq_('./_fails')(function () {
        return isExtensible(Object.preventExtensions({}));
      });
      var setMeta = function setMeta(it) {
        setDesc(it, META, { value: {
            i: 'O' + ++id, // object ID
            w: {} // weak collections IDs
          } });
      };
      var fastKey = function fastKey(it, create) {
        // return primitive with prefix
        if (!isObject(it)) return (typeof it === 'undefined' ? 'undefined' : _typeof(it)) == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
        if (!has(it, META)) {
          // can't set metadata to uncaught frozen object
          if (!isExtensible(it)) return 'F';
          // not necessary to add metadata
          if (!create) return 'E';
          // add missing metadata
          setMeta(it);
          // return object ID
        }return it[META].i;
      };
      var getWeak = function getWeak(it, create) {
        if (!has(it, META)) {
          // can't set metadata to uncaught frozen object
          if (!isExtensible(it)) return true;
          // not necessary to add metadata
          if (!create) return false;
          // add missing metadata
          setMeta(it);
          // return hash weak collections IDs
        }return it[META].w;
      };
      // add metadata on freeze-family methods calling
      var onFreeze = function onFreeze(it) {
        if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
        return it;
      };
      var meta = module.exports = {
        KEY: META,
        NEED: false,
        fastKey: fastKey,
        getWeak: getWeak,
        onFreeze: onFreeze
      };
    }, { "./_fails": 25, "./_has": 28, "./_is-object": 36, "./_object-dp": 47, "./_uid": 68 }], 45: [function (_dereq_, module, exports) {
      'use strict';

      var global = _dereq_('./_global'),
          macrotask = _dereq_('./_task').set,
          Observer = global.MutationObserver || global.WebKitMutationObserver,
          process = global.process,
          Promise = global.Promise,
          isNode = _dereq_('./_cof')(process) == 'process';

      module.exports = function () {
        var head, last, notify;

        var flush = function flush() {
          var parent, fn;
          if (isNode && (parent = process.domain)) parent.exit();
          while (head) {
            fn = head.fn;
            head = head.next;
            try {
              fn();
            } catch (e) {
              if (head) notify();else last = undefined;
              throw e;
            }
          }last = undefined;
          if (parent) parent.enter();
        };

        // Node.js
        if (isNode) {
          notify = function notify() {
            process.nextTick(flush);
          };
          // browsers with MutationObserver
        } else if (Observer) {
          var toggle = true,
              node = document.createTextNode('');
          new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
          notify = function notify() {
            node.data = toggle = !toggle;
          };
          // environments with maybe non-completely correct, but existent Promise
        } else if (Promise && Promise.resolve) {
          var promise = Promise.resolve();
          notify = function notify() {
            promise.then(flush);
          };
          // for other environments - macrotask based on:
          // - setImmediate
          // - MessageChannel
          // - window.postMessag
          // - onreadystatechange
          // - setTimeout
        } else {
          notify = function notify() {
            // strange IE + webpack dev server bug - use .call(global)
            macrotask.call(global, flush);
          };
        }

        return function (fn) {
          var task = { fn: fn, next: undefined };
          if (last) last.next = task;
          if (!head) {
            head = task;
            notify();
          }last = task;
        };
      };
    }, { "./_cof": 14, "./_global": 27, "./_task": 61 }], 46: [function (_dereq_, module, exports) {
      'use strict';

      // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])

      var anObject = _dereq_('./_an-object'),
          dPs = _dereq_('./_object-dps'),
          enumBugKeys = _dereq_('./_enum-bug-keys'),
          IE_PROTO = _dereq_('./_shared-key')('IE_PROTO'),
          Empty = function Empty() {/* empty */},
          PROTOTYPE = 'prototype';

      // Create object with fake `null` prototype: use iframe Object with cleared prototype
      var _createDict = function createDict() {
        // Thrash, waste and sodomy: IE GC bug
        var iframe = _dereq_('./_dom-create')('iframe'),
            i = enumBugKeys.length,
            lt = '<',
            gt = '>',
            iframeDocument;
        iframe.style.display = 'none';
        _dereq_('./_html').appendChild(iframe);
        iframe.src = 'javascript:'; // eslint-disable-line no-script-url
        // createDict = iframe.contentWindow.Object;
        // html.removeChild(iframe);
        iframeDocument = iframe.contentWindow.document;
        iframeDocument.open();
        iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
        iframeDocument.close();
        _createDict = iframeDocument.F;
        while (i--) {
          delete _createDict[PROTOTYPE][enumBugKeys[i]];
        }return _createDict();
      };

      module.exports = Object.create || function create(O, Properties) {
        var result;
        if (O !== null) {
          Empty[PROTOTYPE] = anObject(O);
          result = new Empty();
          Empty[PROTOTYPE] = null;
          // add "__proto__" for Object.getPrototypeOf polyfill
          result[IE_PROTO] = O;
        } else result = _createDict();
        return Properties === undefined ? result : dPs(result, Properties);
      };
    }, { "./_an-object": 7, "./_dom-create": 22, "./_enum-bug-keys": 23, "./_html": 30, "./_object-dps": 48, "./_shared-key": 57 }], 47: [function (_dereq_, module, exports) {
      'use strict';

      var anObject = _dereq_('./_an-object'),
          IE8_DOM_DEFINE = _dereq_('./_ie8-dom-define'),
          toPrimitive = _dereq_('./_to-primitive'),
          dP = Object.defineProperty;

      exports.f = _dereq_('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
        anObject(O);
        P = toPrimitive(P, true);
        anObject(Attributes);
        if (IE8_DOM_DEFINE) try {
          return dP(O, P, Attributes);
        } catch (e) {/* empty */}
        if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
        if ('value' in Attributes) O[P] = Attributes.value;
        return O;
      };
    }, { "./_an-object": 7, "./_descriptors": 21, "./_ie8-dom-define": 31, "./_to-primitive": 67 }], 48: [function (_dereq_, module, exports) {
      'use strict';

      var dP = _dereq_('./_object-dp'),
          anObject = _dereq_('./_an-object'),
          getKeys = _dereq_('./_object-keys');

      module.exports = _dereq_('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {
        anObject(O);
        var keys = getKeys(Properties),
            length = keys.length,
            i = 0,
            P;
        while (length > i) {
          dP.f(O, P = keys[i++], Properties[P]);
        }return O;
      };
    }, { "./_an-object": 7, "./_descriptors": 21, "./_object-dp": 47, "./_object-keys": 51 }], 49: [function (_dereq_, module, exports) {
      'use strict';

      // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)

      var has = _dereq_('./_has'),
          toObject = _dereq_('./_to-object'),
          IE_PROTO = _dereq_('./_shared-key')('IE_PROTO'),
          ObjectProto = Object.prototype;

      module.exports = Object.getPrototypeOf || function (O) {
        O = toObject(O);
        if (has(O, IE_PROTO)) return O[IE_PROTO];
        if (typeof O.constructor == 'function' && O instanceof O.constructor) {
          return O.constructor.prototype;
        }return O instanceof Object ? ObjectProto : null;
      };
    }, { "./_has": 28, "./_shared-key": 57, "./_to-object": 66 }], 50: [function (_dereq_, module, exports) {
      'use strict';

      var has = _dereq_('./_has'),
          toIObject = _dereq_('./_to-iobject'),
          arrayIndexOf = _dereq_('./_array-includes')(false),
          IE_PROTO = _dereq_('./_shared-key')('IE_PROTO');

      module.exports = function (object, names) {
        var O = toIObject(object),
            i = 0,
            result = [],
            key;
        for (key in O) {
          if (key != IE_PROTO) has(O, key) && result.push(key);
        } // Don't enum bug & hidden keys
        while (names.length > i) {
          if (has(O, key = names[i++])) {
            ~arrayIndexOf(result, key) || result.push(key);
          }
        }return result;
      };
    }, { "./_array-includes": 9, "./_has": 28, "./_shared-key": 57, "./_to-iobject": 64 }], 51: [function (_dereq_, module, exports) {
      'use strict';

      // 19.1.2.14 / 15.2.3.14 Object.keys(O)

      var $keys = _dereq_('./_object-keys-internal'),
          enumBugKeys = _dereq_('./_enum-bug-keys');

      module.exports = Object.keys || function keys(O) {
        return $keys(O, enumBugKeys);
      };
    }, { "./_enum-bug-keys": 23, "./_object-keys-internal": 50 }], 52: [function (_dereq_, module, exports) {
      "use strict";

      module.exports = function (bitmap, value) {
        return {
          enumerable: !(bitmap & 1),
          configurable: !(bitmap & 2),
          writable: !(bitmap & 4),
          value: value
        };
      };
    }, {}], 53: [function (_dereq_, module, exports) {
      'use strict';

      var hide = _dereq_('./_hide');
      module.exports = function (target, src, safe) {
        for (var key in src) {
          if (safe && target[key]) target[key] = src[key];else hide(target, key, src[key]);
        }return target;
      };
    }, { "./_hide": 29 }], 54: [function (_dereq_, module, exports) {
      'use strict';

      module.exports = _dereq_('./_hide');
    }, { "./_hide": 29 }], 55: [function (_dereq_, module, exports) {
      'use strict';

      var global = _dereq_('./_global'),
          core = _dereq_('./_core'),
          dP = _dereq_('./_object-dp'),
          DESCRIPTORS = _dereq_('./_descriptors'),
          SPECIES = _dereq_('./_wks')('species');

      module.exports = function (KEY) {
        var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
        if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
          configurable: true,
          get: function get() {
            return this;
          }
        });
      };
    }, { "./_core": 18, "./_descriptors": 21, "./_global": 27, "./_object-dp": 47, "./_wks": 69 }], 56: [function (_dereq_, module, exports) {
      'use strict';

      var def = _dereq_('./_object-dp').f,
          has = _dereq_('./_has'),
          TAG = _dereq_('./_wks')('toStringTag');

      module.exports = function (it, tag, stat) {
        if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
      };
    }, { "./_has": 28, "./_object-dp": 47, "./_wks": 69 }], 57: [function (_dereq_, module, exports) {
      'use strict';

      var shared = _dereq_('./_shared')('keys'),
          uid = _dereq_('./_uid');
      module.exports = function (key) {
        return shared[key] || (shared[key] = uid(key));
      };
    }, { "./_shared": 58, "./_uid": 68 }], 58: [function (_dereq_, module, exports) {
      'use strict';

      var global = _dereq_('./_global'),
          SHARED = '__core-js_shared__',
          store = global[SHARED] || (global[SHARED] = {});
      module.exports = function (key) {
        return store[key] || (store[key] = {});
      };
    }, { "./_global": 27 }], 59: [function (_dereq_, module, exports) {
      'use strict';

      // 7.3.20 SpeciesConstructor(O, defaultConstructor)

      var anObject = _dereq_('./_an-object'),
          aFunction = _dereq_('./_a-function'),
          SPECIES = _dereq_('./_wks')('species');
      module.exports = function (O, D) {
        var C = anObject(O).constructor,
            S;
        return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
      };
    }, { "./_a-function": 4, "./_an-object": 7, "./_wks": 69 }], 60: [function (_dereq_, module, exports) {
      'use strict';

      var toInteger = _dereq_('./_to-integer'),
          defined = _dereq_('./_defined');
      // true  -> String#at
      // false -> String#codePointAt
      module.exports = function (TO_STRING) {
        return function (that, pos) {
          var s = String(defined(that)),
              i = toInteger(pos),
              l = s.length,
              a,
              b;
          if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
          a = s.charCodeAt(i);
          return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
        };
      };
    }, { "./_defined": 20, "./_to-integer": 63 }], 61: [function (_dereq_, module, exports) {
      'use strict';

      var ctx = _dereq_('./_ctx'),
          invoke = _dereq_('./_invoke'),
          html = _dereq_('./_html'),
          cel = _dereq_('./_dom-create'),
          global = _dereq_('./_global'),
          process = global.process,
          setTask = global.setImmediate,
          clearTask = global.clearImmediate,
          MessageChannel = global.MessageChannel,
          counter = 0,
          queue = {},
          ONREADYSTATECHANGE = 'onreadystatechange',
          defer,
          channel,
          port;
      var run = function run() {
        var id = +this;
        if (queue.hasOwnProperty(id)) {
          var fn = queue[id];
          delete queue[id];
          fn();
        }
      };
      var listener = function listener(event) {
        run.call(event.data);
      };
      // Node.js 0.9+ & IE10+ has setImmediate, otherwise:
      if (!setTask || !clearTask) {
        setTask = function setImmediate(fn) {
          var args = [],
              i = 1;
          while (arguments.length > i) {
            args.push(arguments[i++]);
          }queue[++counter] = function () {
            invoke(typeof fn == 'function' ? fn : Function(fn), args);
          };
          defer(counter);
          return counter;
        };
        clearTask = function clearImmediate(id) {
          delete queue[id];
        };
        // Node.js 0.8-
        if (_dereq_('./_cof')(process) == 'process') {
          defer = function defer(id) {
            process.nextTick(ctx(run, id, 1));
          };
          // Browsers with MessageChannel, includes WebWorkers
        } else if (MessageChannel) {
          channel = new MessageChannel();
          port = channel.port2;
          channel.port1.onmessage = listener;
          defer = ctx(port.postMessage, port, 1);
          // Browsers with postMessage, skip WebWorkers
          // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
        } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
          defer = function defer(id) {
            global.postMessage(id + '', '*');
          };
          global.addEventListener('message', listener, false);
          // IE8-
        } else if (ONREADYSTATECHANGE in cel('script')) {
          defer = function defer(id) {
            html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
              html.removeChild(this);
              run.call(id);
            };
          };
          // Rest old browsers
        } else {
          defer = function defer(id) {
            setTimeout(ctx(run, id, 1), 0);
          };
        }
      }
      module.exports = {
        set: setTask,
        clear: clearTask
      };
    }, { "./_cof": 14, "./_ctx": 19, "./_dom-create": 22, "./_global": 27, "./_html": 30, "./_invoke": 32 }], 62: [function (_dereq_, module, exports) {
      'use strict';

      var toInteger = _dereq_('./_to-integer'),
          max = Math.max,
          min = Math.min;
      module.exports = function (index, length) {
        index = toInteger(index);
        return index < 0 ? max(index + length, 0) : min(index, length);
      };
    }, { "./_to-integer": 63 }], 63: [function (_dereq_, module, exports) {
      "use strict";

      // 7.1.4 ToInteger

      var ceil = Math.ceil,
          floor = Math.floor;
      module.exports = function (it) {
        return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
      };
    }, {}], 64: [function (_dereq_, module, exports) {
      'use strict';

      // to indexed object, toObject with fallback for non-array-like ES3 strings

      var IObject = _dereq_('./_iobject'),
          defined = _dereq_('./_defined');
      module.exports = function (it) {
        return IObject(defined(it));
      };
    }, { "./_defined": 20, "./_iobject": 33 }], 65: [function (_dereq_, module, exports) {
      'use strict';

      // 7.1.15 ToLength

      var toInteger = _dereq_('./_to-integer'),
          min = Math.min;
      module.exports = function (it) {
        return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
      };
    }, { "./_to-integer": 63 }], 66: [function (_dereq_, module, exports) {
      'use strict';

      // 7.1.13 ToObject(argument)

      var defined = _dereq_('./_defined');
      module.exports = function (it) {
        return Object(defined(it));
      };
    }, { "./_defined": 20 }], 67: [function (_dereq_, module, exports) {
      'use strict';

      // 7.1.1 ToPrimitive(input [, PreferredType])

      var isObject = _dereq_('./_is-object');
      // instead of the ES6 spec version, we didn't implement @@toPrimitive case
      // and the second argument - flag - preferred type is a string
      module.exports = function (it, S) {
        if (!isObject(it)) return it;
        var fn, val;
        if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
        if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
        if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
        throw TypeError("Can't convert object to primitive value");
      };
    }, { "./_is-object": 36 }], 68: [function (_dereq_, module, exports) {
      'use strict';

      var id = 0,
          px = Math.random();
      module.exports = function (key) {
        return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
      };
    }, {}], 69: [function (_dereq_, module, exports) {
      'use strict';

      var store = _dereq_('./_shared')('wks'),
          uid = _dereq_('./_uid'),
          _Symbol = _dereq_('./_global').Symbol,
          USE_SYMBOL = typeof _Symbol == 'function';

      var $exports = module.exports = function (name) {
        return store[name] || (store[name] = USE_SYMBOL && _Symbol[name] || (USE_SYMBOL ? _Symbol : uid)('Symbol.' + name));
      };

      $exports.store = store;
    }, { "./_global": 27, "./_shared": 58, "./_uid": 68 }], 70: [function (_dereq_, module, exports) {
      'use strict';

      var classof = _dereq_('./_classof'),
          ITERATOR = _dereq_('./_wks')('iterator'),
          Iterators = _dereq_('./_iterators');
      module.exports = _dereq_('./_core').getIteratorMethod = function (it) {
        if (it != undefined) return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
      };
    }, { "./_classof": 13, "./_core": 18, "./_iterators": 42, "./_wks": 69 }], 71: [function (_dereq_, module, exports) {
      'use strict';

      var addToUnscopables = _dereq_('./_add-to-unscopables'),
          step = _dereq_('./_iter-step'),
          Iterators = _dereq_('./_iterators'),
          toIObject = _dereq_('./_to-iobject');

      // 22.1.3.4 Array.prototype.entries()
      // 22.1.3.13 Array.prototype.keys()
      // 22.1.3.29 Array.prototype.values()
      // 22.1.3.30 Array.prototype[@@iterator]()
      module.exports = _dereq_('./_iter-define')(Array, 'Array', function (iterated, kind) {
        this._t = toIObject(iterated); // target
        this._i = 0; // next index
        this._k = kind; // kind
        // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
      }, function () {
        var O = this._t,
            kind = this._k,
            index = this._i++;
        if (!O || index >= O.length) {
          this._t = undefined;
          return step(1);
        }
        if (kind == 'keys') return step(0, index);
        if (kind == 'values') return step(0, O[index]);
        return step(0, [index, O[index]]);
      }, 'values');

      // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
      Iterators.Arguments = Iterators.Array;

      addToUnscopables('keys');
      addToUnscopables('values');
      addToUnscopables('entries');
    }, { "./_add-to-unscopables": 5, "./_iter-define": 39, "./_iter-step": 41, "./_iterators": 42, "./_to-iobject": 64 }], 72: [function (_dereq_, module, exports) {
      'use strict';

      var strong = _dereq_('./_collection-strong');

      // 23.1 Map Objects
      module.exports = _dereq_('./_collection')('Map', function (get) {
        return function Map() {
          return get(this, arguments.length > 0 ? arguments[0] : undefined);
        };
      }, {
        // 23.1.3.6 Map.prototype.get(key)
        get: function get(key) {
          var entry = strong.getEntry(this, key);
          return entry && entry.v;
        },
        // 23.1.3.9 Map.prototype.set(key, value)
        set: function set(key, value) {
          return strong.def(this, key === 0 ? 0 : key, value);
        }
      }, strong, true);
    }, { "./_collection": 17, "./_collection-strong": 15 }], 73: [function (_dereq_, module, exports) {
      "use strict";
    }, {}], 74: [function (_dereq_, module, exports) {
      'use strict';

      var LIBRARY = _dereq_('./_library'),
          global = _dereq_('./_global'),
          ctx = _dereq_('./_ctx'),
          classof = _dereq_('./_classof'),
          $export = _dereq_('./_export'),
          isObject = _dereq_('./_is-object'),
          aFunction = _dereq_('./_a-function'),
          anInstance = _dereq_('./_an-instance'),
          forOf = _dereq_('./_for-of'),
          speciesConstructor = _dereq_('./_species-constructor'),
          task = _dereq_('./_task').set,
          microtask = _dereq_('./_microtask')(),
          PROMISE = 'Promise',
          TypeError = global.TypeError,
          process = global.process,
          $Promise = global[PROMISE],
          process = global.process,
          isNode = classof(process) == 'process',
          empty = function empty() {/* empty */},
          Internal,
          GenericPromiseCapability,
          Wrapper;

      var USE_NATIVE = !!function () {
        try {
          // correct subclassing with @@species support
          var promise = $Promise.resolve(1),
              FakePromise = (promise.constructor = {})[_dereq_('./_wks')('species')] = function (exec) {
            exec(empty, empty);
          };
          // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
          return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
        } catch (e) {/* empty */}
      }();

      // helpers
      var sameConstructor = function sameConstructor(a, b) {
        // with library wrapper special case
        return a === b || a === $Promise && b === Wrapper;
      };
      var isThenable = function isThenable(it) {
        var then;
        return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
      };
      var newPromiseCapability = function newPromiseCapability(C) {
        return sameConstructor($Promise, C) ? new PromiseCapability(C) : new GenericPromiseCapability(C);
      };
      var PromiseCapability = GenericPromiseCapability = function GenericPromiseCapability(C) {
        var resolve, reject;
        this.promise = new C(function ($$resolve, $$reject) {
          if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
          resolve = $$resolve;
          reject = $$reject;
        });
        this.resolve = aFunction(resolve);
        this.reject = aFunction(reject);
      };
      var perform = function perform(exec) {
        try {
          exec();
        } catch (e) {
          return { error: e };
        }
      };
      var notify = function notify(promise, isReject) {
        if (promise._n) return;
        promise._n = true;
        var chain = promise._c;
        microtask(function () {
          var value = promise._v,
              ok = promise._s == 1,
              i = 0;
          var run = function run(reaction) {
            var handler = ok ? reaction.ok : reaction.fail,
                resolve = reaction.resolve,
                reject = reaction.reject,
                domain = reaction.domain,
                result,
                then;
            try {
              if (handler) {
                if (!ok) {
                  if (promise._h == 2) onHandleUnhandled(promise);
                  promise._h = 1;
                }
                if (handler === true) result = value;else {
                  if (domain) domain.enter();
                  result = handler(value);
                  if (domain) domain.exit();
                }
                if (result === reaction.promise) {
                  reject(TypeError('Promise-chain cycle'));
                } else if (then = isThenable(result)) {
                  then.call(result, resolve, reject);
                } else resolve(result);
              } else reject(value);
            } catch (e) {
              reject(e);
            }
          };
          while (chain.length > i) {
            run(chain[i++]);
          } // variable length - can't use forEach
          promise._c = [];
          promise._n = false;
          if (isReject && !promise._h) onUnhandled(promise);
        });
      };
      var onUnhandled = function onUnhandled(promise) {
        task.call(global, function () {
          var value = promise._v,
              abrupt,
              handler,
              console;
          if (isUnhandled(promise)) {
            abrupt = perform(function () {
              if (isNode) {
                process.emit('unhandledRejection', value, promise);
              } else if (handler = global.onunhandledrejection) {
                handler({ promise: promise, reason: value });
              } else if ((console = global.console) && console.error) {
                console.error('Unhandled promise rejection', value);
              }
            });
            // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
            promise._h = isNode || isUnhandled(promise) ? 2 : 1;
          }promise._a = undefined;
          if (abrupt) throw abrupt.error;
        });
      };
      var isUnhandled = function isUnhandled(promise) {
        if (promise._h == 1) return false;
        var chain = promise._a || promise._c,
            i = 0,
            reaction;
        while (chain.length > i) {
          reaction = chain[i++];
          if (reaction.fail || !isUnhandled(reaction.promise)) return false;
        }return true;
      };
      var onHandleUnhandled = function onHandleUnhandled(promise) {
        task.call(global, function () {
          var handler;
          if (isNode) {
            process.emit('rejectionHandled', promise);
          } else if (handler = global.onrejectionhandled) {
            handler({ promise: promise, reason: promise._v });
          }
        });
      };
      var $reject = function $reject(value) {
        var promise = this;
        if (promise._d) return;
        promise._d = true;
        promise = promise._w || promise; // unwrap
        promise._v = value;
        promise._s = 2;
        if (!promise._a) promise._a = promise._c.slice();
        notify(promise, true);
      };
      var $resolve = function $resolve(value) {
        var promise = this,
            then;
        if (promise._d) return;
        promise._d = true;
        promise = promise._w || promise; // unwrap
        try {
          if (promise === value) throw TypeError("Promise can't be resolved itself");
          if (then = isThenable(value)) {
            microtask(function () {
              var wrapper = { _w: promise, _d: false }; // wrap
              try {
                then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
              } catch (e) {
                $reject.call(wrapper, e);
              }
            });
          } else {
            promise._v = value;
            promise._s = 1;
            notify(promise, false);
          }
        } catch (e) {
          $reject.call({ _w: promise, _d: false }, e); // wrap
        }
      };

      // constructor polyfill
      if (!USE_NATIVE) {
        // 25.4.3.1 Promise(executor)
        $Promise = function Promise(executor) {
          anInstance(this, $Promise, PROMISE, '_h');
          aFunction(executor);
          Internal.call(this);
          try {
            executor(ctx($resolve, this, 1), ctx($reject, this, 1));
          } catch (err) {
            $reject.call(this, err);
          }
        };
        Internal = function Promise(executor) {
          this._c = []; // <- awaiting reactions
          this._a = undefined; // <- checked in isUnhandled reactions
          this._s = 0; // <- state
          this._d = false; // <- done
          this._v = undefined; // <- value
          this._h = 0; // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
          this._n = false; // <- notify
        };
        Internal.prototype = _dereq_('./_redefine-all')($Promise.prototype, {
          // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
          then: function then(onFulfilled, onRejected) {
            var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
            reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
            reaction.fail = typeof onRejected == 'function' && onRejected;
            reaction.domain = isNode ? process.domain : undefined;
            this._c.push(reaction);
            if (this._a) this._a.push(reaction);
            if (this._s) notify(this, false);
            return reaction.promise;
          },
          // 25.4.5.1 Promise.prototype.catch(onRejected)
          'catch': function _catch(onRejected) {
            return this.then(undefined, onRejected);
          }
        });
        PromiseCapability = function PromiseCapability() {
          var promise = new Internal();
          this.promise = promise;
          this.resolve = ctx($resolve, promise, 1);
          this.reject = ctx($reject, promise, 1);
        };
      }

      $export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
      _dereq_('./_set-to-string-tag')($Promise, PROMISE);
      _dereq_('./_set-species')(PROMISE);
      Wrapper = _dereq_('./_core')[PROMISE];

      // statics
      $export($export.S + $export.F * !USE_NATIVE, PROMISE, {
        // 25.4.4.5 Promise.reject(r)
        reject: function reject(r) {
          var capability = newPromiseCapability(this),
              $$reject = capability.reject;
          $$reject(r);
          return capability.promise;
        }
      });
      $export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
        // 25.4.4.6 Promise.resolve(x)
        resolve: function resolve(x) {
          // instanceof instead of internal slot check because we should fix it without replacement native Promise core
          if (x instanceof $Promise && sameConstructor(x.constructor, this)) return x;
          var capability = newPromiseCapability(this),
              $$resolve = capability.resolve;
          $$resolve(x);
          return capability.promise;
        }
      });
      $export($export.S + $export.F * !(USE_NATIVE && _dereq_('./_iter-detect')(function (iter) {
        $Promise.all(iter)['catch'](empty);
      })), PROMISE, {
        // 25.4.4.1 Promise.all(iterable)
        all: function all(iterable) {
          var C = this,
              capability = newPromiseCapability(C),
              resolve = capability.resolve,
              reject = capability.reject;
          var abrupt = perform(function () {
            var values = [],
                index = 0,
                remaining = 1;
            forOf(iterable, false, function (promise) {
              var $index = index++,
                  alreadyCalled = false;
              values.push(undefined);
              remaining++;
              C.resolve(promise).then(function (value) {
                if (alreadyCalled) return;
                alreadyCalled = true;
                values[$index] = value;
                --remaining || resolve(values);
              }, reject);
            });
            --remaining || resolve(values);
          });
          if (abrupt) reject(abrupt.error);
          return capability.promise;
        },
        // 25.4.4.4 Promise.race(iterable)
        race: function race(iterable) {
          var C = this,
              capability = newPromiseCapability(C),
              reject = capability.reject;
          var abrupt = perform(function () {
            forOf(iterable, false, function (promise) {
              C.resolve(promise).then(capability.resolve, reject);
            });
          });
          if (abrupt) reject(abrupt.error);
          return capability.promise;
        }
      });
    }, { "./_a-function": 4, "./_an-instance": 6, "./_classof": 13, "./_core": 18, "./_ctx": 19, "./_export": 24, "./_for-of": 26, "./_global": 27, "./_is-object": 36, "./_iter-detect": 40, "./_library": 43, "./_microtask": 45, "./_redefine-all": 53, "./_set-species": 55, "./_set-to-string-tag": 56, "./_species-constructor": 59, "./_task": 61, "./_wks": 69 }], 75: [function (_dereq_, module, exports) {
      'use strict';

      var strong = _dereq_('./_collection-strong');

      // 23.2 Set Objects
      module.exports = _dereq_('./_collection')('Set', function (get) {
        return function Set() {
          return get(this, arguments.length > 0 ? arguments[0] : undefined);
        };
      }, {
        // 23.2.3.1 Set.prototype.add(value)
        add: function add(value) {
          return strong.def(this, value = value === 0 ? 0 : value, value);
        }
      }, strong);
    }, { "./_collection": 17, "./_collection-strong": 15 }], 76: [function (_dereq_, module, exports) {
      'use strict';

      var $at = _dereq_('./_string-at')(true);

      // 21.1.3.27 String.prototype[@@iterator]()
      _dereq_('./_iter-define')(String, 'String', function (iterated) {
        this._t = String(iterated); // target
        this._i = 0; // next index
        // 21.1.5.2.1 %StringIteratorPrototype%.next()
      }, function () {
        var O = this._t,
            index = this._i,
            point;
        if (index >= O.length) return { value: undefined, done: true };
        point = $at(O, index);
        this._i += point.length;
        return { value: point, done: false };
      });
    }, { "./_iter-define": 39, "./_string-at": 60 }], 77: [function (_dereq_, module, exports) {
      'use strict';

      // https://github.com/DavidBruant/Map-Set.prototype.toJSON

      var $export = _dereq_('./_export');

      $export($export.P + $export.R, 'Map', { toJSON: _dereq_('./_collection-to-json')('Map') });
    }, { "./_collection-to-json": 16, "./_export": 24 }], 78: [function (_dereq_, module, exports) {
      'use strict';

      // https://github.com/DavidBruant/Map-Set.prototype.toJSON

      var $export = _dereq_('./_export');

      $export($export.P + $export.R, 'Set', { toJSON: _dereq_('./_collection-to-json')('Set') });
    }, { "./_collection-to-json": 16, "./_export": 24 }], 79: [function (_dereq_, module, exports) {
      'use strict';

      _dereq_('./es6.array.iterator');
      var global = _dereq_('./_global'),
          hide = _dereq_('./_hide'),
          Iterators = _dereq_('./_iterators'),
          TO_STRING_TAG = _dereq_('./_wks')('toStringTag');

      for (var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++) {
        var NAME = collections[i],
            Collection = global[NAME],
            proto = Collection && Collection.prototype;
        if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
        Iterators[NAME] = Iterators.Array;
      }
    }, { "./_global": 27, "./_hide": 29, "./_iterators": 42, "./_wks": 69, "./es6.array.iterator": 71 }], 80: [function (_dereq_, module, exports) {
      (function (global) {
        "use strict";

        _dereq_("core-js/shim");

        _dereq_("regenerator-runtime/runtime");

        _dereq_("core-js/fn/regexp/escape");

        if (global._babelPolyfill) {
          throw new Error("only one instance of babel-polyfill is allowed");
        }
        global._babelPolyfill = true;

        var DEFINE_PROPERTY = "defineProperty";
        function define(O, key, value) {
          O[key] || Object[DEFINE_PROPERTY](O, key, {
            writable: true,
            configurable: true,
            value: value
          });
        }

        define(String.prototype, "padLeft", "".padStart);
        define(String.prototype, "padRight", "".padEnd);

        "pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) {
          [][key] && define(Array, key, Function.call.bind([][key]));
        });
      }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, { "core-js/fn/regexp/escape": 81, "core-js/shim": 374, "regenerator-runtime/runtime": 377 }], 81: [function (_dereq_, module, exports) {
      _dereq_('../../modules/core.regexp.escape');
      module.exports = _dereq_('../../modules/_core').RegExp.escape;
    }, { "../../modules/_core": 102, "../../modules/core.regexp.escape": 198 }], 82: [function (_dereq_, module, exports) {
      module.exports = function (it) {
        if (typeof it != 'function') throw TypeError(it + ' is not a function!');
        return it;
      };
    }, {}], 83: [function (_dereq_, module, exports) {
      var cof = _dereq_('./_cof');
      module.exports = function (it, msg) {
        if (typeof it != 'number' && cof(it) != 'Number') throw TypeError(msg);
        return +it;
      };
    }, { "./_cof": 97 }], 84: [function (_dereq_, module, exports) {
      // 22.1.3.31 Array.prototype[@@unscopables]
      var UNSCOPABLES = _dereq_('./_wks')('unscopables'),
          ArrayProto = Array.prototype;
      if (ArrayProto[UNSCOPABLES] == undefined) _dereq_('./_hide')(ArrayProto, UNSCOPABLES, {});
      module.exports = function (key) {
        ArrayProto[UNSCOPABLES][key] = true;
      };
    }, { "./_hide": 119, "./_wks": 196 }], 85: [function (_dereq_, module, exports) {
      module.exports = function (it, Constructor, name, forbiddenField) {
        if (!(it instanceof Constructor) || forbiddenField !== undefined && forbiddenField in it) {
          throw TypeError(name + ': incorrect invocation!');
        }return it;
      };
    }, {}], 86: [function (_dereq_, module, exports) {
      var isObject = _dereq_('./_is-object');
      module.exports = function (it) {
        if (!isObject(it)) throw TypeError(it + ' is not an object!');
        return it;
      };
    }, { "./_is-object": 128 }], 87: [function (_dereq_, module, exports) {
      // 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
      'use strict';

      var toObject = _dereq_('./_to-object'),
          toIndex = _dereq_('./_to-index'),
          toLength = _dereq_('./_to-length');

      module.exports = [].copyWithin || function copyWithin(target /*= 0*/, start /*= 0, end = @length*/) {
        var O = toObject(this),
            len = toLength(O.length),
            to = toIndex(target, len),
            from = toIndex(start, len),
            end = arguments.length > 2 ? arguments[2] : undefined,
            count = Math.min((end === undefined ? len : toIndex(end, len)) - from, len - to),
            inc = 1;
        if (from < to && to < from + count) {
          inc = -1;
          from += count - 1;
          to += count - 1;
        }
        while (count-- > 0) {
          if (from in O) O[to] = O[from];else delete O[to];
          to += inc;
          from += inc;
        }return O;
      };
    }, { "./_to-index": 184, "./_to-length": 187, "./_to-object": 188 }], 88: [function (_dereq_, module, exports) {
      // 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
      'use strict';

      var toObject = _dereq_('./_to-object'),
          toIndex = _dereq_('./_to-index'),
          toLength = _dereq_('./_to-length');
      module.exports = function fill(value /*, start = 0, end = @length */) {
        var O = toObject(this),
            length = toLength(O.length),
            aLen = arguments.length,
            index = toIndex(aLen > 1 ? arguments[1] : undefined, length),
            end = aLen > 2 ? arguments[2] : undefined,
            endPos = end === undefined ? length : toIndex(end, length);
        while (endPos > index) {
          O[index++] = value;
        }return O;
      };
    }, { "./_to-index": 184, "./_to-length": 187, "./_to-object": 188 }], 89: [function (_dereq_, module, exports) {
      var forOf = _dereq_('./_for-of');

      module.exports = function (iter, ITERATOR) {
        var result = [];
        forOf(iter, false, result.push, result, ITERATOR);
        return result;
      };
    }, { "./_for-of": 116 }], 90: [function (_dereq_, module, exports) {
      // false -> Array#indexOf
      // true  -> Array#includes
      var toIObject = _dereq_('./_to-iobject'),
          toLength = _dereq_('./_to-length'),
          toIndex = _dereq_('./_to-index');
      module.exports = function (IS_INCLUDES) {
        return function ($this, el, fromIndex) {
          var O = toIObject($this),
              length = toLength(O.length),
              index = toIndex(fromIndex, length),
              value;
          // Array#includes uses SameValueZero equality algorithm
          if (IS_INCLUDES && el != el) while (length > index) {
            value = O[index++];
            if (value != value) return true;
            // Array#toIndex ignores holes, Array#includes - not
          } else for (; length > index; index++) {
            if (IS_INCLUDES || index in O) {
              if (O[index] === el) return IS_INCLUDES || index || 0;
            }
          }return !IS_INCLUDES && -1;
        };
      };
    }, { "./_to-index": 184, "./_to-iobject": 186, "./_to-length": 187 }], 91: [function (_dereq_, module, exports) {
      // 0 -> Array#forEach
      // 1 -> Array#map
      // 2 -> Array#filter
      // 3 -> Array#some
      // 4 -> Array#every
      // 5 -> Array#find
      // 6 -> Array#findIndex
      var ctx = _dereq_('./_ctx'),
          IObject = _dereq_('./_iobject'),
          toObject = _dereq_('./_to-object'),
          toLength = _dereq_('./_to-length'),
          asc = _dereq_('./_array-species-create');
      module.exports = function (TYPE, $create) {
        var IS_MAP = TYPE == 1,
            IS_FILTER = TYPE == 2,
            IS_SOME = TYPE == 3,
            IS_EVERY = TYPE == 4,
            IS_FIND_INDEX = TYPE == 6,
            NO_HOLES = TYPE == 5 || IS_FIND_INDEX,
            create = $create || asc;
        return function ($this, callbackfn, that) {
          var O = toObject($this),
              self = IObject(O),
              f = ctx(callbackfn, that, 3),
              length = toLength(self.length),
              index = 0,
              result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined,
              val,
              res;
          for (; length > index; index++) {
            if (NO_HOLES || index in self) {
              val = self[index];
              res = f(val, index, O);
              if (TYPE) {
                if (IS_MAP) result[index] = res; // map
                else if (res) switch (TYPE) {
                    case 3:
                      return true; // some
                    case 5:
                      return val; // find
                    case 6:
                      return index; // findIndex
                    case 2:
                      result.push(val); // filter
                  } else if (IS_EVERY) return false; // every
              }
            }
          }return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
        };
      };
    }, { "./_array-species-create": 94, "./_ctx": 104, "./_iobject": 124, "./_to-length": 187, "./_to-object": 188 }], 92: [function (_dereq_, module, exports) {
      var aFunction = _dereq_('./_a-function'),
          toObject = _dereq_('./_to-object'),
          IObject = _dereq_('./_iobject'),
          toLength = _dereq_('./_to-length');

      module.exports = function (that, callbackfn, aLen, memo, isRight) {
        aFunction(callbackfn);
        var O = toObject(that),
            self = IObject(O),
            length = toLength(O.length),
            index = isRight ? length - 1 : 0,
            i = isRight ? -1 : 1;
        if (aLen < 2) for (;;) {
          if (index in self) {
            memo = self[index];
            index += i;
            break;
          }
          index += i;
          if (isRight ? index < 0 : length <= index) {
            throw TypeError('Reduce of empty array with no initial value');
          }
        }
        for (; isRight ? index >= 0 : length > index; index += i) {
          if (index in self) {
            memo = callbackfn(memo, self[index], index, O);
          }
        }return memo;
      };
    }, { "./_a-function": 82, "./_iobject": 124, "./_to-length": 187, "./_to-object": 188 }], 93: [function (_dereq_, module, exports) {
      var isObject = _dereq_('./_is-object'),
          isArray = _dereq_('./_is-array'),
          SPECIES = _dereq_('./_wks')('species');

      module.exports = function (original) {
        var C;
        if (isArray(original)) {
          C = original.constructor;
          // cross-realm fallback
          if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
          if (isObject(C)) {
            C = C[SPECIES];
            if (C === null) C = undefined;
          }
        }return C === undefined ? Array : C;
      };
    }, { "./_is-array": 126, "./_is-object": 128, "./_wks": 196 }], 94: [function (_dereq_, module, exports) {
      // 9.4.2.3 ArraySpeciesCreate(originalArray, length)
      var speciesConstructor = _dereq_('./_array-species-constructor');

      module.exports = function (original, length) {
        return new (speciesConstructor(original))(length);
      };
    }, { "./_array-species-constructor": 93 }], 95: [function (_dereq_, module, exports) {
      'use strict';

      var aFunction = _dereq_('./_a-function'),
          isObject = _dereq_('./_is-object'),
          invoke = _dereq_('./_invoke'),
          arraySlice = [].slice,
          factories = {};

      var construct = function construct(F, len, args) {
        if (!(len in factories)) {
          for (var n = [], i = 0; i < len; i++) {
            n[i] = 'a[' + i + ']';
          }factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
        }return factories[len](F, args);
      };

      module.exports = Function.bind || function bind(that /*, args... */) {
        var fn = aFunction(this),
            partArgs = arraySlice.call(arguments, 1);
        var bound = function bound() /* args... */{
          var args = partArgs.concat(arraySlice.call(arguments));
          return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
        };
        if (isObject(fn.prototype)) bound.prototype = fn.prototype;
        return bound;
      };
    }, { "./_a-function": 82, "./_invoke": 123, "./_is-object": 128 }], 96: [function (_dereq_, module, exports) {
      // getting tag from 19.1.3.6 Object.prototype.toString()
      var cof = _dereq_('./_cof'),
          TAG = _dereq_('./_wks')('toStringTag')
      // ES3 wrong here
      ,
          ARG = cof(function () {
        return arguments;
      }()) == 'Arguments';

      // fallback for IE11 Script Access Denied error
      var tryGet = function tryGet(it, key) {
        try {
          return it[key];
        } catch (e) {/* empty */}
      };

      module.exports = function (it) {
        var O, T, B;
        return it === undefined ? 'Undefined' : it === null ? 'Null'
        // @@toStringTag case
        : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
        // builtinTag case
        : ARG ? cof(O)
        // ES3 arguments fallback
        : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
      };
    }, { "./_cof": 97, "./_wks": 196 }], 97: [function (_dereq_, module, exports) {
      var toString = {}.toString;

      module.exports = function (it) {
        return toString.call(it).slice(8, -1);
      };
    }, {}], 98: [function (_dereq_, module, exports) {
      'use strict';

      var dP = _dereq_('./_object-dp').f,
          create = _dereq_('./_object-create'),
          redefineAll = _dereq_('./_redefine-all'),
          ctx = _dereq_('./_ctx'),
          anInstance = _dereq_('./_an-instance'),
          defined = _dereq_('./_defined'),
          forOf = _dereq_('./_for-of'),
          $iterDefine = _dereq_('./_iter-define'),
          step = _dereq_('./_iter-step'),
          setSpecies = _dereq_('./_set-species'),
          DESCRIPTORS = _dereq_('./_descriptors'),
          fastKey = _dereq_('./_meta').fastKey,
          SIZE = DESCRIPTORS ? '_s' : 'size';

      var getEntry = function getEntry(that, key) {
        // fast case
        var index = fastKey(key),
            entry;
        if (index !== 'F') return that._i[index];
        // frozen object case
        for (entry = that._f; entry; entry = entry.n) {
          if (entry.k == key) return entry;
        }
      };

      module.exports = {
        getConstructor: function getConstructor(wrapper, NAME, IS_MAP, ADDER) {
          var C = wrapper(function (that, iterable) {
            anInstance(that, C, NAME, '_i');
            that._i = create(null); // index
            that._f = undefined; // first entry
            that._l = undefined; // last entry
            that[SIZE] = 0; // size
            if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
          });
          redefineAll(C.prototype, {
            // 23.1.3.1 Map.prototype.clear()
            // 23.2.3.2 Set.prototype.clear()
            clear: function clear() {
              for (var that = this, data = that._i, entry = that._f; entry; entry = entry.n) {
                entry.r = true;
                if (entry.p) entry.p = entry.p.n = undefined;
                delete data[entry.i];
              }
              that._f = that._l = undefined;
              that[SIZE] = 0;
            },
            // 23.1.3.3 Map.prototype.delete(key)
            // 23.2.3.4 Set.prototype.delete(value)
            'delete': function _delete(key) {
              var that = this,
                  entry = getEntry(that, key);
              if (entry) {
                var next = entry.n,
                    prev = entry.p;
                delete that._i[entry.i];
                entry.r = true;
                if (prev) prev.n = next;
                if (next) next.p = prev;
                if (that._f == entry) that._f = next;
                if (that._l == entry) that._l = prev;
                that[SIZE]--;
              }return !!entry;
            },
            // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
            // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
            forEach: function forEach(callbackfn /*, that = undefined */) {
              anInstance(this, C, 'forEach');
              var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3),
                  entry;
              while (entry = entry ? entry.n : this._f) {
                f(entry.v, entry.k, this);
                // revert to the last existing entry
                while (entry && entry.r) {
                  entry = entry.p;
                }
              }
            },
            // 23.1.3.7 Map.prototype.has(key)
            // 23.2.3.7 Set.prototype.has(value)
            has: function has(key) {
              return !!getEntry(this, key);
            }
          });
          if (DESCRIPTORS) dP(C.prototype, 'size', {
            get: function get() {
              return defined(this[SIZE]);
            }
          });
          return C;
        },
        def: function def(that, key, value) {
          var entry = getEntry(that, key),
              prev,
              index;
          // change existing entry
          if (entry) {
            entry.v = value;
            // create new entry
          } else {
            that._l = entry = {
              i: index = fastKey(key, true), // <- index
              k: key, // <- key
              v: value, // <- value
              p: prev = that._l, // <- previous entry
              n: undefined, // <- next entry
              r: false // <- removed
            };
            if (!that._f) that._f = entry;
            if (prev) prev.n = entry;
            that[SIZE]++;
            // add to index
            if (index !== 'F') that._i[index] = entry;
          }return that;
        },
        getEntry: getEntry,
        setStrong: function setStrong(C, NAME, IS_MAP) {
          // add .keys, .values, .entries, [@@iterator]
          // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
          $iterDefine(C, NAME, function (iterated, kind) {
            this._t = iterated; // target
            this._k = kind; // kind
            this._l = undefined; // previous
          }, function () {
            var that = this,
                kind = that._k,
                entry = that._l;
            // revert to the last existing entry
            while (entry && entry.r) {
              entry = entry.p;
            } // get next entry
            if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
              // or finish the iteration
              that._t = undefined;
              return step(1);
            }
            // return step by kind
            if (kind == 'keys') return step(0, entry.k);
            if (kind == 'values') return step(0, entry.v);
            return step(0, [entry.k, entry.v]);
          }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

          // add [@@species], 23.1.2.2, 23.2.2.2
          setSpecies(NAME);
        }
      };
    }, { "./_an-instance": 85, "./_ctx": 104, "./_defined": 106, "./_descriptors": 107, "./_for-of": 116, "./_iter-define": 132, "./_iter-step": 134, "./_meta": 141, "./_object-create": 145, "./_object-dp": 146, "./_redefine-all": 165, "./_set-species": 170 }], 99: [function (_dereq_, module, exports) {
      // https://github.com/DavidBruant/Map-Set.prototype.toJSON
      var classof = _dereq_('./_classof'),
          from = _dereq_('./_array-from-iterable');
      module.exports = function (NAME) {
        return function toJSON() {
          if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
          return from(this);
        };
      };
    }, { "./_array-from-iterable": 89, "./_classof": 96 }], 100: [function (_dereq_, module, exports) {
      'use strict';

      var redefineAll = _dereq_('./_redefine-all'),
          getWeak = _dereq_('./_meta').getWeak,
          anObject = _dereq_('./_an-object'),
          isObject = _dereq_('./_is-object'),
          anInstance = _dereq_('./_an-instance'),
          forOf = _dereq_('./_for-of'),
          createArrayMethod = _dereq_('./_array-methods'),
          $has = _dereq_('./_has'),
          arrayFind = createArrayMethod(5),
          arrayFindIndex = createArrayMethod(6),
          id = 0;

      // fallback for uncaught frozen keys
      var uncaughtFrozenStore = function uncaughtFrozenStore(that) {
        return that._l || (that._l = new UncaughtFrozenStore());
      };
      var UncaughtFrozenStore = function UncaughtFrozenStore() {
        this.a = [];
      };
      var findUncaughtFrozen = function findUncaughtFrozen(store, key) {
        return arrayFind(store.a, function (it) {
          return it[0] === key;
        });
      };
      UncaughtFrozenStore.prototype = {
        get: function get(key) {
          var entry = findUncaughtFrozen(this, key);
          if (entry) return entry[1];
        },
        has: function has(key) {
          return !!findUncaughtFrozen(this, key);
        },
        set: function set(key, value) {
          var entry = findUncaughtFrozen(this, key);
          if (entry) entry[1] = value;else this.a.push([key, value]);
        },
        'delete': function _delete(key) {
          var index = arrayFindIndex(this.a, function (it) {
            return it[0] === key;
          });
          if (~index) this.a.splice(index, 1);
          return !!~index;
        }
      };

      module.exports = {
        getConstructor: function getConstructor(wrapper, NAME, IS_MAP, ADDER) {
          var C = wrapper(function (that, iterable) {
            anInstance(that, C, NAME, '_i');
            that._i = id++; // collection id
            that._l = undefined; // leak store for uncaught frozen objects
            if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
          });
          redefineAll(C.prototype, {
            // 23.3.3.2 WeakMap.prototype.delete(key)
            // 23.4.3.3 WeakSet.prototype.delete(value)
            'delete': function _delete(key) {
              if (!isObject(key)) return false;
              var data = getWeak(key);
              if (data === true) return uncaughtFrozenStore(this)['delete'](key);
              return data && $has(data, this._i) && delete data[this._i];
            },
            // 23.3.3.4 WeakMap.prototype.has(key)
            // 23.4.3.4 WeakSet.prototype.has(value)
            has: function has(key) {
              if (!isObject(key)) return false;
              var data = getWeak(key);
              if (data === true) return uncaughtFrozenStore(this).has(key);
              return data && $has(data, this._i);
            }
          });
          return C;
        },
        def: function def(that, key, value) {
          var data = getWeak(anObject(key), true);
          if (data === true) uncaughtFrozenStore(that).set(key, value);else data[that._i] = value;
          return that;
        },
        ufstore: uncaughtFrozenStore
      };
    }, { "./_an-instance": 85, "./_an-object": 86, "./_array-methods": 91, "./_for-of": 116, "./_has": 118, "./_is-object": 128, "./_meta": 141, "./_redefine-all": 165 }], 101: [function (_dereq_, module, exports) {
      'use strict';

      var global = _dereq_('./_global'),
          $export = _dereq_('./_export'),
          redefine = _dereq_('./_redefine'),
          redefineAll = _dereq_('./_redefine-all'),
          meta = _dereq_('./_meta'),
          forOf = _dereq_('./_for-of'),
          anInstance = _dereq_('./_an-instance'),
          isObject = _dereq_('./_is-object'),
          fails = _dereq_('./_fails'),
          $iterDetect = _dereq_('./_iter-detect'),
          setToStringTag = _dereq_('./_set-to-string-tag'),
          inheritIfRequired = _dereq_('./_inherit-if-required');

      module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
        var Base = global[NAME],
            C = Base,
            ADDER = IS_MAP ? 'set' : 'add',
            proto = C && C.prototype,
            O = {};
        var fixMethod = function fixMethod(KEY) {
          var fn = proto[KEY];
          redefine(proto, KEY, KEY == 'delete' ? function (a) {
            return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
          } : KEY == 'has' ? function has(a) {
            return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
          } : KEY == 'get' ? function get(a) {
            return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
          } : KEY == 'add' ? function add(a) {
            fn.call(this, a === 0 ? 0 : a);return this;
          } : function set(a, b) {
            fn.call(this, a === 0 ? 0 : a, b);return this;
          });
        };
        if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
          new C().entries().next();
        }))) {
          // create collection constructor
          C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
          redefineAll(C.prototype, methods);
          meta.NEED = true;
        } else {
          var instance = new C()
          // early implementations not supports chaining
          ,
              HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance
          // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
          ,
              THROWS_ON_PRIMITIVES = fails(function () {
            instance.has(1);
          })
          // most early implementations doesn't supports iterables, most modern - not close it correctly
          ,
              ACCEPT_ITERABLES = $iterDetect(function (iter) {
            new C(iter);
          }) // eslint-disable-line no-new
          // for early implementations -0 and +0 not the same
          ,
              BUGGY_ZERO = !IS_WEAK && fails(function () {
            // V8 ~ Chromium 42- fails only with 5+ elements
            var $instance = new C(),
                index = 5;
            while (index--) {
              $instance[ADDER](index, index);
            }return !$instance.has(-0);
          });
          if (!ACCEPT_ITERABLES) {
            C = wrapper(function (target, iterable) {
              anInstance(target, C, NAME);
              var that = inheritIfRequired(new Base(), target, C);
              if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
              return that;
            });
            C.prototype = proto;
            proto.constructor = C;
          }
          if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
            fixMethod('delete');
            fixMethod('has');
            IS_MAP && fixMethod('get');
          }
          if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
          // weak collections should not contains .clear method
          if (IS_WEAK && proto.clear) delete proto.clear;
        }

        setToStringTag(C, NAME);

        O[NAME] = C;
        $export($export.G + $export.W + $export.F * (C != Base), O);

        if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

        return C;
      };
    }, { "./_an-instance": 85, "./_export": 111, "./_fails": 113, "./_for-of": 116, "./_global": 117, "./_inherit-if-required": 122, "./_is-object": 128, "./_iter-detect": 133, "./_meta": 141, "./_redefine": 166, "./_redefine-all": 165, "./_set-to-string-tag": 171 }], 102: [function (_dereq_, module, exports) {
      var core = module.exports = { version: '2.4.0' };
      if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
    }, {}], 103: [function (_dereq_, module, exports) {
      'use strict';

      var $defineProperty = _dereq_('./_object-dp'),
          createDesc = _dereq_('./_property-desc');

      module.exports = function (object, index, value) {
        if (index in object) $defineProperty.f(object, index, createDesc(0, value));else object[index] = value;
      };
    }, { "./_object-dp": 146, "./_property-desc": 164 }], 104: [function (_dereq_, module, exports) {
      // optional / simple context binding
      var aFunction = _dereq_('./_a-function');
      module.exports = function (fn, that, length) {
        aFunction(fn);
        if (that === undefined) return fn;
        switch (length) {
          case 1:
            return function (a) {
              return fn.call(that, a);
            };
          case 2:
            return function (a, b) {
              return fn.call(that, a, b);
            };
          case 3:
            return function (a, b, c) {
              return fn.call(that, a, b, c);
            };
        }
        return function () /* ...args */{
          return fn.apply(that, arguments);
        };
      };
    }, { "./_a-function": 82 }], 105: [function (_dereq_, module, exports) {
      'use strict';

      var anObject = _dereq_('./_an-object'),
          toPrimitive = _dereq_('./_to-primitive'),
          NUMBER = 'number';

      module.exports = function (hint) {
        if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');
        return toPrimitive(anObject(this), hint != NUMBER);
      };
    }, { "./_an-object": 86, "./_to-primitive": 189 }], 106: [function (_dereq_, module, exports) {
      // 7.2.1 RequireObjectCoercible(argument)
      module.exports = function (it) {
        if (it == undefined) throw TypeError("Can't call method on  " + it);
        return it;
      };
    }, {}], 107: [function (_dereq_, module, exports) {
      // Thank's IE8 for his funny defineProperty
      module.exports = !_dereq_('./_fails')(function () {
        return Object.defineProperty({}, 'a', { get: function get() {
            return 7;
          } }).a != 7;
      });
    }, { "./_fails": 113 }], 108: [function (_dereq_, module, exports) {
      var isObject = _dereq_('./_is-object'),
          document = _dereq_('./_global').document
      // in old IE typeof document.createElement is 'object'
      ,
          is = isObject(document) && isObject(document.createElement);
      module.exports = function (it) {
        return is ? document.createElement(it) : {};
      };
    }, { "./_global": 117, "./_is-object": 128 }], 109: [function (_dereq_, module, exports) {
      // IE 8- don't enum bug keys
      module.exports = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');
    }, {}], 110: [function (_dereq_, module, exports) {
      // all enumerable object keys, includes symbols
      var getKeys = _dereq_('./_object-keys'),
          gOPS = _dereq_('./_object-gops'),
          pIE = _dereq_('./_object-pie');
      module.exports = function (it) {
        var result = getKeys(it),
            getSymbols = gOPS.f;
        if (getSymbols) {
          var symbols = getSymbols(it),
              isEnum = pIE.f,
              i = 0,
              key;
          while (symbols.length > i) {
            if (isEnum.call(it, key = symbols[i++])) result.push(key);
          }
        }return result;
      };
    }, { "./_object-gops": 152, "./_object-keys": 155, "./_object-pie": 156 }], 111: [function (_dereq_, module, exports) {
      var global = _dereq_('./_global'),
          core = _dereq_('./_core'),
          hide = _dereq_('./_hide'),
          redefine = _dereq_('./_redefine'),
          ctx = _dereq_('./_ctx'),
          PROTOTYPE = 'prototype';

      var $export = function $export(type, name, source) {
        var IS_FORCED = type & $export.F,
            IS_GLOBAL = type & $export.G,
            IS_STATIC = type & $export.S,
            IS_PROTO = type & $export.P,
            IS_BIND = type & $export.B,
            target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE],
            exports = IS_GLOBAL ? core : core[name] || (core[name] = {}),
            expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {}),
            key,
            own,
            out,
            exp;
        if (IS_GLOBAL) source = name;
        for (key in source) {
          // contains in native
          own = !IS_FORCED && target && target[key] !== undefined;
          // export native or passed
          out = (own ? target : source)[key];
          // bind timers to global for call from export context
          exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
          // extend global
          if (target) redefine(target, key, out, type & $export.U);
          // export
          if (exports[key] != out) hide(exports, key, exp);
          if (IS_PROTO && expProto[key] != out) expProto[key] = out;
        }
      };
      global.core = core;
      // type bitmap
      $export.F = 1; // forced
      $export.G = 2; // global
      $export.S = 4; // static
      $export.P = 8; // proto
      $export.B = 16; // bind
      $export.W = 32; // wrap
      $export.U = 64; // safe
      $export.R = 128; // real proto method for `library` 
      module.exports = $export;
    }, { "./_core": 102, "./_ctx": 104, "./_global": 117, "./_hide": 119, "./_redefine": 166 }], 112: [function (_dereq_, module, exports) {
      var MATCH = _dereq_('./_wks')('match');
      module.exports = function (KEY) {
        var re = /./;
        try {
          '/./'[KEY](re);
        } catch (e) {
          try {
            re[MATCH] = false;
            return !'/./'[KEY](re);
          } catch (f) {/* empty */}
        }return true;
      };
    }, { "./_wks": 196 }], 113: [function (_dereq_, module, exports) {
      module.exports = function (exec) {
        try {
          return !!exec();
        } catch (e) {
          return true;
        }
      };
    }, {}], 114: [function (_dereq_, module, exports) {
      'use strict';

      var hide = _dereq_('./_hide'),
          redefine = _dereq_('./_redefine'),
          fails = _dereq_('./_fails'),
          defined = _dereq_('./_defined'),
          wks = _dereq_('./_wks');

      module.exports = function (KEY, length, exec) {
        var SYMBOL = wks(KEY),
            fns = exec(defined, SYMBOL, ''[KEY]),
            strfn = fns[0],
            rxfn = fns[1];
        if (fails(function () {
          var O = {};
          O[SYMBOL] = function () {
            return 7;
          };
          return ''[KEY](O) != 7;
        })) {
          redefine(String.prototype, KEY, strfn);
          hide(RegExp.prototype, SYMBOL, length == 2
          // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
          // 21.2.5.11 RegExp.prototype[@@split](string, limit)
          ? function (string, arg) {
            return rxfn.call(string, this, arg);
          }
          // 21.2.5.6 RegExp.prototype[@@match](string)
          // 21.2.5.9 RegExp.prototype[@@search](string)
          : function (string) {
            return rxfn.call(string, this);
          });
        }
      };
    }, { "./_defined": 106, "./_fails": 113, "./_hide": 119, "./_redefine": 166, "./_wks": 196 }], 115: [function (_dereq_, module, exports) {
      'use strict';
      // 21.2.5.3 get RegExp.prototype.flags

      var anObject = _dereq_('./_an-object');
      module.exports = function () {
        var that = anObject(this),
            result = '';
        if (that.global) result += 'g';
        if (that.ignoreCase) result += 'i';
        if (that.multiline) result += 'm';
        if (that.unicode) result += 'u';
        if (that.sticky) result += 'y';
        return result;
      };
    }, { "./_an-object": 86 }], 116: [function (_dereq_, module, exports) {
      var ctx = _dereq_('./_ctx'),
          call = _dereq_('./_iter-call'),
          isArrayIter = _dereq_('./_is-array-iter'),
          anObject = _dereq_('./_an-object'),
          toLength = _dereq_('./_to-length'),
          getIterFn = _dereq_('./core.get-iterator-method'),
          BREAK = {},
          RETURN = {};
      var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
        var iterFn = ITERATOR ? function () {
          return iterable;
        } : getIterFn(iterable),
            f = ctx(fn, that, entries ? 2 : 1),
            index = 0,
            length,
            step,
            iterator,
            result;
        if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
        // fast case for arrays with default iterator
        if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
          result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
          if (result === BREAK || result === RETURN) return result;
        } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
          result = call(iterator, f, step.value, entries);
          if (result === BREAK || result === RETURN) return result;
        }
      };
      exports.BREAK = BREAK;
      exports.RETURN = RETURN;
    }, { "./_an-object": 86, "./_ctx": 104, "./_is-array-iter": 125, "./_iter-call": 130, "./_to-length": 187, "./core.get-iterator-method": 197 }], 117: [function (_dereq_, module, exports) {
      // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
      var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
      if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
    }, {}], 118: [function (_dereq_, module, exports) {
      var hasOwnProperty = {}.hasOwnProperty;
      module.exports = function (it, key) {
        return hasOwnProperty.call(it, key);
      };
    }, {}], 119: [function (_dereq_, module, exports) {
      var dP = _dereq_('./_object-dp'),
          createDesc = _dereq_('./_property-desc');
      module.exports = _dereq_('./_descriptors') ? function (object, key, value) {
        return dP.f(object, key, createDesc(1, value));
      } : function (object, key, value) {
        object[key] = value;
        return object;
      };
    }, { "./_descriptors": 107, "./_object-dp": 146, "./_property-desc": 164 }], 120: [function (_dereq_, module, exports) {
      module.exports = _dereq_('./_global').document && document.documentElement;
    }, { "./_global": 117 }], 121: [function (_dereq_, module, exports) {
      module.exports = !_dereq_('./_descriptors') && !_dereq_('./_fails')(function () {
        return Object.defineProperty(_dereq_('./_dom-create')('div'), 'a', { get: function get() {
            return 7;
          } }).a != 7;
      });
    }, { "./_descriptors": 107, "./_dom-create": 108, "./_fails": 113 }], 122: [function (_dereq_, module, exports) {
      var isObject = _dereq_('./_is-object'),
          setPrototypeOf = _dereq_('./_set-proto').set;
      module.exports = function (that, target, C) {
        var P,
            S = target.constructor;
        if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
          setPrototypeOf(that, P);
        }return that;
      };
    }, { "./_is-object": 128, "./_set-proto": 169 }], 123: [function (_dereq_, module, exports) {
      // fast apply, http://jsperf.lnkit.com/fast-apply/5
      module.exports = function (fn, args, that) {
        var un = that === undefined;
        switch (args.length) {
          case 0:
            return un ? fn() : fn.call(that);
          case 1:
            return un ? fn(args[0]) : fn.call(that, args[0]);
          case 2:
            return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
          case 3:
            return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
          case 4:
            return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
        }return fn.apply(that, args);
      };
    }, {}], 124: [function (_dereq_, module, exports) {
      // fallback for non-array-like ES3 and non-enumerable old V8 strings
      var cof = _dereq_('./_cof');
      module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
        return cof(it) == 'String' ? it.split('') : Object(it);
      };
    }, { "./_cof": 97 }], 125: [function (_dereq_, module, exports) {
      // check on default Array iterator
      var Iterators = _dereq_('./_iterators'),
          ITERATOR = _dereq_('./_wks')('iterator'),
          ArrayProto = Array.prototype;

      module.exports = function (it) {
        return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
      };
    }, { "./_iterators": 135, "./_wks": 196 }], 126: [function (_dereq_, module, exports) {
      // 7.2.2 IsArray(argument)
      var cof = _dereq_('./_cof');
      module.exports = Array.isArray || function isArray(arg) {
        return cof(arg) == 'Array';
      };
    }, { "./_cof": 97 }], 127: [function (_dereq_, module, exports) {
      // 20.1.2.3 Number.isInteger(number)
      var isObject = _dereq_('./_is-object'),
          floor = Math.floor;
      module.exports = function isInteger(it) {
        return !isObject(it) && isFinite(it) && floor(it) === it;
      };
    }, { "./_is-object": 128 }], 128: [function (_dereq_, module, exports) {
      module.exports = function (it) {
        return (typeof it === "undefined" ? "undefined" : _typeof2(it)) === 'object' ? it !== null : typeof it === 'function';
      };
    }, {}], 129: [function (_dereq_, module, exports) {
      // 7.2.8 IsRegExp(argument)
      var isObject = _dereq_('./_is-object'),
          cof = _dereq_('./_cof'),
          MATCH = _dereq_('./_wks')('match');
      module.exports = function (it) {
        var isRegExp;
        return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
      };
    }, { "./_cof": 97, "./_is-object": 128, "./_wks": 196 }], 130: [function (_dereq_, module, exports) {
      // call something on iterator step with safe closing on error
      var anObject = _dereq_('./_an-object');
      module.exports = function (iterator, fn, value, entries) {
        try {
          return entries ? fn(anObject(value)[0], value[1]) : fn(value);
          // 7.4.6 IteratorClose(iterator, completion)
        } catch (e) {
          var ret = iterator['return'];
          if (ret !== undefined) anObject(ret.call(iterator));
          throw e;
        }
      };
    }, { "./_an-object": 86 }], 131: [function (_dereq_, module, exports) {
      'use strict';

      var create = _dereq_('./_object-create'),
          descriptor = _dereq_('./_property-desc'),
          setToStringTag = _dereq_('./_set-to-string-tag'),
          IteratorPrototype = {};

      // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
      _dereq_('./_hide')(IteratorPrototype, _dereq_('./_wks')('iterator'), function () {
        return this;
      });

      module.exports = function (Constructor, NAME, next) {
        Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
        setToStringTag(Constructor, NAME + ' Iterator');
      };
    }, { "./_hide": 119, "./_object-create": 145, "./_property-desc": 164, "./_set-to-string-tag": 171, "./_wks": 196 }], 132: [function (_dereq_, module, exports) {
      'use strict';

      var LIBRARY = _dereq_('./_library'),
          $export = _dereq_('./_export'),
          redefine = _dereq_('./_redefine'),
          hide = _dereq_('./_hide'),
          has = _dereq_('./_has'),
          Iterators = _dereq_('./_iterators'),
          $iterCreate = _dereq_('./_iter-create'),
          setToStringTag = _dereq_('./_set-to-string-tag'),
          getPrototypeOf = _dereq_('./_object-gpo'),
          ITERATOR = _dereq_('./_wks')('iterator'),
          BUGGY = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
      ,
          FF_ITERATOR = '@@iterator',
          KEYS = 'keys',
          VALUES = 'values';

      var returnThis = function returnThis() {
        return this;
      };

      module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
        $iterCreate(Constructor, NAME, next);
        var getMethod = function getMethod(kind) {
          if (!BUGGY && kind in proto) return proto[kind];
          switch (kind) {
            case KEYS:
              return function keys() {
                return new Constructor(this, kind);
              };
            case VALUES:
              return function values() {
                return new Constructor(this, kind);
              };
          }return function entries() {
            return new Constructor(this, kind);
          };
        };
        var TAG = NAME + ' Iterator',
            DEF_VALUES = DEFAULT == VALUES,
            VALUES_BUG = false,
            proto = Base.prototype,
            $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT],
            $default = $native || getMethod(DEFAULT),
            $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined,
            $anyNative = NAME == 'Array' ? proto.entries || $native : $native,
            methods,
            key,
            IteratorPrototype;
        // Fix native
        if ($anyNative) {
          IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
          if (IteratorPrototype !== Object.prototype) {
            // Set @@toStringTag to native iterators
            setToStringTag(IteratorPrototype, TAG, true);
            // fix for some old engines
            if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);
          }
        }
        // fix Array#{values, @@iterator}.name in V8 / FF
        if (DEF_VALUES && $native && $native.name !== VALUES) {
          VALUES_BUG = true;
          $default = function values() {
            return $native.call(this);
          };
        }
        // Define iterator
        if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
          hide(proto, ITERATOR, $default);
        }
        // Plug for library
        Iterators[NAME] = $default;
        Iterators[TAG] = returnThis;
        if (DEFAULT) {
          methods = {
            values: DEF_VALUES ? $default : getMethod(VALUES),
            keys: IS_SET ? $default : getMethod(KEYS),
            entries: $entries
          };
          if (FORCED) for (key in methods) {
            if (!(key in proto)) redefine(proto, key, methods[key]);
          } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
        }
        return methods;
      };
    }, { "./_export": 111, "./_has": 118, "./_hide": 119, "./_iter-create": 131, "./_iterators": 135, "./_library": 137, "./_object-gpo": 153, "./_redefine": 166, "./_set-to-string-tag": 171, "./_wks": 196 }], 133: [function (_dereq_, module, exports) {
      var ITERATOR = _dereq_('./_wks')('iterator'),
          SAFE_CLOSING = false;

      try {
        var riter = [7][ITERATOR]();
        riter['return'] = function () {
          SAFE_CLOSING = true;
        };
        Array.from(riter, function () {
          throw 2;
        });
      } catch (e) {/* empty */}

      module.exports = function (exec, skipClosing) {
        if (!skipClosing && !SAFE_CLOSING) return false;
        var safe = false;
        try {
          var arr = [7],
              iter = arr[ITERATOR]();
          iter.next = function () {
            return { done: safe = true };
          };
          arr[ITERATOR] = function () {
            return iter;
          };
          exec(arr);
        } catch (e) {/* empty */}
        return safe;
      };
    }, { "./_wks": 196 }], 134: [function (_dereq_, module, exports) {
      module.exports = function (done, value) {
        return { value: value, done: !!done };
      };
    }, {}], 135: [function (_dereq_, module, exports) {
      module.exports = {};
    }, {}], 136: [function (_dereq_, module, exports) {
      var getKeys = _dereq_('./_object-keys'),
          toIObject = _dereq_('./_to-iobject');
      module.exports = function (object, el) {
        var O = toIObject(object),
            keys = getKeys(O),
            length = keys.length,
            index = 0,
            key;
        while (length > index) {
          if (O[key = keys[index++]] === el) return key;
        }
      };
    }, { "./_object-keys": 155, "./_to-iobject": 186 }], 137: [function (_dereq_, module, exports) {
      module.exports = false;
    }, {}], 138: [function (_dereq_, module, exports) {
      // 20.2.2.14 Math.expm1(x)
      var $expm1 = Math.expm1;
      module.exports = !$expm1
      // Old FF bug
      || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
      // Tor Browser bug
      || $expm1(-2e-17) != -2e-17 ? function expm1(x) {
        return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
      } : $expm1;
    }, {}], 139: [function (_dereq_, module, exports) {
      // 20.2.2.20 Math.log1p(x)
      module.exports = Math.log1p || function log1p(x) {
        return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
      };
    }, {}], 140: [function (_dereq_, module, exports) {
      // 20.2.2.28 Math.sign(x)
      module.exports = Math.sign || function sign(x) {
        return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
      };
    }, {}], 141: [function (_dereq_, module, exports) {
      var META = _dereq_('./_uid')('meta'),
          isObject = _dereq_('./_is-object'),
          has = _dereq_('./_has'),
          setDesc = _dereq_('./_object-dp').f,
          id = 0;
      var isExtensible = Object.isExtensible || function () {
        return true;
      };
      var FREEZE = !_dereq_('./_fails')(function () {
        return isExtensible(Object.preventExtensions({}));
      });
      var setMeta = function setMeta(it) {
        setDesc(it, META, { value: {
            i: 'O' + ++id, // object ID
            w: {} // weak collections IDs
          } });
      };
      var fastKey = function fastKey(it, create) {
        // return primitive with prefix
        if (!isObject(it)) return (typeof it === "undefined" ? "undefined" : _typeof2(it)) == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
        if (!has(it, META)) {
          // can't set metadata to uncaught frozen object
          if (!isExtensible(it)) return 'F';
          // not necessary to add metadata
          if (!create) return 'E';
          // add missing metadata
          setMeta(it);
          // return object ID
        }return it[META].i;
      };
      var getWeak = function getWeak(it, create) {
        if (!has(it, META)) {
          // can't set metadata to uncaught frozen object
          if (!isExtensible(it)) return true;
          // not necessary to add metadata
          if (!create) return false;
          // add missing metadata
          setMeta(it);
          // return hash weak collections IDs
        }return it[META].w;
      };
      // add metadata on freeze-family methods calling
      var onFreeze = function onFreeze(it) {
        if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
        return it;
      };
      var meta = module.exports = {
        KEY: META,
        NEED: false,
        fastKey: fastKey,
        getWeak: getWeak,
        onFreeze: onFreeze
      };
    }, { "./_fails": 113, "./_has": 118, "./_is-object": 128, "./_object-dp": 146, "./_uid": 193 }], 142: [function (_dereq_, module, exports) {
      var Map = _dereq_('./es6.map'),
          $export = _dereq_('./_export'),
          shared = _dereq_('./_shared')('metadata'),
          store = shared.store || (shared.store = new (_dereq_('./es6.weak-map'))());

      var getOrCreateMetadataMap = function getOrCreateMetadataMap(target, targetKey, create) {
        var targetMetadata = store.get(target);
        if (!targetMetadata) {
          if (!create) return undefined;
          store.set(target, targetMetadata = new Map());
        }
        var keyMetadata = targetMetadata.get(targetKey);
        if (!keyMetadata) {
          if (!create) return undefined;
          targetMetadata.set(targetKey, keyMetadata = new Map());
        }return keyMetadata;
      };
      var ordinaryHasOwnMetadata = function ordinaryHasOwnMetadata(MetadataKey, O, P) {
        var metadataMap = getOrCreateMetadataMap(O, P, false);
        return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
      };
      var ordinaryGetOwnMetadata = function ordinaryGetOwnMetadata(MetadataKey, O, P) {
        var metadataMap = getOrCreateMetadataMap(O, P, false);
        return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
      };
      var ordinaryDefineOwnMetadata = function ordinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
        getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
      };
      var ordinaryOwnMetadataKeys = function ordinaryOwnMetadataKeys(target, targetKey) {
        var metadataMap = getOrCreateMetadataMap(target, targetKey, false),
            keys = [];
        if (metadataMap) metadataMap.forEach(function (_, key) {
          keys.push(key);
        });
        return keys;
      };
      var toMetaKey = function toMetaKey(it) {
        return it === undefined || (typeof it === "undefined" ? "undefined" : _typeof2(it)) == 'symbol' ? it : String(it);
      };
      var exp = function exp(O) {
        $export($export.S, 'Reflect', O);
      };

      module.exports = {
        store: store,
        map: getOrCreateMetadataMap,
        has: ordinaryHasOwnMetadata,
        get: ordinaryGetOwnMetadata,
        set: ordinaryDefineOwnMetadata,
        keys: ordinaryOwnMetadataKeys,
        key: toMetaKey,
        exp: exp
      };
    }, { "./_export": 111, "./_shared": 173, "./es6.map": 228, "./es6.weak-map": 334 }], 143: [function (_dereq_, module, exports) {
      var global = _dereq_('./_global'),
          macrotask = _dereq_('./_task').set,
          Observer = global.MutationObserver || global.WebKitMutationObserver,
          process = global.process,
          Promise = global.Promise,
          isNode = _dereq_('./_cof')(process) == 'process';

      module.exports = function () {
        var head, last, notify;

        var flush = function flush() {
          var parent, fn;
          if (isNode && (parent = process.domain)) parent.exit();
          while (head) {
            fn = head.fn;
            head = head.next;
            try {
              fn();
            } catch (e) {
              if (head) notify();else last = undefined;
              throw e;
            }
          }last = undefined;
          if (parent) parent.enter();
        };

        // Node.js
        if (isNode) {
          notify = function notify() {
            process.nextTick(flush);
          };
          // browsers with MutationObserver
        } else if (Observer) {
          var toggle = true,
              node = document.createTextNode('');
          new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
          notify = function notify() {
            node.data = toggle = !toggle;
          };
          // environments with maybe non-completely correct, but existent Promise
        } else if (Promise && Promise.resolve) {
          var promise = Promise.resolve();
          notify = function notify() {
            promise.then(flush);
          };
          // for other environments - macrotask based on:
          // - setImmediate
          // - MessageChannel
          // - window.postMessag
          // - onreadystatechange
          // - setTimeout
        } else {
          notify = function notify() {
            // strange IE + webpack dev server bug - use .call(global)
            macrotask.call(global, flush);
          };
        }

        return function (fn) {
          var task = { fn: fn, next: undefined };
          if (last) last.next = task;
          if (!head) {
            head = task;
            notify();
          }last = task;
        };
      };
    }, { "./_cof": 97, "./_global": 117, "./_task": 183 }], 144: [function (_dereq_, module, exports) {
      'use strict';
      // 19.1.2.1 Object.assign(target, source, ...)

      var getKeys = _dereq_('./_object-keys'),
          gOPS = _dereq_('./_object-gops'),
          pIE = _dereq_('./_object-pie'),
          toObject = _dereq_('./_to-object'),
          IObject = _dereq_('./_iobject'),
          $assign = Object.assign;

      // should work with symbols and should have deterministic property order (V8 bug)
      module.exports = !$assign || _dereq_('./_fails')(function () {
        var A = {},
            B = {},
            S = Symbol(),
            K = 'abcdefghijklmnopqrst';
        A[S] = 7;
        K.split('').forEach(function (k) {
          B[k] = k;
        });
        return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
      }) ? function assign(target, source) {
        // eslint-disable-line no-unused-vars
        var T = toObject(target),
            aLen = arguments.length,
            index = 1,
            getSymbols = gOPS.f,
            isEnum = pIE.f;
        while (aLen > index) {
          var S = IObject(arguments[index++]),
              keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S),
              length = keys.length,
              j = 0,
              key;
          while (length > j) {
            if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
          }
        }return T;
      } : $assign;
    }, { "./_fails": 113, "./_iobject": 124, "./_object-gops": 152, "./_object-keys": 155, "./_object-pie": 156, "./_to-object": 188 }], 145: [function (_dereq_, module, exports) {
      // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
      var anObject = _dereq_('./_an-object'),
          dPs = _dereq_('./_object-dps'),
          enumBugKeys = _dereq_('./_enum-bug-keys'),
          IE_PROTO = _dereq_('./_shared-key')('IE_PROTO'),
          Empty = function Empty() {/* empty */},
          PROTOTYPE = 'prototype';

      // Create object with fake `null` prototype: use iframe Object with cleared prototype
      var _createDict2 = function createDict() {
        // Thrash, waste and sodomy: IE GC bug
        var iframe = _dereq_('./_dom-create')('iframe'),
            i = enumBugKeys.length,
            lt = '<',
            gt = '>',
            iframeDocument;
        iframe.style.display = 'none';
        _dereq_('./_html').appendChild(iframe);
        iframe.src = 'javascript:'; // eslint-disable-line no-script-url
        // createDict = iframe.contentWindow.Object;
        // html.removeChild(iframe);
        iframeDocument = iframe.contentWindow.document;
        iframeDocument.open();
        iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
        iframeDocument.close();
        _createDict2 = iframeDocument.F;
        while (i--) {
          delete _createDict2[PROTOTYPE][enumBugKeys[i]];
        }return _createDict2();
      };

      module.exports = Object.create || function create(O, Properties) {
        var result;
        if (O !== null) {
          Empty[PROTOTYPE] = anObject(O);
          result = new Empty();
          Empty[PROTOTYPE] = null;
          // add "__proto__" for Object.getPrototypeOf polyfill
          result[IE_PROTO] = O;
        } else result = _createDict2();
        return Properties === undefined ? result : dPs(result, Properties);
      };
    }, { "./_an-object": 86, "./_dom-create": 108, "./_enum-bug-keys": 109, "./_html": 120, "./_object-dps": 147, "./_shared-key": 172 }], 146: [function (_dereq_, module, exports) {
      var anObject = _dereq_('./_an-object'),
          IE8_DOM_DEFINE = _dereq_('./_ie8-dom-define'),
          toPrimitive = _dereq_('./_to-primitive'),
          dP = Object.defineProperty;

      exports.f = _dereq_('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
        anObject(O);
        P = toPrimitive(P, true);
        anObject(Attributes);
        if (IE8_DOM_DEFINE) try {
          return dP(O, P, Attributes);
        } catch (e) {/* empty */}
        if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
        if ('value' in Attributes) O[P] = Attributes.value;
        return O;
      };
    }, { "./_an-object": 86, "./_descriptors": 107, "./_ie8-dom-define": 121, "./_to-primitive": 189 }], 147: [function (_dereq_, module, exports) {
      var dP = _dereq_('./_object-dp'),
          anObject = _dereq_('./_an-object'),
          getKeys = _dereq_('./_object-keys');

      module.exports = _dereq_('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {
        anObject(O);
        var keys = getKeys(Properties),
            length = keys.length,
            i = 0,
            P;
        while (length > i) {
          dP.f(O, P = keys[i++], Properties[P]);
        }return O;
      };
    }, { "./_an-object": 86, "./_descriptors": 107, "./_object-dp": 146, "./_object-keys": 155 }], 148: [function (_dereq_, module, exports) {
      // Forced replacement prototype accessors methods
      module.exports = _dereq_('./_library') || !_dereq_('./_fails')(function () {
        var K = Math.random();
        // In FF throws only define methods
        __defineSetter__.call(null, K, function () {/* empty */});
        delete _dereq_('./_global')[K];
      });
    }, { "./_fails": 113, "./_global": 117, "./_library": 137 }], 149: [function (_dereq_, module, exports) {
      var pIE = _dereq_('./_object-pie'),
          createDesc = _dereq_('./_property-desc'),
          toIObject = _dereq_('./_to-iobject'),
          toPrimitive = _dereq_('./_to-primitive'),
          has = _dereq_('./_has'),
          IE8_DOM_DEFINE = _dereq_('./_ie8-dom-define'),
          gOPD = Object.getOwnPropertyDescriptor;

      exports.f = _dereq_('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P) {
        O = toIObject(O);
        P = toPrimitive(P, true);
        if (IE8_DOM_DEFINE) try {
          return gOPD(O, P);
        } catch (e) {/* empty */}
        if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
      };
    }, { "./_descriptors": 107, "./_has": 118, "./_ie8-dom-define": 121, "./_object-pie": 156, "./_property-desc": 164, "./_to-iobject": 186, "./_to-primitive": 189 }], 150: [function (_dereq_, module, exports) {
      // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
      var toIObject = _dereq_('./_to-iobject'),
          gOPN = _dereq_('./_object-gopn').f,
          toString = {}.toString;

      var windowNames = (typeof window === "undefined" ? "undefined" : _typeof2(window)) == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];

      var getWindowNames = function getWindowNames(it) {
        try {
          return gOPN(it);
        } catch (e) {
          return windowNames.slice();
        }
      };

      module.exports.f = function getOwnPropertyNames(it) {
        return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
      };
    }, { "./_object-gopn": 151, "./_to-iobject": 186 }], 151: [function (_dereq_, module, exports) {
      // 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
      var $keys = _dereq_('./_object-keys-internal'),
          hiddenKeys = _dereq_('./_enum-bug-keys').concat('length', 'prototype');

      exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
        return $keys(O, hiddenKeys);
      };
    }, { "./_enum-bug-keys": 109, "./_object-keys-internal": 154 }], 152: [function (_dereq_, module, exports) {
      exports.f = Object.getOwnPropertySymbols;
    }, {}], 153: [function (_dereq_, module, exports) {
      // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
      var has = _dereq_('./_has'),
          toObject = _dereq_('./_to-object'),
          IE_PROTO = _dereq_('./_shared-key')('IE_PROTO'),
          ObjectProto = Object.prototype;

      module.exports = Object.getPrototypeOf || function (O) {
        O = toObject(O);
        if (has(O, IE_PROTO)) return O[IE_PROTO];
        if (typeof O.constructor == 'function' && O instanceof O.constructor) {
          return O.constructor.prototype;
        }return O instanceof Object ? ObjectProto : null;
      };
    }, { "./_has": 118, "./_shared-key": 172, "./_to-object": 188 }], 154: [function (_dereq_, module, exports) {
      var has = _dereq_('./_has'),
          toIObject = _dereq_('./_to-iobject'),
          arrayIndexOf = _dereq_('./_array-includes')(false),
          IE_PROTO = _dereq_('./_shared-key')('IE_PROTO');

      module.exports = function (object, names) {
        var O = toIObject(object),
            i = 0,
            result = [],
            key;
        for (key in O) {
          if (key != IE_PROTO) has(O, key) && result.push(key);
        } // Don't enum bug & hidden keys
        while (names.length > i) {
          if (has(O, key = names[i++])) {
            ~arrayIndexOf(result, key) || result.push(key);
          }
        }return result;
      };
    }, { "./_array-includes": 90, "./_has": 118, "./_shared-key": 172, "./_to-iobject": 186 }], 155: [function (_dereq_, module, exports) {
      // 19.1.2.14 / 15.2.3.14 Object.keys(O)
      var $keys = _dereq_('./_object-keys-internal'),
          enumBugKeys = _dereq_('./_enum-bug-keys');

      module.exports = Object.keys || function keys(O) {
        return $keys(O, enumBugKeys);
      };
    }, { "./_enum-bug-keys": 109, "./_object-keys-internal": 154 }], 156: [function (_dereq_, module, exports) {
      exports.f = {}.propertyIsEnumerable;
    }, {}], 157: [function (_dereq_, module, exports) {
      // most Object methods by ES6 should accept primitives
      var $export = _dereq_('./_export'),
          core = _dereq_('./_core'),
          fails = _dereq_('./_fails');
      module.exports = function (KEY, exec) {
        var fn = (core.Object || {})[KEY] || Object[KEY],
            exp = {};
        exp[KEY] = exec(fn);
        $export($export.S + $export.F * fails(function () {
          fn(1);
        }), 'Object', exp);
      };
    }, { "./_core": 102, "./_export": 111, "./_fails": 113 }], 158: [function (_dereq_, module, exports) {
      var getKeys = _dereq_('./_object-keys'),
          toIObject = _dereq_('./_to-iobject'),
          isEnum = _dereq_('./_object-pie').f;
      module.exports = function (isEntries) {
        return function (it) {
          var O = toIObject(it),
              keys = getKeys(O),
              length = keys.length,
              i = 0,
              result = [],
              key;
          while (length > i) {
            if (isEnum.call(O, key = keys[i++])) {
              result.push(isEntries ? [key, O[key]] : O[key]);
            }
          }return result;
        };
      };
    }, { "./_object-keys": 155, "./_object-pie": 156, "./_to-iobject": 186 }], 159: [function (_dereq_, module, exports) {
      // all object keys, includes non-enumerable and symbols
      var gOPN = _dereq_('./_object-gopn'),
          gOPS = _dereq_('./_object-gops'),
          anObject = _dereq_('./_an-object'),
          Reflect = _dereq_('./_global').Reflect;
      module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
        var keys = gOPN.f(anObject(it)),
            getSymbols = gOPS.f;
        return getSymbols ? keys.concat(getSymbols(it)) : keys;
      };
    }, { "./_an-object": 86, "./_global": 117, "./_object-gopn": 151, "./_object-gops": 152 }], 160: [function (_dereq_, module, exports) {
      var $parseFloat = _dereq_('./_global').parseFloat,
          $trim = _dereq_('./_string-trim').trim;

      module.exports = 1 / $parseFloat(_dereq_('./_string-ws') + '-0') !== -Infinity ? function parseFloat(str) {
        var string = $trim(String(str), 3),
            result = $parseFloat(string);
        return result === 0 && string.charAt(0) == '-' ? -0 : result;
      } : $parseFloat;
    }, { "./_global": 117, "./_string-trim": 181, "./_string-ws": 182 }], 161: [function (_dereq_, module, exports) {
      var $parseInt = _dereq_('./_global').parseInt,
          $trim = _dereq_('./_string-trim').trim,
          ws = _dereq_('./_string-ws'),
          hex = /^[\-+]?0[xX]/;

      module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
        var string = $trim(String(str), 3);
        return $parseInt(string, radix >>> 0 || (hex.test(string) ? 16 : 10));
      } : $parseInt;
    }, { "./_global": 117, "./_string-trim": 181, "./_string-ws": 182 }], 162: [function (_dereq_, module, exports) {
      'use strict';

      var path = _dereq_('./_path'),
          invoke = _dereq_('./_invoke'),
          aFunction = _dereq_('./_a-function');
      module.exports = function () /* ...pargs */{
        var fn = aFunction(this),
            length = arguments.length,
            pargs = Array(length),
            i = 0,
            _ = path._,
            holder = false;
        while (length > i) {
          if ((pargs[i] = arguments[i++]) === _) holder = true;
        }return function () /* ...args */{
          var that = this,
              aLen = arguments.length,
              j = 0,
              k = 0,
              args;
          if (!holder && !aLen) return invoke(fn, pargs, that);
          args = pargs.slice();
          if (holder) for (; length > j; j++) {
            if (args[j] === _) args[j] = arguments[k++];
          }while (aLen > k) {
            args.push(arguments[k++]);
          }return invoke(fn, args, that);
        };
      };
    }, { "./_a-function": 82, "./_invoke": 123, "./_path": 163 }], 163: [function (_dereq_, module, exports) {
      module.exports = _dereq_('./_global');
    }, { "./_global": 117 }], 164: [function (_dereq_, module, exports) {
      module.exports = function (bitmap, value) {
        return {
          enumerable: !(bitmap & 1),
          configurable: !(bitmap & 2),
          writable: !(bitmap & 4),
          value: value
        };
      };
    }, {}], 165: [function (_dereq_, module, exports) {
      var redefine = _dereq_('./_redefine');
      module.exports = function (target, src, safe) {
        for (var key in src) {
          redefine(target, key, src[key], safe);
        }return target;
      };
    }, { "./_redefine": 166 }], 166: [function (_dereq_, module, exports) {
      var global = _dereq_('./_global'),
          hide = _dereq_('./_hide'),
          has = _dereq_('./_has'),
          SRC = _dereq_('./_uid')('src'),
          TO_STRING = 'toString',
          $toString = Function[TO_STRING],
          TPL = ('' + $toString).split(TO_STRING);

      _dereq_('./_core').inspectSource = function (it) {
        return $toString.call(it);
      };

      (module.exports = function (O, key, val, safe) {
        var isFunction = typeof val == 'function';
        if (isFunction) has(val, 'name') || hide(val, 'name', key);
        if (O[key] === val) return;
        if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
        if (O === global) {
          O[key] = val;
        } else {
          if (!safe) {
            delete O[key];
            hide(O, key, val);
          } else {
            if (O[key]) O[key] = val;else hide(O, key, val);
          }
        }
        // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
      })(Function.prototype, TO_STRING, function toString() {
        return typeof this == 'function' && this[SRC] || $toString.call(this);
      });
    }, { "./_core": 102, "./_global": 117, "./_has": 118, "./_hide": 119, "./_uid": 193 }], 167: [function (_dereq_, module, exports) {
      module.exports = function (regExp, replace) {
        var replacer = replace === Object(replace) ? function (part) {
          return replace[part];
        } : replace;
        return function (it) {
          return String(it).replace(regExp, replacer);
        };
      };
    }, {}], 168: [function (_dereq_, module, exports) {
      // 7.2.9 SameValue(x, y)
      module.exports = Object.is || function is(x, y) {
        return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
      };
    }, {}], 169: [function (_dereq_, module, exports) {
      // Works with __proto__ only. Old v8 can't work with null proto objects.
      /* eslint-disable no-proto */
      var isObject = _dereq_('./_is-object'),
          anObject = _dereq_('./_an-object');
      var check = function check(O, proto) {
        anObject(O);
        if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
      };
      module.exports = {
        set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
        function (test, buggy, set) {
          try {
            set = _dereq_('./_ctx')(Function.call, _dereq_('./_object-gopd').f(Object.prototype, '__proto__').set, 2);
            set(test, []);
            buggy = !(test instanceof Array);
          } catch (e) {
            buggy = true;
          }
          return function setPrototypeOf(O, proto) {
            check(O, proto);
            if (buggy) O.__proto__ = proto;else set(O, proto);
            return O;
          };
        }({}, false) : undefined),
        check: check
      };
    }, { "./_an-object": 86, "./_ctx": 104, "./_is-object": 128, "./_object-gopd": 149 }], 170: [function (_dereq_, module, exports) {
      'use strict';

      var global = _dereq_('./_global'),
          dP = _dereq_('./_object-dp'),
          DESCRIPTORS = _dereq_('./_descriptors'),
          SPECIES = _dereq_('./_wks')('species');

      module.exports = function (KEY) {
        var C = global[KEY];
        if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
          configurable: true,
          get: function get() {
            return this;
          }
        });
      };
    }, { "./_descriptors": 107, "./_global": 117, "./_object-dp": 146, "./_wks": 196 }], 171: [function (_dereq_, module, exports) {
      var def = _dereq_('./_object-dp').f,
          has = _dereq_('./_has'),
          TAG = _dereq_('./_wks')('toStringTag');

      module.exports = function (it, tag, stat) {
        if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
      };
    }, { "./_has": 118, "./_object-dp": 146, "./_wks": 196 }], 172: [function (_dereq_, module, exports) {
      var shared = _dereq_('./_shared')('keys'),
          uid = _dereq_('./_uid');
      module.exports = function (key) {
        return shared[key] || (shared[key] = uid(key));
      };
    }, { "./_shared": 173, "./_uid": 193 }], 173: [function (_dereq_, module, exports) {
      var global = _dereq_('./_global'),
          SHARED = '__core-js_shared__',
          store = global[SHARED] || (global[SHARED] = {});
      module.exports = function (key) {
        return store[key] || (store[key] = {});
      };
    }, { "./_global": 117 }], 174: [function (_dereq_, module, exports) {
      // 7.3.20 SpeciesConstructor(O, defaultConstructor)
      var anObject = _dereq_('./_an-object'),
          aFunction = _dereq_('./_a-function'),
          SPECIES = _dereq_('./_wks')('species');
      module.exports = function (O, D) {
        var C = anObject(O).constructor,
            S;
        return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
      };
    }, { "./_a-function": 82, "./_an-object": 86, "./_wks": 196 }], 175: [function (_dereq_, module, exports) {
      var fails = _dereq_('./_fails');

      module.exports = function (method, arg) {
        return !!method && fails(function () {
          arg ? method.call(null, function () {}, 1) : method.call(null);
        });
      };
    }, { "./_fails": 113 }], 176: [function (_dereq_, module, exports) {
      var toInteger = _dereq_('./_to-integer'),
          defined = _dereq_('./_defined');
      // true  -> String#at
      // false -> String#codePointAt
      module.exports = function (TO_STRING) {
        return function (that, pos) {
          var s = String(defined(that)),
              i = toInteger(pos),
              l = s.length,
              a,
              b;
          if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
          a = s.charCodeAt(i);
          return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
        };
      };
    }, { "./_defined": 106, "./_to-integer": 185 }], 177: [function (_dereq_, module, exports) {
      // helper for String#{startsWith, endsWith, includes}
      var isRegExp = _dereq_('./_is-regexp'),
          defined = _dereq_('./_defined');

      module.exports = function (that, searchString, NAME) {
        if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
        return String(defined(that));
      };
    }, { "./_defined": 106, "./_is-regexp": 129 }], 178: [function (_dereq_, module, exports) {
      var $export = _dereq_('./_export'),
          fails = _dereq_('./_fails'),
          defined = _dereq_('./_defined'),
          quot = /"/g;
      // B.2.3.2.1 CreateHTML(string, tag, attribute, value)
      var createHTML = function createHTML(string, tag, attribute, value) {
        var S = String(defined(string)),
            p1 = '<' + tag;
        if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
        return p1 + '>' + S + '</' + tag + '>';
      };
      module.exports = function (NAME, exec) {
        var O = {};
        O[NAME] = exec(createHTML);
        $export($export.P + $export.F * fails(function () {
          var test = ''[NAME]('"');
          return test !== test.toLowerCase() || test.split('"').length > 3;
        }), 'String', O);
      };
    }, { "./_defined": 106, "./_export": 111, "./_fails": 113 }], 179: [function (_dereq_, module, exports) {
      // https://github.com/tc39/proposal-string-pad-start-end
      var toLength = _dereq_('./_to-length'),
          repeat = _dereq_('./_string-repeat'),
          defined = _dereq_('./_defined');

      module.exports = function (that, maxLength, fillString, left) {
        var S = String(defined(that)),
            stringLength = S.length,
            fillStr = fillString === undefined ? ' ' : String(fillString),
            intMaxLength = toLength(maxLength);
        if (intMaxLength <= stringLength || fillStr == '') return S;
        var fillLen = intMaxLength - stringLength,
            stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
        if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
        return left ? stringFiller + S : S + stringFiller;
      };
    }, { "./_defined": 106, "./_string-repeat": 180, "./_to-length": 187 }], 180: [function (_dereq_, module, exports) {
      'use strict';

      var toInteger = _dereq_('./_to-integer'),
          defined = _dereq_('./_defined');

      module.exports = function repeat(count) {
        var str = String(defined(this)),
            res = '',
            n = toInteger(count);
        if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
        for (; n > 0; (n >>>= 1) && (str += str)) {
          if (n & 1) res += str;
        }return res;
      };
    }, { "./_defined": 106, "./_to-integer": 185 }], 181: [function (_dereq_, module, exports) {
      var $export = _dereq_('./_export'),
          defined = _dereq_('./_defined'),
          fails = _dereq_('./_fails'),
          spaces = _dereq_('./_string-ws'),
          space = '[' + spaces + ']',
          non = "\u200B\x85",
          ltrim = RegExp('^' + space + space + '*'),
          rtrim = RegExp(space + space + '*$');

      var exporter = function exporter(KEY, exec, ALIAS) {
        var exp = {};
        var FORCE = fails(function () {
          return !!spaces[KEY]() || non[KEY]() != non;
        });
        var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
        if (ALIAS) exp[ALIAS] = fn;
        $export($export.P + $export.F * FORCE, 'String', exp);
      };

      // 1 -> String#trimLeft
      // 2 -> String#trimRight
      // 3 -> String#trim
      var trim = exporter.trim = function (string, TYPE) {
        string = String(defined(string));
        if (TYPE & 1) string = string.replace(ltrim, '');
        if (TYPE & 2) string = string.replace(rtrim, '');
        return string;
      };

      module.exports = exporter;
    }, { "./_defined": 106, "./_export": 111, "./_fails": 113, "./_string-ws": 182 }], 182: [function (_dereq_, module, exports) {
      module.exports = "\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003" + "\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF";
    }, {}], 183: [function (_dereq_, module, exports) {
      var ctx = _dereq_('./_ctx'),
          invoke = _dereq_('./_invoke'),
          html = _dereq_('./_html'),
          cel = _dereq_('./_dom-create'),
          global = _dereq_('./_global'),
          process = global.process,
          setTask = global.setImmediate,
          clearTask = global.clearImmediate,
          MessageChannel = global.MessageChannel,
          counter = 0,
          queue = {},
          ONREADYSTATECHANGE = 'onreadystatechange',
          defer,
          channel,
          port;
      var run = function run() {
        var id = +this;
        if (queue.hasOwnProperty(id)) {
          var fn = queue[id];
          delete queue[id];
          fn();
        }
      };
      var listener = function listener(event) {
        run.call(event.data);
      };
      // Node.js 0.9+ & IE10+ has setImmediate, otherwise:
      if (!setTask || !clearTask) {
        setTask = function setImmediate(fn) {
          var args = [],
              i = 1;
          while (arguments.length > i) {
            args.push(arguments[i++]);
          }queue[++counter] = function () {
            invoke(typeof fn == 'function' ? fn : Function(fn), args);
          };
          defer(counter);
          return counter;
        };
        clearTask = function clearImmediate(id) {
          delete queue[id];
        };
        // Node.js 0.8-
        if (_dereq_('./_cof')(process) == 'process') {
          defer = function defer(id) {
            process.nextTick(ctx(run, id, 1));
          };
          // Browsers with MessageChannel, includes WebWorkers
        } else if (MessageChannel) {
          channel = new MessageChannel();
          port = channel.port2;
          channel.port1.onmessage = listener;
          defer = ctx(port.postMessage, port, 1);
          // Browsers with postMessage, skip WebWorkers
          // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
        } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
          defer = function defer(id) {
            global.postMessage(id + '', '*');
          };
          global.addEventListener('message', listener, false);
          // IE8-
        } else if (ONREADYSTATECHANGE in cel('script')) {
          defer = function defer(id) {
            html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
              html.removeChild(this);
              run.call(id);
            };
          };
          // Rest old browsers
        } else {
          defer = function defer(id) {
            setTimeout(ctx(run, id, 1), 0);
          };
        }
      }
      module.exports = {
        set: setTask,
        clear: clearTask
      };
    }, { "./_cof": 97, "./_ctx": 104, "./_dom-create": 108, "./_global": 117, "./_html": 120, "./_invoke": 123 }], 184: [function (_dereq_, module, exports) {
      var toInteger = _dereq_('./_to-integer'),
          max = Math.max,
          min = Math.min;
      module.exports = function (index, length) {
        index = toInteger(index);
        return index < 0 ? max(index + length, 0) : min(index, length);
      };
    }, { "./_to-integer": 185 }], 185: [function (_dereq_, module, exports) {
      // 7.1.4 ToInteger
      var ceil = Math.ceil,
          floor = Math.floor;
      module.exports = function (it) {
        return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
      };
    }, {}], 186: [function (_dereq_, module, exports) {
      // to indexed object, toObject with fallback for non-array-like ES3 strings
      var IObject = _dereq_('./_iobject'),
          defined = _dereq_('./_defined');
      module.exports = function (it) {
        return IObject(defined(it));
      };
    }, { "./_defined": 106, "./_iobject": 124 }], 187: [function (_dereq_, module, exports) {
      // 7.1.15 ToLength
      var toInteger = _dereq_('./_to-integer'),
          min = Math.min;
      module.exports = function (it) {
        return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
      };
    }, { "./_to-integer": 185 }], 188: [function (_dereq_, module, exports) {
      // 7.1.13 ToObject(argument)
      var defined = _dereq_('./_defined');
      module.exports = function (it) {
        return Object(defined(it));
      };
    }, { "./_defined": 106 }], 189: [function (_dereq_, module, exports) {
      // 7.1.1 ToPrimitive(input [, PreferredType])
      var isObject = _dereq_('./_is-object');
      // instead of the ES6 spec version, we didn't implement @@toPrimitive case
      // and the second argument - flag - preferred type is a string
      module.exports = function (it, S) {
        if (!isObject(it)) return it;
        var fn, val;
        if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
        if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
        if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
        throw TypeError("Can't convert object to primitive value");
      };
    }, { "./_is-object": 128 }], 190: [function (_dereq_, module, exports) {
      'use strict';

      if (_dereq_('./_descriptors')) {
        var LIBRARY = _dereq_('./_library'),
            global = _dereq_('./_global'),
            fails = _dereq_('./_fails'),
            $export = _dereq_('./_export'),
            $typed = _dereq_('./_typed'),
            $buffer = _dereq_('./_typed-buffer'),
            ctx = _dereq_('./_ctx'),
            anInstance = _dereq_('./_an-instance'),
            propertyDesc = _dereq_('./_property-desc'),
            hide = _dereq_('./_hide'),
            redefineAll = _dereq_('./_redefine-all'),
            toInteger = _dereq_('./_to-integer'),
            toLength = _dereq_('./_to-length'),
            toIndex = _dereq_('./_to-index'),
            toPrimitive = _dereq_('./_to-primitive'),
            has = _dereq_('./_has'),
            same = _dereq_('./_same-value'),
            classof = _dereq_('./_classof'),
            isObject = _dereq_('./_is-object'),
            toObject = _dereq_('./_to-object'),
            isArrayIter = _dereq_('./_is-array-iter'),
            create = _dereq_('./_object-create'),
            getPrototypeOf = _dereq_('./_object-gpo'),
            gOPN = _dereq_('./_object-gopn').f,
            getIterFn = _dereq_('./core.get-iterator-method'),
            uid = _dereq_('./_uid'),
            wks = _dereq_('./_wks'),
            createArrayMethod = _dereq_('./_array-methods'),
            createArrayIncludes = _dereq_('./_array-includes'),
            speciesConstructor = _dereq_('./_species-constructor'),
            ArrayIterators = _dereq_('./es6.array.iterator'),
            Iterators = _dereq_('./_iterators'),
            $iterDetect = _dereq_('./_iter-detect'),
            setSpecies = _dereq_('./_set-species'),
            arrayFill = _dereq_('./_array-fill'),
            arrayCopyWithin = _dereq_('./_array-copy-within'),
            $DP = _dereq_('./_object-dp'),
            $GOPD = _dereq_('./_object-gopd'),
            dP = $DP.f,
            gOPD = $GOPD.f,
            RangeError = global.RangeError,
            TypeError = global.TypeError,
            Uint8Array = global.Uint8Array,
            ARRAY_BUFFER = 'ArrayBuffer',
            SHARED_BUFFER = 'Shared' + ARRAY_BUFFER,
            BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT',
            PROTOTYPE = 'prototype',
            ArrayProto = Array[PROTOTYPE],
            $ArrayBuffer = $buffer.ArrayBuffer,
            $DataView = $buffer.DataView,
            arrayForEach = createArrayMethod(0),
            arrayFilter = createArrayMethod(2),
            arraySome = createArrayMethod(3),
            arrayEvery = createArrayMethod(4),
            arrayFind = createArrayMethod(5),
            arrayFindIndex = createArrayMethod(6),
            arrayIncludes = createArrayIncludes(true),
            arrayIndexOf = createArrayIncludes(false),
            arrayValues = ArrayIterators.values,
            arrayKeys = ArrayIterators.keys,
            arrayEntries = ArrayIterators.entries,
            arrayLastIndexOf = ArrayProto.lastIndexOf,
            arrayReduce = ArrayProto.reduce,
            arrayReduceRight = ArrayProto.reduceRight,
            arrayJoin = ArrayProto.join,
            arraySort = ArrayProto.sort,
            arraySlice = ArrayProto.slice,
            arrayToString = ArrayProto.toString,
            arrayToLocaleString = ArrayProto.toLocaleString,
            ITERATOR = wks('iterator'),
            TAG = wks('toStringTag'),
            TYPED_CONSTRUCTOR = uid('typed_constructor'),
            DEF_CONSTRUCTOR = uid('def_constructor'),
            ALL_CONSTRUCTORS = $typed.CONSTR,
            TYPED_ARRAY = $typed.TYPED,
            VIEW = $typed.VIEW,
            WRONG_LENGTH = 'Wrong length!';

        var $map = createArrayMethod(1, function (O, length) {
          return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
        });

        var LITTLE_ENDIAN = fails(function () {
          return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
        });

        var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
          new Uint8Array(1).set({});
        });

        var strictToLength = function strictToLength(it, SAME) {
          if (it === undefined) throw TypeError(WRONG_LENGTH);
          var number = +it,
              length = toLength(it);
          if (SAME && !same(number, length)) throw RangeError(WRONG_LENGTH);
          return length;
        };

        var toOffset = function toOffset(it, BYTES) {
          var offset = toInteger(it);
          if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
          return offset;
        };

        var validate = function validate(it) {
          if (isObject(it) && TYPED_ARRAY in it) return it;
          throw TypeError(it + ' is not a typed array!');
        };

        var allocate = function allocate(C, length) {
          if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
            throw TypeError('It is not a typed array constructor!');
          }return new C(length);
        };

        var speciesFromList = function speciesFromList(O, list) {
          return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
        };

        var fromList = function fromList(C, list) {
          var index = 0,
              length = list.length,
              result = allocate(C, length);
          while (length > index) {
            result[index] = list[index++];
          }return result;
        };

        var addGetter = function addGetter(it, key, internal) {
          dP(it, key, { get: function get() {
              return this._d[internal];
            } });
        };

        var $from = function from(source /*, mapfn, thisArg */) {
          var O = toObject(source),
              aLen = arguments.length,
              mapfn = aLen > 1 ? arguments[1] : undefined,
              mapping = mapfn !== undefined,
              iterFn = getIterFn(O),
              i,
              length,
              values,
              result,
              step,
              iterator;
          if (iterFn != undefined && !isArrayIter(iterFn)) {
            for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
              values.push(step.value);
            }O = values;
          }
          if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
          for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
            result[i] = mapping ? mapfn(O[i], i) : O[i];
          }
          return result;
        };

        var $of = function of() /*...items*/{
          var index = 0,
              length = arguments.length,
              result = allocate(this, length);
          while (length > index) {
            result[index] = arguments[index++];
          }return result;
        };

        // iOS Safari 6.x fails here
        var TO_LOCALE_BUG = !!Uint8Array && fails(function () {
          arrayToLocaleString.call(new Uint8Array(1));
        });

        var $toLocaleString = function toLocaleString() {
          return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
        };

        var proto = {
          copyWithin: function copyWithin(target, start /*, end */) {
            return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
          },
          every: function every(callbackfn /*, thisArg */) {
            return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
          },
          fill: function fill(value /*, start, end */) {
            // eslint-disable-line no-unused-vars
            return arrayFill.apply(validate(this), arguments);
          },
          filter: function filter(callbackfn /*, thisArg */) {
            return speciesFromList(this, arrayFilter(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined));
          },
          find: function find(predicate /*, thisArg */) {
            return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
          },
          findIndex: function findIndex(predicate /*, thisArg */) {
            return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
          },
          forEach: function forEach(callbackfn /*, thisArg */) {
            arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
          },
          indexOf: function indexOf(searchElement /*, fromIndex */) {
            return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
          },
          includes: function includes(searchElement /*, fromIndex */) {
            return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
          },
          join: function join(separator) {
            // eslint-disable-line no-unused-vars
            return arrayJoin.apply(validate(this), arguments);
          },
          lastIndexOf: function lastIndexOf(searchElement /*, fromIndex */) {
            // eslint-disable-line no-unused-vars
            return arrayLastIndexOf.apply(validate(this), arguments);
          },
          map: function map(mapfn /*, thisArg */) {
            return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
          },
          reduce: function reduce(callbackfn /*, initialValue */) {
            // eslint-disable-line no-unused-vars
            return arrayReduce.apply(validate(this), arguments);
          },
          reduceRight: function reduceRight(callbackfn /*, initialValue */) {
            // eslint-disable-line no-unused-vars
            return arrayReduceRight.apply(validate(this), arguments);
          },
          reverse: function reverse() {
            var that = this,
                length = validate(that).length,
                middle = Math.floor(length / 2),
                index = 0,
                value;
            while (index < middle) {
              value = that[index];
              that[index++] = that[--length];
              that[length] = value;
            }return that;
          },
          some: function some(callbackfn /*, thisArg */) {
            return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
          },
          sort: function sort(comparefn) {
            return arraySort.call(validate(this), comparefn);
          },
          subarray: function subarray(begin, end) {
            var O = validate(this),
                length = O.length,
                $begin = toIndex(begin, length);
            return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(O.buffer, O.byteOffset + $begin * O.BYTES_PER_ELEMENT, toLength((end === undefined ? length : toIndex(end, length)) - $begin));
          }
        };

        var $slice = function slice(start, end) {
          return speciesFromList(this, arraySlice.call(validate(this), start, end));
        };

        var $set = function set(arrayLike /*, offset */) {
          validate(this);
          var offset = toOffset(arguments[1], 1),
              length = this.length,
              src = toObject(arrayLike),
              len = toLength(src.length),
              index = 0;
          if (len + offset > length) throw RangeError(WRONG_LENGTH);
          while (index < len) {
            this[offset + index] = src[index++];
          }
        };

        var $iterators = {
          entries: function entries() {
            return arrayEntries.call(validate(this));
          },
          keys: function keys() {
            return arrayKeys.call(validate(this));
          },
          values: function values() {
            return arrayValues.call(validate(this));
          }
        };

        var isTAIndex = function isTAIndex(target, key) {
          return isObject(target) && target[TYPED_ARRAY] && (typeof key === "undefined" ? "undefined" : _typeof2(key)) != 'symbol' && key in target && String(+key) == String(key);
        };
        var $getDesc = function getOwnPropertyDescriptor(target, key) {
          return isTAIndex(target, key = toPrimitive(key, true)) ? propertyDesc(2, target[key]) : gOPD(target, key);
        };
        var $setDesc = function defineProperty(target, key, desc) {
          if (isTAIndex(target, key = toPrimitive(key, true)) && isObject(desc) && has(desc, 'value') && !has(desc, 'get') && !has(desc, 'set')
          // TODO: add validation descriptor w/o calling accessors
          && !desc.configurable && (!has(desc, 'writable') || desc.writable) && (!has(desc, 'enumerable') || desc.enumerable)) {
            target[key] = desc.value;
            return target;
          } else return dP(target, key, desc);
        };

        if (!ALL_CONSTRUCTORS) {
          $GOPD.f = $getDesc;
          $DP.f = $setDesc;
        }

        $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
          getOwnPropertyDescriptor: $getDesc,
          defineProperty: $setDesc
        });

        if (fails(function () {
          arrayToString.call({});
        })) {
          arrayToString = arrayToLocaleString = function toString() {
            return arrayJoin.call(this);
          };
        }

        var $TypedArrayPrototype$ = redefineAll({}, proto);
        redefineAll($TypedArrayPrototype$, $iterators);
        hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
        redefineAll($TypedArrayPrototype$, {
          slice: $slice,
          set: $set,
          constructor: function constructor() {/* noop */},
          toString: arrayToString,
          toLocaleString: $toLocaleString
        });
        addGetter($TypedArrayPrototype$, 'buffer', 'b');
        addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
        addGetter($TypedArrayPrototype$, 'byteLength', 'l');
        addGetter($TypedArrayPrototype$, 'length', 'e');
        dP($TypedArrayPrototype$, TAG, {
          get: function get() {
            return this[TYPED_ARRAY];
          }
        });

        module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
          CLAMPED = !!CLAMPED;
          var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array',
              ISNT_UINT8 = NAME != 'Uint8Array',
              GETTER = 'get' + KEY,
              SETTER = 'set' + KEY,
              TypedArray = global[NAME],
              Base = TypedArray || {},
              TAC = TypedArray && getPrototypeOf(TypedArray),
              FORCED = !TypedArray || !$typed.ABV,
              O = {},
              TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
          var getter = function getter(that, index) {
            var data = that._d;
            return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
          };
          var setter = function setter(that, index, value) {
            var data = that._d;
            if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
            data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
          };
          var addElement = function addElement(that, index) {
            dP(that, index, {
              get: function get() {
                return getter(this, index);
              },
              set: function set(value) {
                return setter(this, index, value);
              },
              enumerable: true
            });
          };
          if (FORCED) {
            TypedArray = wrapper(function (that, data, $offset, $length) {
              anInstance(that, TypedArray, NAME, '_d');
              var index = 0,
                  offset = 0,
                  buffer,
                  byteLength,
                  length,
                  klass;
              if (!isObject(data)) {
                length = strictToLength(data, true);
                byteLength = length * BYTES;
                buffer = new $ArrayBuffer(byteLength);
              } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
                buffer = data;
                offset = toOffset($offset, BYTES);
                var $len = data.byteLength;
                if ($length === undefined) {
                  if ($len % BYTES) throw RangeError(WRONG_LENGTH);
                  byteLength = $len - offset;
                  if (byteLength < 0) throw RangeError(WRONG_LENGTH);
                } else {
                  byteLength = toLength($length) * BYTES;
                  if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
                }
                length = byteLength / BYTES;
              } else if (TYPED_ARRAY in data) {
                return fromList(TypedArray, data);
              } else {
                return $from.call(TypedArray, data);
              }
              hide(that, '_d', {
                b: buffer,
                o: offset,
                l: byteLength,
                e: length,
                v: new $DataView(buffer)
              });
              while (index < length) {
                addElement(that, index++);
              }
            });
            TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
            hide(TypedArrayPrototype, 'constructor', TypedArray);
          } else if (!$iterDetect(function (iter) {
            // V8 works with iterators, but fails in many other cases
            // https://code.google.com/p/v8/issues/detail?id=4552
            new TypedArray(null); // eslint-disable-line no-new
            new TypedArray(iter); // eslint-disable-line no-new
          }, true)) {
            TypedArray = wrapper(function (that, data, $offset, $length) {
              anInstance(that, TypedArray, NAME);
              var klass;
              // `ws` module bug, temporarily remove validation length for Uint8Array
              // https://github.com/websockets/ws/pull/645
              if (!isObject(data)) return new Base(strictToLength(data, ISNT_UINT8));
              if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
                return $length !== undefined ? new Base(data, toOffset($offset, BYTES), $length) : $offset !== undefined ? new Base(data, toOffset($offset, BYTES)) : new Base(data);
              }
              if (TYPED_ARRAY in data) return fromList(TypedArray, data);
              return $from.call(TypedArray, data);
            });
            arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
              if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
            });
            TypedArray[PROTOTYPE] = TypedArrayPrototype;
            if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
          }
          var $nativeIterator = TypedArrayPrototype[ITERATOR],
              CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined),
              $iterator = $iterators.values;
          hide(TypedArray, TYPED_CONSTRUCTOR, true);
          hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
          hide(TypedArrayPrototype, VIEW, true);
          hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

          if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
            dP(TypedArrayPrototype, TAG, {
              get: function get() {
                return NAME;
              }
            });
          }

          O[NAME] = TypedArray;

          $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

          $export($export.S, NAME, {
            BYTES_PER_ELEMENT: BYTES,
            from: $from,
            of: $of
          });

          if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

          $export($export.P, NAME, proto);

          setSpecies(NAME);

          $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });

          $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

          $export($export.P + $export.F * (TypedArrayPrototype.toString != arrayToString), NAME, { toString: arrayToString });

          $export($export.P + $export.F * fails(function () {
            new TypedArray(1).slice();
          }), NAME, { slice: $slice });

          $export($export.P + $export.F * (fails(function () {
            return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
          }) || !fails(function () {
            TypedArrayPrototype.toLocaleString.call([1, 2]);
          })), NAME, { toLocaleString: $toLocaleString });

          Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
          if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
        };
      } else module.exports = function () {/* empty */};
    }, { "./_an-instance": 85, "./_array-copy-within": 87, "./_array-fill": 88, "./_array-includes": 90, "./_array-methods": 91, "./_classof": 96, "./_ctx": 104, "./_descriptors": 107, "./_export": 111, "./_fails": 113, "./_global": 117, "./_has": 118, "./_hide": 119, "./_is-array-iter": 125, "./_is-object": 128, "./_iter-detect": 133, "./_iterators": 135, "./_library": 137, "./_object-create": 145, "./_object-dp": 146, "./_object-gopd": 149, "./_object-gopn": 151, "./_object-gpo": 153, "./_property-desc": 164, "./_redefine-all": 165, "./_same-value": 168, "./_set-species": 170, "./_species-constructor": 174, "./_to-index": 184, "./_to-integer": 185, "./_to-length": 187, "./_to-object": 188, "./_to-primitive": 189, "./_typed": 192, "./_typed-buffer": 191, "./_uid": 193, "./_wks": 196, "./core.get-iterator-method": 197, "./es6.array.iterator": 209 }], 191: [function (_dereq_, module, exports) {
      'use strict';

      var global = _dereq_('./_global'),
          DESCRIPTORS = _dereq_('./_descriptors'),
          LIBRARY = _dereq_('./_library'),
          $typed = _dereq_('./_typed'),
          hide = _dereq_('./_hide'),
          redefineAll = _dereq_('./_redefine-all'),
          fails = _dereq_('./_fails'),
          anInstance = _dereq_('./_an-instance'),
          toInteger = _dereq_('./_to-integer'),
          toLength = _dereq_('./_to-length'),
          gOPN = _dereq_('./_object-gopn').f,
          dP = _dereq_('./_object-dp').f,
          arrayFill = _dereq_('./_array-fill'),
          setToStringTag = _dereq_('./_set-to-string-tag'),
          ARRAY_BUFFER = 'ArrayBuffer',
          DATA_VIEW = 'DataView',
          PROTOTYPE = 'prototype',
          WRONG_LENGTH = 'Wrong length!',
          WRONG_INDEX = 'Wrong index!',
          $ArrayBuffer = global[ARRAY_BUFFER],
          $DataView = global[DATA_VIEW],
          Math = global.Math,
          RangeError = global.RangeError,
          Infinity = global.Infinity,
          BaseBuffer = $ArrayBuffer,
          abs = Math.abs,
          pow = Math.pow,
          floor = Math.floor,
          log = Math.log,
          LN2 = Math.LN2,
          BUFFER = 'buffer',
          BYTE_LENGTH = 'byteLength',
          BYTE_OFFSET = 'byteOffset',
          $BUFFER = DESCRIPTORS ? '_b' : BUFFER,
          $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH,
          $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;

      // IEEE754 conversions based on https://github.com/feross/ieee754
      var packIEEE754 = function packIEEE754(value, mLen, nBytes) {
        var buffer = Array(nBytes),
            eLen = nBytes * 8 - mLen - 1,
            eMax = (1 << eLen) - 1,
            eBias = eMax >> 1,
            rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0,
            i = 0,
            s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0,
            e,
            m,
            c;
        value = abs(value);
        if (value != value || value === Infinity) {
          m = value != value ? 1 : 0;
          e = eMax;
        } else {
          e = floor(log(value) / LN2);
          if (value * (c = pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * pow(2, eBias - 1) * pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8) {}
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8) {}
        buffer[--i] |= s * 128;
        return buffer;
      };
      var unpackIEEE754 = function unpackIEEE754(buffer, mLen, nBytes) {
        var eLen = nBytes * 8 - mLen - 1,
            eMax = (1 << eLen) - 1,
            eBias = eMax >> 1,
            nBits = eLen - 7,
            i = nBytes - 1,
            s = buffer[i--],
            e = s & 127,
            m;
        s >>= 7;
        for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8) {}
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8) {}
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : s ? -Infinity : Infinity;
        } else {
          m = m + pow(2, mLen);
          e = e - eBias;
        }return (s ? -1 : 1) * m * pow(2, e - mLen);
      };

      var unpackI32 = function unpackI32(bytes) {
        return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
      };
      var packI8 = function packI8(it) {
        return [it & 0xff];
      };
      var packI16 = function packI16(it) {
        return [it & 0xff, it >> 8 & 0xff];
      };
      var packI32 = function packI32(it) {
        return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
      };
      var packF64 = function packF64(it) {
        return packIEEE754(it, 52, 8);
      };
      var packF32 = function packF32(it) {
        return packIEEE754(it, 23, 4);
      };

      var addGetter = function addGetter(C, key, internal) {
        dP(C[PROTOTYPE], key, { get: function get() {
            return this[internal];
          } });
      };

      var get = function get(view, bytes, index, isLittleEndian) {
        var numIndex = +index,
            intIndex = toInteger(numIndex);
        if (numIndex != intIndex || intIndex < 0 || intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
        var store = view[$BUFFER]._b,
            start = intIndex + view[$OFFSET],
            pack = store.slice(start, start + bytes);
        return isLittleEndian ? pack : pack.reverse();
      };
      var set = function set(view, bytes, index, conversion, value, isLittleEndian) {
        var numIndex = +index,
            intIndex = toInteger(numIndex);
        if (numIndex != intIndex || intIndex < 0 || intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
        var store = view[$BUFFER]._b,
            start = intIndex + view[$OFFSET],
            pack = conversion(+value);
        for (var i = 0; i < bytes; i++) {
          store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
        }
      };

      var validateArrayBufferArguments = function validateArrayBufferArguments(that, length) {
        anInstance(that, $ArrayBuffer, ARRAY_BUFFER);
        var numberLength = +length,
            byteLength = toLength(numberLength);
        if (numberLength != byteLength) throw RangeError(WRONG_LENGTH);
        return byteLength;
      };

      if (!$typed.ABV) {
        $ArrayBuffer = function ArrayBuffer(length) {
          var byteLength = validateArrayBufferArguments(this, length);
          this._b = arrayFill.call(Array(byteLength), 0);
          this[$LENGTH] = byteLength;
        };

        $DataView = function DataView(buffer, byteOffset, byteLength) {
          anInstance(this, $DataView, DATA_VIEW);
          anInstance(buffer, $ArrayBuffer, DATA_VIEW);
          var bufferLength = buffer[$LENGTH],
              offset = toInteger(byteOffset);
          if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
          byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
          if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
          this[$BUFFER] = buffer;
          this[$OFFSET] = offset;
          this[$LENGTH] = byteLength;
        };

        if (DESCRIPTORS) {
          addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
          addGetter($DataView, BUFFER, '_b');
          addGetter($DataView, BYTE_LENGTH, '_l');
          addGetter($DataView, BYTE_OFFSET, '_o');
        }

        redefineAll($DataView[PROTOTYPE], {
          getInt8: function getInt8(byteOffset) {
            return get(this, 1, byteOffset)[0] << 24 >> 24;
          },
          getUint8: function getUint8(byteOffset) {
            return get(this, 1, byteOffset)[0];
          },
          getInt16: function getInt16(byteOffset /*, littleEndian */) {
            var bytes = get(this, 2, byteOffset, arguments[1]);
            return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
          },
          getUint16: function getUint16(byteOffset /*, littleEndian */) {
            var bytes = get(this, 2, byteOffset, arguments[1]);
            return bytes[1] << 8 | bytes[0];
          },
          getInt32: function getInt32(byteOffset /*, littleEndian */) {
            return unpackI32(get(this, 4, byteOffset, arguments[1]));
          },
          getUint32: function getUint32(byteOffset /*, littleEndian */) {
            return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
          },
          getFloat32: function getFloat32(byteOffset /*, littleEndian */) {
            return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
          },
          getFloat64: function getFloat64(byteOffset /*, littleEndian */) {
            return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
          },
          setInt8: function setInt8(byteOffset, value) {
            set(this, 1, byteOffset, packI8, value);
          },
          setUint8: function setUint8(byteOffset, value) {
            set(this, 1, byteOffset, packI8, value);
          },
          setInt16: function setInt16(byteOffset, value /*, littleEndian */) {
            set(this, 2, byteOffset, packI16, value, arguments[2]);
          },
          setUint16: function setUint16(byteOffset, value /*, littleEndian */) {
            set(this, 2, byteOffset, packI16, value, arguments[2]);
          },
          setInt32: function setInt32(byteOffset, value /*, littleEndian */) {
            set(this, 4, byteOffset, packI32, value, arguments[2]);
          },
          setUint32: function setUint32(byteOffset, value /*, littleEndian */) {
            set(this, 4, byteOffset, packI32, value, arguments[2]);
          },
          setFloat32: function setFloat32(byteOffset, value /*, littleEndian */) {
            set(this, 4, byteOffset, packF32, value, arguments[2]);
          },
          setFloat64: function setFloat64(byteOffset, value /*, littleEndian */) {
            set(this, 8, byteOffset, packF64, value, arguments[2]);
          }
        });
      } else {
        if (!fails(function () {
          new $ArrayBuffer(); // eslint-disable-line no-new
        }) || !fails(function () {
          new $ArrayBuffer(.5); // eslint-disable-line no-new
        })) {
          $ArrayBuffer = function ArrayBuffer(length) {
            return new BaseBuffer(validateArrayBufferArguments(this, length));
          };
          var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
          for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
            if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
          };
          if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
        }
        // iOS Safari 7.x bug
        var view = new $DataView(new $ArrayBuffer(2)),
            $setInt8 = $DataView[PROTOTYPE].setInt8;
        view.setInt8(0, 2147483648);
        view.setInt8(1, 2147483649);
        if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
          setInt8: function setInt8(byteOffset, value) {
            $setInt8.call(this, byteOffset, value << 24 >> 24);
          },
          setUint8: function setUint8(byteOffset, value) {
            $setInt8.call(this, byteOffset, value << 24 >> 24);
          }
        }, true);
      }
      setToStringTag($ArrayBuffer, ARRAY_BUFFER);
      setToStringTag($DataView, DATA_VIEW);
      hide($DataView[PROTOTYPE], $typed.VIEW, true);
      exports[ARRAY_BUFFER] = $ArrayBuffer;
      exports[DATA_VIEW] = $DataView;
    }, { "./_an-instance": 85, "./_array-fill": 88, "./_descriptors": 107, "./_fails": 113, "./_global": 117, "./_hide": 119, "./_library": 137, "./_object-dp": 146, "./_object-gopn": 151, "./_redefine-all": 165, "./_set-to-string-tag": 171, "./_to-integer": 185, "./_to-length": 187, "./_typed": 192 }], 192: [function (_dereq_, module, exports) {
      var global = _dereq_('./_global'),
          hide = _dereq_('./_hide'),
          uid = _dereq_('./_uid'),
          TYPED = uid('typed_array'),
          VIEW = uid('view'),
          ABV = !!(global.ArrayBuffer && global.DataView),
          CONSTR = ABV,
          i = 0,
          l = 9,
          Typed;

      var TypedArrayConstructors = 'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'.split(',');

      while (i < l) {
        if (Typed = global[TypedArrayConstructors[i++]]) {
          hide(Typed.prototype, TYPED, true);
          hide(Typed.prototype, VIEW, true);
        } else CONSTR = false;
      }

      module.exports = {
        ABV: ABV,
        CONSTR: CONSTR,
        TYPED: TYPED,
        VIEW: VIEW
      };
    }, { "./_global": 117, "./_hide": 119, "./_uid": 193 }], 193: [function (_dereq_, module, exports) {
      var id = 0,
          px = Math.random();
      module.exports = function (key) {
        return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
      };
    }, {}], 194: [function (_dereq_, module, exports) {
      var global = _dereq_('./_global'),
          core = _dereq_('./_core'),
          LIBRARY = _dereq_('./_library'),
          wksExt = _dereq_('./_wks-ext'),
          defineProperty = _dereq_('./_object-dp').f;
      module.exports = function (name) {
        var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
        if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
      };
    }, { "./_core": 102, "./_global": 117, "./_library": 137, "./_object-dp": 146, "./_wks-ext": 195 }], 195: [function (_dereq_, module, exports) {
      exports.f = _dereq_('./_wks');
    }, { "./_wks": 196 }], 196: [function (_dereq_, module, exports) {
      var store = _dereq_('./_shared')('wks'),
          uid = _dereq_('./_uid'),
          _Symbol2 = _dereq_('./_global').Symbol,
          USE_SYMBOL = typeof _Symbol2 == 'function';

      var $exports = module.exports = function (name) {
        return store[name] || (store[name] = USE_SYMBOL && _Symbol2[name] || (USE_SYMBOL ? _Symbol2 : uid)('Symbol.' + name));
      };

      $exports.store = store;
    }, { "./_global": 117, "./_shared": 173, "./_uid": 193 }], 197: [function (_dereq_, module, exports) {
      var classof = _dereq_('./_classof'),
          ITERATOR = _dereq_('./_wks')('iterator'),
          Iterators = _dereq_('./_iterators');
      module.exports = _dereq_('./_core').getIteratorMethod = function (it) {
        if (it != undefined) return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
      };
    }, { "./_classof": 96, "./_core": 102, "./_iterators": 135, "./_wks": 196 }], 198: [function (_dereq_, module, exports) {
      // https://github.com/benjamingr/RexExp.escape
      var $export = _dereq_('./_export'),
          $re = _dereq_('./_replacer')(/[\\^$*+?.()|[\]{}]/g, '\\$&');

      $export($export.S, 'RegExp', { escape: function escape(it) {
          return $re(it);
        } });
    }, { "./_export": 111, "./_replacer": 167 }], 199: [function (_dereq_, module, exports) {
      // 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
      var $export = _dereq_('./_export');

      $export($export.P, 'Array', { copyWithin: _dereq_('./_array-copy-within') });

      _dereq_('./_add-to-unscopables')('copyWithin');
    }, { "./_add-to-unscopables": 84, "./_array-copy-within": 87, "./_export": 111 }], 200: [function (_dereq_, module, exports) {
      'use strict';

      var $export = _dereq_('./_export'),
          $every = _dereq_('./_array-methods')(4);

      $export($export.P + $export.F * !_dereq_('./_strict-method')([].every, true), 'Array', {
        // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
        every: function every(callbackfn /* , thisArg */) {
          return $every(this, callbackfn, arguments[1]);
        }
      });
    }, { "./_array-methods": 91, "./_export": 111, "./_strict-method": 175 }], 201: [function (_dereq_, module, exports) {
      // 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
      var $export = _dereq_('./_export');

      $export($export.P, 'Array', { fill: _dereq_('./_array-fill') });

      _dereq_('./_add-to-unscopables')('fill');
    }, { "./_add-to-unscopables": 84, "./_array-fill": 88, "./_export": 111 }], 202: [function (_dereq_, module, exports) {
      'use strict';

      var $export = _dereq_('./_export'),
          $filter = _dereq_('./_array-methods')(2);

      $export($export.P + $export.F * !_dereq_('./_strict-method')([].filter, true), 'Array', {
        // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
        filter: function filter(callbackfn /* , thisArg */) {
          return $filter(this, callbackfn, arguments[1]);
        }
      });
    }, { "./_array-methods": 91, "./_export": 111, "./_strict-method": 175 }], 203: [function (_dereq_, module, exports) {
      'use strict';
      // 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)

      var $export = _dereq_('./_export'),
          $find = _dereq_('./_array-methods')(6),
          KEY = 'findIndex',
          forced = true;
      // Shouldn't skip holes
      if (KEY in []) Array(1)[KEY](function () {
        forced = false;
      });
      $export($export.P + $export.F * forced, 'Array', {
        findIndex: function findIndex(callbackfn /*, that = undefined */) {
          return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
        }
      });
      _dereq_('./_add-to-unscopables')(KEY);
    }, { "./_add-to-unscopables": 84, "./_array-methods": 91, "./_export": 111 }], 204: [function (_dereq_, module, exports) {
      'use strict';
      // 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)

      var $export = _dereq_('./_export'),
          $find = _dereq_('./_array-methods')(5),
          KEY = 'find',
          forced = true;
      // Shouldn't skip holes
      if (KEY in []) Array(1)[KEY](function () {
        forced = false;
      });
      $export($export.P + $export.F * forced, 'Array', {
        find: function find(callbackfn /*, that = undefined */) {
          return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
        }
      });
      _dereq_('./_add-to-unscopables')(KEY);
    }, { "./_add-to-unscopables": 84, "./_array-methods": 91, "./_export": 111 }], 205: [function (_dereq_, module, exports) {
      'use strict';

      var $export = _dereq_('./_export'),
          $forEach = _dereq_('./_array-methods')(0),
          STRICT = _dereq_('./_strict-method')([].forEach, true);

      $export($export.P + $export.F * !STRICT, 'Array', {
        // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
        forEach: function forEach(callbackfn /* , thisArg */) {
          return $forEach(this, callbackfn, arguments[1]);
        }
      });
    }, { "./_array-methods": 91, "./_export": 111, "./_strict-method": 175 }], 206: [function (_dereq_, module, exports) {
      'use strict';

      var ctx = _dereq_('./_ctx'),
          $export = _dereq_('./_export'),
          toObject = _dereq_('./_to-object'),
          call = _dereq_('./_iter-call'),
          isArrayIter = _dereq_('./_is-array-iter'),
          toLength = _dereq_('./_to-length'),
          createProperty = _dereq_('./_create-property'),
          getIterFn = _dereq_('./core.get-iterator-method');

      $export($export.S + $export.F * !_dereq_('./_iter-detect')(function (iter) {
        Array.from(iter);
      }), 'Array', {
        // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
        from: function from(arrayLike /*, mapfn = undefined, thisArg = undefined*/) {
          var O = toObject(arrayLike),
              C = typeof this == 'function' ? this : Array,
              aLen = arguments.length,
              mapfn = aLen > 1 ? arguments[1] : undefined,
              mapping = mapfn !== undefined,
              index = 0,
              iterFn = getIterFn(O),
              length,
              result,
              step,
              iterator;
          if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
          // if object isn't iterable or it's array with default iterator - use simple case
          if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
            for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
              createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
            }
          } else {
            length = toLength(O.length);
            for (result = new C(length); length > index; index++) {
              createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
            }
          }
          result.length = index;
          return result;
        }
      });
    }, { "./_create-property": 103, "./_ctx": 104, "./_export": 111, "./_is-array-iter": 125, "./_iter-call": 130, "./_iter-detect": 133, "./_to-length": 187, "./_to-object": 188, "./core.get-iterator-method": 197 }], 207: [function (_dereq_, module, exports) {
      'use strict';

      var $export = _dereq_('./_export'),
          $indexOf = _dereq_('./_array-includes')(false),
          $native = [].indexOf,
          NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

      $export($export.P + $export.F * (NEGATIVE_ZERO || !_dereq_('./_strict-method')($native)), 'Array', {
        // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
        indexOf: function indexOf(searchElement /*, fromIndex = 0 */) {
          return NEGATIVE_ZERO
          // convert -0 to +0
          ? $native.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments[1]);
        }
      });
    }, { "./_array-includes": 90, "./_export": 111, "./_strict-method": 175 }], 208: [function (_dereq_, module, exports) {
      // 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
      var $export = _dereq_('./_export');

      $export($export.S, 'Array', { isArray: _dereq_('./_is-array') });
    }, { "./_export": 111, "./_is-array": 126 }], 209: [function (_dereq_, module, exports) {
      'use strict';

      var addToUnscopables = _dereq_('./_add-to-unscopables'),
          step = _dereq_('./_iter-step'),
          Iterators = _dereq_('./_iterators'),
          toIObject = _dereq_('./_to-iobject');

      // 22.1.3.4 Array.prototype.entries()
      // 22.1.3.13 Array.prototype.keys()
      // 22.1.3.29 Array.prototype.values()
      // 22.1.3.30 Array.prototype[@@iterator]()
      module.exports = _dereq_('./_iter-define')(Array, 'Array', function (iterated, kind) {
        this._t = toIObject(iterated); // target
        this._i = 0; // next index
        this._k = kind; // kind
        // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
      }, function () {
        var O = this._t,
            kind = this._k,
            index = this._i++;
        if (!O || index >= O.length) {
          this._t = undefined;
          return step(1);
        }
        if (kind == 'keys') return step(0, index);
        if (kind == 'values') return step(0, O[index]);
        return step(0, [index, O[index]]);
      }, 'values');

      // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
      Iterators.Arguments = Iterators.Array;

      addToUnscopables('keys');
      addToUnscopables('values');
      addToUnscopables('entries');
    }, { "./_add-to-unscopables": 84, "./_iter-define": 132, "./_iter-step": 134, "./_iterators": 135, "./_to-iobject": 186 }], 210: [function (_dereq_, module, exports) {
      'use strict';
      // 22.1.3.13 Array.prototype.join(separator)

      var $export = _dereq_('./_export'),
          toIObject = _dereq_('./_to-iobject'),
          arrayJoin = [].join;

      // fallback for not array-like strings
      $export($export.P + $export.F * (_dereq_('./_iobject') != Object || !_dereq_('./_strict-method')(arrayJoin)), 'Array', {
        join: function join(separator) {
          return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
        }
      });
    }, { "./_export": 111, "./_iobject": 124, "./_strict-method": 175, "./_to-iobject": 186 }], 211: [function (_dereq_, module, exports) {
      'use strict';

      var $export = _dereq_('./_export'),
          toIObject = _dereq_('./_to-iobject'),
          toInteger = _dereq_('./_to-integer'),
          toLength = _dereq_('./_to-length'),
          $native = [].lastIndexOf,
          NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;

      $export($export.P + $export.F * (NEGATIVE_ZERO || !_dereq_('./_strict-method')($native)), 'Array', {
        // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
        lastIndexOf: function lastIndexOf(searchElement /*, fromIndex = @[*-1] */) {
          // convert -0 to +0
          if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;
          var O = toIObject(this),
              length = toLength(O.length),
              index = length - 1;
          if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
          if (index < 0) index = length + index;
          for (; index >= 0; index--) {
            if (index in O) if (O[index] === searchElement) return index || 0;
          }return -1;
        }
      });
    }, { "./_export": 111, "./_strict-method": 175, "./_to-integer": 185, "./_to-iobject": 186, "./_to-length": 187 }], 212: [function (_dereq_, module, exports) {
      'use strict';

      var $export = _dereq_('./_export'),
          $map = _dereq_('./_array-methods')(1);

      $export($export.P + $export.F * !_dereq_('./_strict-method')([].map, true), 'Array', {
        // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
        map: function map(callbackfn /* , thisArg */) {
          return $map(this, callbackfn, arguments[1]);
        }
      });
    }, { "./_array-methods": 91, "./_export": 111, "./_strict-method": 175 }], 213: [function (_dereq_, module, exports) {
      'use strict';

      var $export = _dereq_('./_export'),
          createProperty = _dereq_('./_create-property');

      // WebKit Array.of isn't generic
      $export($export.S + $export.F * _dereq_('./_fails')(function () {
        function F() {}
        return !(Array.of.call(F) instanceof F);
      }), 'Array', {
        // 22.1.2.3 Array.of( ...items)
        of: function of() /* ...args */{
          var index = 0,
              aLen = arguments.length,
              result = new (typeof this == 'function' ? this : Array)(aLen);
          while (aLen > index) {
            createProperty(result, index, arguments[index++]);
          }result.length = aLen;
          return result;
        }
      });
    }, { "./_create-property": 103, "./_export": 111, "./_fails": 113 }], 214: [function (_dereq_, module, exports) {
      'use strict';

      var $export = _dereq_('./_export'),
          $reduce = _dereq_('./_array-reduce');

      $export($export.P + $export.F * !_dereq_('./_strict-method')([].reduceRight, true), 'Array', {
        // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
        reduceRight: function reduceRight(callbackfn /* , initialValue */) {
          return $reduce(this, callbackfn, arguments.length, arguments[1], true);
        }
      });
    }, { "./_array-reduce": 92, "./_export": 111, "./_strict-method": 175 }], 215: [function (_dereq_, module, exports) {
      'use strict';

      var $export = _dereq_('./_export'),
          $reduce = _dereq_('./_array-reduce');

      $export($export.P + $export.F * !_dereq_('./_strict-method')([].reduce, true), 'Array', {
        // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
        reduce: function reduce(callbackfn /* , initialValue */) {
          return $reduce(this, callbackfn, arguments.length, arguments[1], false);
        }
      });
    }, { "./_array-reduce": 92, "./_export": 111, "./_strict-method": 175 }], 216: [function (_dereq_, module, exports) {
      'use strict';

      var $export = _dereq_('./_export'),
          html = _dereq_('./_html'),
          cof = _dereq_('./_cof'),
          toIndex = _dereq_('./_to-index'),
          toLength = _dereq_('./_to-length'),
          arraySlice = [].slice;

      // fallback for not array-like ES3 strings and DOM objects
      $export($export.P + $export.F * _dereq_('./_fails')(function () {
        if (html) arraySlice.call(html);
      }), 'Array', {
        slice: function slice(begin, end) {
          var len = toLength(this.length),
              klass = cof(this);
          end = end === undefined ? len : end;
          if (klass == 'Array') return arraySlice.call(this, begin, end);
          var start = toIndex(begin, len),
              upTo = toIndex(end, len),
              size = toLength(upTo - start),
              cloned = Array(size),
              i = 0;
          for (; i < size; i++) {
            cloned[i] = klass == 'String' ? this.charAt(start + i) : this[start + i];
          }return cloned;
        }
      });
    }, { "./_cof": 97, "./_export": 111, "./_fails": 113, "./_html": 120, "./_to-index": 184, "./_to-length": 187 }], 217: [function (_dereq_, module, exports) {
      'use strict';

      var $export = _dereq_('./_export'),
          $some = _dereq_('./_array-methods')(3);

      $export($export.P + $export.F * !_dereq_('./_strict-method')([].some, true), 'Array', {
        // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
        some: function some(callbackfn /* , thisArg */) {
          return $some(this, callbackfn, arguments[1]);
        }
      });
    }, { "./_array-methods": 91, "./_export": 111, "./_strict-method": 175 }], 218: [function (_dereq_, module, exports) {
      'use strict';

      var $export = _dereq_('./_export'),
          aFunction = _dereq_('./_a-function'),
          toObject = _dereq_('./_to-object'),
          fails = _dereq_('./_fails'),
          $sort = [].sort,
          test = [1, 2, 3];

      $export($export.P + $export.F * (fails(function () {
        // IE8-
        test.sort(undefined);
      }) || !fails(function () {
        // V8 bug
        test.sort(null);
        // Old WebKit
      }) || !_dereq_('./_strict-method')($sort)), 'Array', {
        // 22.1.3.25 Array.prototype.sort(comparefn)
        sort: function sort(comparefn) {
          return comparefn === undefined ? $sort.call(toObject(this)) : $sort.call(toObject(this), aFunction(comparefn));
        }
      });
    }, { "./_a-function": 82, "./_export": 111, "./_fails": 113, "./_strict-method": 175, "./_to-object": 188 }], 219: [function (_dereq_, module, exports) {
      _dereq_('./_set-species')('Array');
    }, { "./_set-species": 170 }], 220: [function (_dereq_, module, exports) {
      // 20.3.3.1 / 15.9.4.4 Date.now()
      var $export = _dereq_('./_export');

      $export($export.S, 'Date', { now: function now() {
          return new Date().getTime();
        } });
    }, { "./_export": 111 }], 221: [function (_dereq_, module, exports) {
      'use strict';
      // 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()

      var $export = _dereq_('./_export'),
          fails = _dereq_('./_fails'),
          getTime = Date.prototype.getTime;

      var lz = function lz(num) {
        return num > 9 ? num : '0' + num;
      };

      // PhantomJS / old WebKit has a broken implementations
      $export($export.P + $export.F * (fails(function () {
        return new Date(-5e13 - 1).toISOString() != '0385-07-25T07:06:39.999Z';
      }) || !fails(function () {
        new Date(NaN).toISOString();
      })), 'Date', {
        toISOString: function toISOString() {
          if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
          var d = this,
              y = d.getUTCFullYear(),
              m = d.getUTCMilliseconds(),
              s = y < 0 ? '-' : y > 9999 ? '+' : '';
          return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) + '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) + 'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) + ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
        }
      });
    }, { "./_export": 111, "./_fails": 113 }], 222: [function (_dereq_, module, exports) {
      'use strict';

      var $export = _dereq_('./_export'),
          toObject = _dereq_('./_to-object'),
          toPrimitive = _dereq_('./_to-primitive');

      $export($export.P + $export.F * _dereq_('./_fails')(function () {
        return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({ toISOString: function toISOString() {
            return 1;
          } }) !== 1;
      }), 'Date', {
        toJSON: function toJSON(key) {
          var O = toObject(this),
              pv = toPrimitive(O);
          return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
        }
      });
    }, { "./_export": 111, "./_fails": 113, "./_to-object": 188, "./_to-primitive": 189 }], 223: [function (_dereq_, module, exports) {
      var TO_PRIMITIVE = _dereq_('./_wks')('toPrimitive'),
          proto = Date.prototype;

      if (!(TO_PRIMITIVE in proto)) _dereq_('./_hide')(proto, TO_PRIMITIVE, _dereq_('./_date-to-primitive'));
    }, { "./_date-to-primitive": 105, "./_hide": 119, "./_wks": 196 }], 224: [function (_dereq_, module, exports) {
      var DateProto = Date.prototype,
          INVALID_DATE = 'Invalid Date',
          TO_STRING = 'toString',
          $toString = DateProto[TO_STRING],
          getTime = DateProto.getTime;
      if (new Date(NaN) + '' != INVALID_DATE) {
        _dereq_('./_redefine')(DateProto, TO_STRING, function toString() {
          var value = getTime.call(this);
          return value === value ? $toString.call(this) : INVALID_DATE;
        });
      }
    }, { "./_redefine": 166 }], 225: [function (_dereq_, module, exports) {
      // 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
      var $export = _dereq_('./_export');

      $export($export.P, 'Function', { bind: _dereq_('./_bind') });
    }, { "./_bind": 95, "./_export": 111 }], 226: [function (_dereq_, module, exports) {
      'use strict';

      var isObject = _dereq_('./_is-object'),
          getPrototypeOf = _dereq_('./_object-gpo'),
          HAS_INSTANCE = _dereq_('./_wks')('hasInstance'),
          FunctionProto = Function.prototype;
      // 19.2.3.6 Function.prototype[@@hasInstance](V)
      if (!(HAS_INSTANCE in FunctionProto)) _dereq_('./_object-dp').f(FunctionProto, HAS_INSTANCE, { value: function value(O) {
          if (typeof this != 'function' || !isObject(O)) return false;
          if (!isObject(this.prototype)) return O instanceof this;
          // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
          while (O = getPrototypeOf(O)) {
            if (this.prototype === O) return true;
          }return false;
        } });
    }, { "./_is-object": 128, "./_object-dp": 146, "./_object-gpo": 153, "./_wks": 196 }], 227: [function (_dereq_, module, exports) {
      var dP = _dereq_('./_object-dp').f,
          createDesc = _dereq_('./_property-desc'),
          has = _dereq_('./_has'),
          FProto = Function.prototype,
          nameRE = /^\s*function ([^ (]*)/,
          NAME = 'name';

      var isExtensible = Object.isExtensible || function () {
        return true;
      };

      // 19.2.4.2 name
      NAME in FProto || _dereq_('./_descriptors') && dP(FProto, NAME, {
        configurable: true,
        get: function get() {
          try {
            var that = this,
                name = ('' + that).match(nameRE)[1];
            has(that, NAME) || !isExtensible(that) || dP(that, NAME, createDesc(5, name));
            return name;
          } catch (e) {
            return '';
          }
        }
      });
    }, { "./_descriptors": 107, "./_has": 118, "./_object-dp": 146, "./_property-desc": 164 }], 228: [function (_dereq_, module, exports) {
      'use strict';

      var strong = _dereq_('./_collection-strong');

      // 23.1 Map Objects
      module.exports = _dereq_('./_collection')('Map', function (get) {
        return function Map() {
          return get(this, arguments.length > 0 ? arguments[0] : undefined);
        };
      }, {
        // 23.1.3.6 Map.prototype.get(key)
        get: function get(key) {
          var entry = strong.getEntry(this, key);
          return entry && entry.v;
        },
        // 23.1.3.9 Map.prototype.set(key, value)
        set: function set(key, value) {
          return strong.def(this, key === 0 ? 0 : key, value);
        }
      }, strong, true);
    }, { "./_collection": 101, "./_collection-strong": 98 }], 229: [function (_dereq_, module, exports) {
      // 20.2.2.3 Math.acosh(x)
      var $export = _dereq_('./_export'),
          log1p = _dereq_('./_math-log1p'),
          sqrt = Math.sqrt,
          $acosh = Math.acosh;

      $export($export.S + $export.F * !($acosh
      // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
      && Math.floor($acosh(Number.MAX_VALUE)) == 710
      // Tor Browser bug: Math.acosh(Infinity) -> NaN 
      && $acosh(Infinity) == Infinity), 'Math', {
        acosh: function acosh(x) {
          return (x = +x) < 1 ? NaN : x > 94906265.62425156 ? Math.log(x) + Math.LN2 : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
        }
      });
    }, { "./_export": 111, "./_math-log1p": 139 }], 230: [function (_dereq_, module, exports) {
      // 20.2.2.5 Math.asinh(x)
      var $export = _dereq_('./_export'),
          $asinh = Math.asinh;

      function asinh(x) {
        return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
      }

      // Tor Browser bug: Math.asinh(0) -> -0 
      $export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh });
    }, { "./_export": 111 }], 231: [function (_dereq_, module, exports) {
      // 20.2.2.7 Math.atanh(x)
      var $export = _dereq_('./_export'),
          $atanh = Math.atanh;

      // Tor Browser bug: Math.atanh(-0) -> 0 
      $export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
        atanh: function atanh(x) {
          return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
        }
      });
    }, { "./_export": 111 }], 232: [function (_dereq_, module, exports) {
      // 20.2.2.9 Math.cbrt(x)
      var $export = _dereq_('./_export'),
          sign = _dereq_('./_math-sign');

      $export($export.S, 'Math', {
        cbrt: function cbrt(x) {
          return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
        }
      });
    }, { "./_export": 111, "./_math-sign": 140 }], 233: [function (_dereq_, module, exports) {
      // 20.2.2.11 Math.clz32(x)
      var $export = _dereq_('./_export');

      $export($export.S, 'Math', {
        clz32: function clz32(x) {
          return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
        }
      });
    }, { "./_export": 111 }], 234: [function (_dereq_, module, exports) {
      // 20.2.2.12 Math.cosh(x)
      var $export = _dereq_('./_export'),
          exp = Math.exp;

      $export($export.S, 'Math', {
        cosh: function cosh(x) {
          return (exp(x = +x) + exp(-x)) / 2;
        }
      });
    }, { "./_export": 111 }], 235: [function (_dereq_, module, exports) {
      // 20.2.2.14 Math.expm1(x)
      var $export = _dereq_('./_export'),
          $expm1 = _dereq_('./_math-expm1');

      $export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', { expm1: $expm1 });
    }, { "./_export": 111, "./_math-expm1": 138 }], 236: [function (_dereq_, module, exports) {
      // 20.2.2.16 Math.fround(x)
      var $export = _dereq_('./_export'),
          sign = _dereq_('./_math-sign'),
          pow = Math.pow,
          EPSILON = pow(2, -52),
          EPSILON32 = pow(2, -23),
          MAX32 = pow(2, 127) * (2 - EPSILON32),
          MIN32 = pow(2, -126);

      var roundTiesToEven = function roundTiesToEven(n) {
        return n + 1 / EPSILON - 1 / EPSILON;
      };

      $export($export.S, 'Math', {
        fround: function fround(x) {
          var $abs = Math.abs(x),
              $sign = sign(x),
              a,
              result;
          if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
          a = (1 + EPSILON32 / EPSILON) * $abs;
          result = a - (a - $abs);
          if (result > MAX32 || result != result) return $sign * Infinity;
          return $sign * result;
        }
      });
    }, { "./_export": 111, "./_math-sign": 140 }], 237: [function (_dereq_, module, exports) {
      // 20.2.2.17 Math.hypot([value1[, value2[, … ]]])
      var $export = _dereq_('./_export'),
          abs = Math.abs;

      $export($export.S, 'Math', {
        hypot: function hypot(value1, value2) {
          // eslint-disable-line no-unused-vars
          var sum = 0,
              i = 0,
              aLen = arguments.length,
              larg = 0,
              arg,
              div;
          while (i < aLen) {
            arg = abs(arguments[i++]);
            if (larg < arg) {
              div = larg / arg;
              sum = sum * div * div + 1;
              larg = arg;
            } else if (arg > 0) {
              div = arg / larg;
              sum += div * div;
            } else sum += arg;
          }
          return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
        }
      });
    }, { "./_export": 111 }], 238: [function (_dereq_, module, exports) {
      // 20.2.2.18 Math.imul(x, y)
      var $export = _dereq_('./_export'),
          $imul = Math.imul;

      // some WebKit versions fails with big numbers, some has wrong arity
      $export($export.S + $export.F * _dereq_('./_fails')(function () {
        return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
      }), 'Math', {
        imul: function imul(x, y) {
          var UINT16 = 0xffff,
              xn = +x,
              yn = +y,
              xl = UINT16 & xn,
              yl = UINT16 & yn;
          return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
        }
      });
    }, { "./_export": 111, "./_fails": 113 }], 239: [function (_dereq_, module, exports) {
      // 20.2.2.21 Math.log10(x)
      var $export = _dereq_('./_export');

      $export($export.S, 'Math', {
        log10: function log10(x) {
          return Math.log(x) / Math.LN10;
        }
      });
    }, { "./_export": 111 }], 240: [function (_dereq_, module, exports) {
      // 20.2.2.20 Math.log1p(x)
      var $export = _dereq_('./_export');

      $export($export.S, 'Math', { log1p: _dereq_('./_math-log1p') });
    }, { "./_export": 111, "./_math-log1p": 139 }], 241: [function (_dereq_, module, exports) {
      // 20.2.2.22 Math.log2(x)
      var $export = _dereq_('./_export');

      $export($export.S, 'Math', {
        log2: function log2(x) {
          return Math.log(x) / Math.LN2;
        }
      });
    }, { "./_export": 111 }], 242: [function (_dereq_, module, exports) {
      // 20.2.2.28 Math.sign(x)
      var $export = _dereq_('./_export');

      $export($export.S, 'Math', { sign: _dereq_('./_math-sign') });
    }, { "./_export": 111, "./_math-sign": 140 }], 243: [function (_dereq_, module, exports) {
      // 20.2.2.30 Math.sinh(x)
      var $export = _dereq_('./_export'),
          expm1 = _dereq_('./_math-expm1'),
          exp = Math.exp;

      // V8 near Chromium 38 has a problem with very small numbers
      $export($export.S + $export.F * _dereq_('./_fails')(function () {
        return !Math.sinh(-2e-17) != -2e-17;
      }), 'Math', {
        sinh: function sinh(x) {
          return Math.abs(x = +x) < 1 ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
        }
      });
    }, { "./_export": 111, "./_fails": 113, "./_math-expm1": 138 }], 244: [function (_dereq_, module, exports) {
      // 20.2.2.33 Math.tanh(x)
      var $export = _dereq_('./_export'),
          expm1 = _dereq_('./_math-expm1'),
          exp = Math.exp;

      $export($export.S, 'Math', {
        tanh: function tanh(x) {
          var a = expm1(x = +x),
              b = expm1(-x);
          return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
        }
      });
    }, { "./_export": 111, "./_math-expm1": 138 }], 245: [function (_dereq_, module, exports) {
      // 20.2.2.34 Math.trunc(x)
      var $export = _dereq_('./_export');

      $export($export.S, 'Math', {
        trunc: function trunc(it) {
          return (it > 0 ? Math.floor : Math.ceil)(it);
        }
      });
    }, { "./_export": 111 }], 246: [function (_dereq_, module, exports) {
      'use strict';

      var global = _dereq_('./_global'),
          has = _dereq_('./_has'),
          cof = _dereq_('./_cof'),
          inheritIfRequired = _dereq_('./_inherit-if-required'),
          toPrimitive = _dereq_('./_to-primitive'),
          fails = _dereq_('./_fails'),
          gOPN = _dereq_('./_object-gopn').f,
          gOPD = _dereq_('./_object-gopd').f,
          dP = _dereq_('./_object-dp').f,
          $trim = _dereq_('./_string-trim').trim,
          NUMBER = 'Number',
          $Number = global[NUMBER],
          Base = $Number,
          proto = $Number.prototype
      // Opera ~12 has broken Object#toString
      ,
          BROKEN_COF = cof(_dereq_('./_object-create')(proto)) == NUMBER,
          TRIM = 'trim' in String.prototype;

      // 7.1.3 ToNumber(argument)
      var toNumber = function toNumber(argument) {
        var it = toPrimitive(argument, false);
        if (typeof it == 'string' && it.length > 2) {
          it = TRIM ? it.trim() : $trim(it, 3);
          var first = it.charCodeAt(0),
              third,
              radix,
              maxCode;
          if (first === 43 || first === 45) {
            third = it.charCodeAt(2);
            if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
          } else if (first === 48) {
            switch (it.charCodeAt(1)) {
              case 66:case 98:
                radix = 2;maxCode = 49;break; // fast equal /^0b[01]+$/i
              case 79:case 111:
                radix = 8;maxCode = 55;break; // fast equal /^0o[0-7]+$/i
              default:
                return +it;
            }
            for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
              code = digits.charCodeAt(i);
              // parseInt parses a string to a first unavailable symbol
              // but ToNumber should return NaN if a string contains unavailable symbols
              if (code < 48 || code > maxCode) return NaN;
            }return parseInt(digits, radix);
          }
        }return +it;
      };

      if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
        $Number = function Number(value) {
          var it = arguments.length < 1 ? 0 : value,
              that = this;
          return that instanceof $Number
          // check on 1..constructor(foo) case
          && (BROKEN_COF ? fails(function () {
            proto.valueOf.call(that);
          }) : cof(that) != NUMBER) ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
        };
        for (var keys = _dereq_('./_descriptors') ? gOPN(Base) : (
        // ES3:
        'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
        // ES6 (in case, if modules with ES6 Number statics required before):
        'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' + 'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger').split(','), j = 0, key; keys.length > j; j++) {
          if (has(Base, key = keys[j]) && !has($Number, key)) {
            dP($Number, key, gOPD(Base, key));
          }
        }
        $Number.prototype = proto;
        proto.constructor = $Number;
        _dereq_('./_redefine')(global, NUMBER, $Number);
      }
    }, { "./_cof": 97, "./_descriptors": 107, "./_fails": 113, "./_global": 117, "./_has": 118, "./_inherit-if-required": 122, "./_object-create": 145, "./_object-dp": 146, "./_object-gopd": 149, "./_object-gopn": 151, "./_redefine": 166, "./_string-trim": 181, "./_to-primitive": 189 }], 247: [function (_dereq_, module, exports) {
      // 20.1.2.1 Number.EPSILON
      var $export = _dereq_('./_export');

      $export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });
    }, { "./_export": 111 }], 248: [function (_dereq_, module, exports) {
      // 20.1.2.2 Number.isFinite(number)
      var $export = _dereq_('./_export'),
          _isFinite = _dereq_('./_global').isFinite;

      $export($export.S, 'Number', {
        isFinite: function isFinite(it) {
          return typeof it == 'number' && _isFinite(it);
        }
      });
    }, { "./_export": 111, "./_global": 117 }], 249: [function (_dereq_, module, exports) {
      // 20.1.2.3 Number.isInteger(number)
      var $export = _dereq_('./_export');

      $export($export.S, 'Number', { isInteger: _dereq_('./_is-integer') });
    }, { "./_export": 111, "./_is-integer": 127 }], 250: [function (_dereq_, module, exports) {
      // 20.1.2.4 Number.isNaN(number)
      var $export = _dereq_('./_export');

      $export($export.S, 'Number', {
        isNaN: function isNaN(number) {
          return number != number;
        }
      });
    }, { "./_export": 111 }], 251: [function (_dereq_, module, exports) {
      // 20.1.2.5 Number.isSafeInteger(number)
      var $export = _dereq_('./_export'),
          isInteger = _dereq_('./_is-integer'),
          abs = Math.abs;

      $export($export.S, 'Number', {
        isSafeInteger: function isSafeInteger(number) {
          return isInteger(number) && abs(number) <= 0x1fffffffffffff;
        }
      });
    }, { "./_export": 111, "./_is-integer": 127 }], 252: [function (_dereq_, module, exports) {
      // 20.1.2.6 Number.MAX_SAFE_INTEGER
      var $export = _dereq_('./_export');

      $export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });
    }, { "./_export": 111 }], 253: [function (_dereq_, module, exports) {
      // 20.1.2.10 Number.MIN_SAFE_INTEGER
      var $export = _dereq_('./_export');

      $export($export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });
    }, { "./_export": 111 }], 254: [function (_dereq_, module, exports) {
      var $export = _dereq_('./_export'),
          $parseFloat = _dereq_('./_parse-float');
      // 20.1.2.12 Number.parseFloat(string)
      $export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', { parseFloat: $parseFloat });
    }, { "./_export": 111, "./_parse-float": 160 }], 255: [function (_dereq_, module, exports) {
      var $export = _dereq_('./_export'),
          $parseInt = _dereq_('./_parse-int');
      // 20.1.2.13 Number.parseInt(string, radix)
      $export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', { parseInt: $parseInt });
    }, { "./_export": 111, "./_parse-int": 161 }], 256: [function (_dereq_, module, exports) {
      'use strict';

      var $export = _dereq_('./_export'),
          toInteger = _dereq_('./_to-integer'),
          aNumberValue = _dereq_('./_a-number-value'),
          repeat = _dereq_('./_string-repeat'),
          $toFixed = 1..toFixed,
          floor = Math.floor,
          data = [0, 0, 0, 0, 0, 0],
          ERROR = 'Number.toFixed: incorrect invocation!',
          ZERO = '0';

      var multiply = function multiply(n, c) {
        var i = -1,
            c2 = c;
        while (++i < 6) {
          c2 += n * data[i];
          data[i] = c2 % 1e7;
          c2 = floor(c2 / 1e7);
        }
      };
      var divide = function divide(n) {
        var i = 6,
            c = 0;
        while (--i >= 0) {
          c += data[i];
          data[i] = floor(c / n);
          c = c % n * 1e7;
        }
      };
      var numToString = function numToString() {
        var i = 6,
            s = '';
        while (--i >= 0) {
          if (s !== '' || i === 0 || data[i] !== 0) {
            var t = String(data[i]);
            s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
          }
        }return s;
      };
      var pow = function pow(x, n, acc) {
        return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
      };
      var log = function log(x) {
        var n = 0,
            x2 = x;
        while (x2 >= 4096) {
          n += 12;
          x2 /= 4096;
        }
        while (x2 >= 2) {
          n += 1;
          x2 /= 2;
        }return n;
      };

      $export($export.P + $export.F * (!!$toFixed && (0.00008.toFixed(3) !== '0.000' || 0.9.toFixed(0) !== '1' || 1.255.toFixed(2) !== '1.25' || 1000000000000000128..toFixed(0) !== '1000000000000000128') || !_dereq_('./_fails')(function () {
        // V8 ~ Android 4.3-
        $toFixed.call({});
      })), 'Number', {
        toFixed: function toFixed(fractionDigits) {
          var x = aNumberValue(this, ERROR),
              f = toInteger(fractionDigits),
              s = '',
              m = ZERO,
              e,
              z,
              j,
              k;
          if (f < 0 || f > 20) throw RangeError(ERROR);
          if (x != x) return 'NaN';
          if (x <= -1e21 || x >= 1e21) return String(x);
          if (x < 0) {
            s = '-';
            x = -x;
          }
          if (x > 1e-21) {
            e = log(x * pow(2, 69, 1)) - 69;
            z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
            z *= 0x10000000000000;
            e = 52 - e;
            if (e > 0) {
              multiply(0, z);
              j = f;
              while (j >= 7) {
                multiply(1e7, 0);
                j -= 7;
              }
              multiply(pow(10, j, 1), 0);
              j = e - 1;
              while (j >= 23) {
                divide(1 << 23);
                j -= 23;
              }
              divide(1 << j);
              multiply(1, 1);
              divide(2);
              m = numToString();
            } else {
              multiply(0, z);
              multiply(1 << -e, 0);
              m = numToString() + repeat.call(ZERO, f);
            }
          }
          if (f > 0) {
            k = m.length;
            m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
          } else {
            m = s + m;
          }return m;
        }
      });
    }, { "./_a-number-value": 83, "./_export": 111, "./_fails": 113, "./_string-repeat": 180, "./_to-integer": 185 }], 257: [function (_dereq_, module, exports) {
      'use strict';

      var $export = _dereq_('./_export'),
          $fails = _dereq_('./_fails'),
          aNumberValue = _dereq_('./_a-number-value'),
          $toPrecision = 1..toPrecision;

      $export($export.P + $export.F * ($fails(function () {
        // IE7-
        return $toPrecision.call(1, undefined) !== '1';
      }) || !$fails(function () {
        // V8 ~ Android 4.3-
        $toPrecision.call({});
      })), 'Number', {
        toPrecision: function toPrecision(precision) {
          var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
          return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
        }
      });
    }, { "./_a-number-value": 83, "./_export": 111, "./_fails": 113 }], 258: [function (_dereq_, module, exports) {
      // 19.1.3.1 Object.assign(target, source)
      var $export = _dereq_('./_export');

      $export($export.S + $export.F, 'Object', { assign: _dereq_('./_object-assign') });
    }, { "./_export": 111, "./_object-assign": 144 }], 259: [function (_dereq_, module, exports) {
      var $export = _dereq_('./_export');
      // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
      $export($export.S, 'Object', { create: _dereq_('./_object-create') });
    }, { "./_export": 111, "./_object-create": 145 }], 260: [function (_dereq_, module, exports) {
      var $export = _dereq_('./_export');
      // 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
      $export($export.S + $export.F * !_dereq_('./_descriptors'), 'Object', { defineProperties: _dereq_('./_object-dps') });
    }, { "./_descriptors": 107, "./_export": 111, "./_object-dps": 147 }], 261: [function (_dereq_, module, exports) {
      var $export = _dereq_('./_export');
      // 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
      $export($export.S + $export.F * !_dereq_('./_descriptors'), 'Object', { defineProperty: _dereq_('./_object-dp').f });
    }, { "./_descriptors": 107, "./_export": 111, "./_object-dp": 146 }], 262: [function (_dereq_, module, exports) {
      // 19.1.2.5 Object.freeze(O)
      var isObject = _dereq_('./_is-object'),
          meta = _dereq_('./_meta').onFreeze;

      _dereq_('./_object-sap')('freeze', function ($freeze) {
        return function freeze(it) {
          return $freeze && isObject(it) ? $freeze(meta(it)) : it;
        };
      });
    }, { "./_is-object": 128, "./_meta": 141, "./_object-sap": 157 }], 263: [function (_dereq_, module, exports) {
      // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
      var toIObject = _dereq_('./_to-iobject'),
          $getOwnPropertyDescriptor = _dereq_('./_object-gopd').f;

      _dereq_('./_object-sap')('getOwnPropertyDescriptor', function () {
        return function getOwnPropertyDescriptor(it, key) {
          return $getOwnPropertyDescriptor(toIObject(it), key);
        };
      });
    }, { "./_object-gopd": 149, "./_object-sap": 157, "./_to-iobject": 186 }], 264: [function (_dereq_, module, exports) {
      // 19.1.2.7 Object.getOwnPropertyNames(O)
      _dereq_('./_object-sap')('getOwnPropertyNames', function () {
        return _dereq_('./_object-gopn-ext').f;
      });
    }, { "./_object-gopn-ext": 150, "./_object-sap": 157 }], 265: [function (_dereq_, module, exports) {
      // 19.1.2.9 Object.getPrototypeOf(O)
      var toObject = _dereq_('./_to-object'),
          $getPrototypeOf = _dereq_('./_object-gpo');

      _dereq_('./_object-sap')('getPrototypeOf', function () {
        return function getPrototypeOf(it) {
          return $getPrototypeOf(toObject(it));
        };
      });
    }, { "./_object-gpo": 153, "./_object-sap": 157, "./_to-object": 188 }], 266: [function (_dereq_, module, exports) {
      // 19.1.2.11 Object.isExtensible(O)
      var isObject = _dereq_('./_is-object');

      _dereq_('./_object-sap')('isExtensible', function ($isExtensible) {
        return function isExtensible(it) {
          return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
        };
      });
    }, { "./_is-object": 128, "./_object-sap": 157 }], 267: [function (_dereq_, module, exports) {
      // 19.1.2.12 Object.isFrozen(O)
      var isObject = _dereq_('./_is-object');

      _dereq_('./_object-sap')('isFrozen', function ($isFrozen) {
        return function isFrozen(it) {
          return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
        };
      });
    }, { "./_is-object": 128, "./_object-sap": 157 }], 268: [function (_dereq_, module, exports) {
      // 19.1.2.13 Object.isSealed(O)
      var isObject = _dereq_('./_is-object');

      _dereq_('./_object-sap')('isSealed', function ($isSealed) {
        return function isSealed(it) {
          return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
        };
      });
    }, { "./_is-object": 128, "./_object-sap": 157 }], 269: [function (_dereq_, module, exports) {
      // 19.1.3.10 Object.is(value1, value2)
      var $export = _dereq_('./_export');
      $export($export.S, 'Object', { is: _dereq_('./_same-value') });
    }, { "./_export": 111, "./_same-value": 168 }], 270: [function (_dereq_, module, exports) {
      // 19.1.2.14 Object.keys(O)
      var toObject = _dereq_('./_to-object'),
          $keys = _dereq_('./_object-keys');

      _dereq_('./_object-sap')('keys', function () {
        return function keys(it) {
          return $keys(toObject(it));
        };
      });
    }, { "./_object-keys": 155, "./_object-sap": 157, "./_to-object": 188 }], 271: [function (_dereq_, module, exports) {
      // 19.1.2.15 Object.preventExtensions(O)
      var isObject = _dereq_('./_is-object'),
          meta = _dereq_('./_meta').onFreeze;

      _dereq_('./_object-sap')('preventExtensions', function ($preventExtensions) {
        return function preventExtensions(it) {
          return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
        };
      });
    }, { "./_is-object": 128, "./_meta": 141, "./_object-sap": 157 }], 272: [function (_dereq_, module, exports) {
      // 19.1.2.17 Object.seal(O)
      var isObject = _dereq_('./_is-object'),
          meta = _dereq_('./_meta').onFreeze;

      _dereq_('./_object-sap')('seal', function ($seal) {
        return function seal(it) {
          return $seal && isObject(it) ? $seal(meta(it)) : it;
        };
      });
    }, { "./_is-object": 128, "./_meta": 141, "./_object-sap": 157 }], 273: [function (_dereq_, module, exports) {
      // 19.1.3.19 Object.setPrototypeOf(O, proto)
      var $export = _dereq_('./_export');
      $export($export.S, 'Object', { setPrototypeOf: _dereq_('./_set-proto').set });
    }, { "./_export": 111, "./_set-proto": 169 }], 274: [function (_dereq_, module, exports) {
      'use strict';
      // 19.1.3.6 Object.prototype.toString()

      var classof = _dereq_('./_classof'),
          test = {};
      test[_dereq_('./_wks')('toStringTag')] = 'z';
      if (test + '' != '[object z]') {
        _dereq_('./_redefine')(Object.prototype, 'toString', function toString() {
          return '[object ' + classof(this) + ']';
        }, true);
      }
    }, { "./_classof": 96, "./_redefine": 166, "./_wks": 196 }], 275: [function (_dereq_, module, exports) {
      var $export = _dereq_('./_export'),
          $parseFloat = _dereq_('./_parse-float');
      // 18.2.4 parseFloat(string)
      $export($export.G + $export.F * (parseFloat != $parseFloat), { parseFloat: $parseFloat });
    }, { "./_export": 111, "./_parse-float": 160 }], 276: [function (_dereq_, module, exports) {
      var $export = _dereq_('./_export'),
          $parseInt = _dereq_('./_parse-int');
      // 18.2.5 parseInt(string, radix)
      $export($export.G + $export.F * (parseInt != $parseInt), { parseInt: $parseInt });
    }, { "./_export": 111, "./_parse-int": 161 }], 277: [function (_dereq_, module, exports) {
      'use strict';

      var LIBRARY = _dereq_('./_library'),
          global = _dereq_('./_global'),
          ctx = _dereq_('./_ctx'),
          classof = _dereq_('./_classof'),
          $export = _dereq_('./_export'),
          isObject = _dereq_('./_is-object'),
          aFunction = _dereq_('./_a-function'),
          anInstance = _dereq_('./_an-instance'),
          forOf = _dereq_('./_for-of'),
          speciesConstructor = _dereq_('./_species-constructor'),
          task = _dereq_('./_task').set,
          microtask = _dereq_('./_microtask')(),
          PROMISE = 'Promise',
          TypeError = global.TypeError,
          process = global.process,
          $Promise = global[PROMISE],
          process = global.process,
          isNode = classof(process) == 'process',
          empty = function empty() {/* empty */},
          Internal,
          GenericPromiseCapability,
          Wrapper;

      var USE_NATIVE = !!function () {
        try {
          // correct subclassing with @@species support
          var promise = $Promise.resolve(1),
              FakePromise = (promise.constructor = {})[_dereq_('./_wks')('species')] = function (exec) {
            exec(empty, empty);
          };
          // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
          return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
        } catch (e) {/* empty */}
      }();

      // helpers
      var sameConstructor = function sameConstructor(a, b) {
        // with library wrapper special case
        return a === b || a === $Promise && b === Wrapper;
      };
      var isThenable = function isThenable(it) {
        var then;
        return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
      };
      var newPromiseCapability = function newPromiseCapability(C) {
        return sameConstructor($Promise, C) ? new PromiseCapability(C) : new GenericPromiseCapability(C);
      };
      var PromiseCapability = GenericPromiseCapability = function GenericPromiseCapability(C) {
        var resolve, reject;
        this.promise = new C(function ($$resolve, $$reject) {
          if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
          resolve = $$resolve;
          reject = $$reject;
        });
        this.resolve = aFunction(resolve);
        this.reject = aFunction(reject);
      };
      var perform = function perform(exec) {
        try {
          exec();
        } catch (e) {
          return { error: e };
        }
      };
      var notify = function notify(promise, isReject) {
        if (promise._n) return;
        promise._n = true;
        var chain = promise._c;
        microtask(function () {
          var value = promise._v,
              ok = promise._s == 1,
              i = 0;
          var run = function run(reaction) {
            var handler = ok ? reaction.ok : reaction.fail,
                resolve = reaction.resolve,
                reject = reaction.reject,
                domain = reaction.domain,
                result,
                then;
            try {
              if (handler) {
                if (!ok) {
                  if (promise._h == 2) onHandleUnhandled(promise);
                  promise._h = 1;
                }
                if (handler === true) result = value;else {
                  if (domain) domain.enter();
                  result = handler(value);
                  if (domain) domain.exit();
                }
                if (result === reaction.promise) {
                  reject(TypeError('Promise-chain cycle'));
                } else if (then = isThenable(result)) {
                  then.call(result, resolve, reject);
                } else resolve(result);
              } else reject(value);
            } catch (e) {
              reject(e);
            }
          };
          while (chain.length > i) {
            run(chain[i++]);
          } // variable length - can't use forEach
          promise._c = [];
          promise._n = false;
          if (isReject && !promise._h) onUnhandled(promise);
        });
      };
      var onUnhandled = function onUnhandled(promise) {
        task.call(global, function () {
          var value = promise._v,
              abrupt,
              handler,
              console;
          if (isUnhandled(promise)) {
            abrupt = perform(function () {
              if (isNode) {
                process.emit('unhandledRejection', value, promise);
              } else if (handler = global.onunhandledrejection) {
                handler({ promise: promise, reason: value });
              } else if ((console = global.console) && console.error) {
                console.error('Unhandled promise rejection', value);
              }
            });
            // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
            promise._h = isNode || isUnhandled(promise) ? 2 : 1;
          }promise._a = undefined;
          if (abrupt) throw abrupt.error;
        });
      };
      var isUnhandled = function isUnhandled(promise) {
        if (promise._h == 1) return false;
        var chain = promise._a || promise._c,
            i = 0,
            reaction;
        while (chain.length > i) {
          reaction = chain[i++];
          if (reaction.fail || !isUnhandled(reaction.promise)) return false;
        }return true;
      };
      var onHandleUnhandled = function onHandleUnhandled(promise) {
        task.call(global, function () {
          var handler;
          if (isNode) {
            process.emit('rejectionHandled', promise);
          } else if (handler = global.onrejectionhandled) {
            handler({ promise: promise, reason: promise._v });
          }
        });
      };
      var $reject = function $reject(value) {
        var promise = this;
        if (promise._d) return;
        promise._d = true;
        promise = promise._w || promise; // unwrap
        promise._v = value;
        promise._s = 2;
        if (!promise._a) promise._a = promise._c.slice();
        notify(promise, true);
      };
      var $resolve = function $resolve(value) {
        var promise = this,
            then;
        if (promise._d) return;
        promise._d = true;
        promise = promise._w || promise; // unwrap
        try {
          if (promise === value) throw TypeError("Promise can't be resolved itself");
          if (then = isThenable(value)) {
            microtask(function () {
              var wrapper = { _w: promise, _d: false }; // wrap
              try {
                then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
              } catch (e) {
                $reject.call(wrapper, e);
              }
            });
          } else {
            promise._v = value;
            promise._s = 1;
            notify(promise, false);
          }
        } catch (e) {
          $reject.call({ _w: promise, _d: false }, e); // wrap
        }
      };

      // constructor polyfill
      if (!USE_NATIVE) {
        // 25.4.3.1 Promise(executor)
        $Promise = function Promise(executor) {
          anInstance(this, $Promise, PROMISE, '_h');
          aFunction(executor);
          Internal.call(this);
          try {
            executor(ctx($resolve, this, 1), ctx($reject, this, 1));
          } catch (err) {
            $reject.call(this, err);
          }
        };
        Internal = function Promise(executor) {
          this._c = []; // <- awaiting reactions
          this._a = undefined; // <- checked in isUnhandled reactions
          this._s = 0; // <- state
          this._d = false; // <- done
          this._v = undefined; // <- value
          this._h = 0; // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
          this._n = false; // <- notify
        };
        Internal.prototype = _dereq_('./_redefine-all')($Promise.prototype, {
          // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
          then: function then(onFulfilled, onRejected) {
            var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
            reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
            reaction.fail = typeof onRejected == 'function' && onRejected;
            reaction.domain = isNode ? process.domain : undefined;
            this._c.push(reaction);
            if (this._a) this._a.push(reaction);
            if (this._s) notify(this, false);
            return reaction.promise;
          },
          // 25.4.5.1 Promise.prototype.catch(onRejected)
          'catch': function _catch(onRejected) {
            return this.then(undefined, onRejected);
          }
        });
        PromiseCapability = function PromiseCapability() {
          var promise = new Internal();
          this.promise = promise;
          this.resolve = ctx($resolve, promise, 1);
          this.reject = ctx($reject, promise, 1);
        };
      }

      $export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
      _dereq_('./_set-to-string-tag')($Promise, PROMISE);
      _dereq_('./_set-species')(PROMISE);
      Wrapper = _dereq_('./_core')[PROMISE];

      // statics
      $export($export.S + $export.F * !USE_NATIVE, PROMISE, {
        // 25.4.4.5 Promise.reject(r)
        reject: function reject(r) {
          var capability = newPromiseCapability(this),
              $$reject = capability.reject;
          $$reject(r);
          return capability.promise;
        }
      });
      $export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
        // 25.4.4.6 Promise.resolve(x)
        resolve: function resolve(x) {
          // instanceof instead of internal slot check because we should fix it without replacement native Promise core
          if (x instanceof $Promise && sameConstructor(x.constructor, this)) return x;
          var capability = newPromiseCapability(this),
              $$resolve = capability.resolve;
          $$resolve(x);
          return capability.promise;
        }
      });
      $export($export.S + $export.F * !(USE_NATIVE && _dereq_('./_iter-detect')(function (iter) {
        $Promise.all(iter)['catch'](empty);
      })), PROMISE, {
        // 25.4.4.1 Promise.all(iterable)
        all: function all(iterable) {
          var C = this,
              capability = newPromiseCapability(C),
              resolve = capability.resolve,
              reject = capability.reject;
          var abrupt = perform(function () {
            var values = [],
                index = 0,
                remaining = 1;
            forOf(iterable, false, function (promise) {
              var $index = index++,
                  alreadyCalled = false;
              values.push(undefined);
              remaining++;
              C.resolve(promise).then(function (value) {
                if (alreadyCalled) return;
                alreadyCalled = true;
                values[$index] = value;
                --remaining || resolve(values);
              }, reject);
            });
            --remaining || resolve(values);
          });
          if (abrupt) reject(abrupt.error);
          return capability.promise;
        },
        // 25.4.4.4 Promise.race(iterable)
        race: function race(iterable) {
          var C = this,
              capability = newPromiseCapability(C),
              reject = capability.reject;
          var abrupt = perform(function () {
            forOf(iterable, false, function (promise) {
              C.resolve(promise).then(capability.resolve, reject);
            });
          });
          if (abrupt) reject(abrupt.error);
          return capability.promise;
        }
      });
    }, { "./_a-function": 82, "./_an-instance": 85, "./_classof": 96, "./_core": 102, "./_ctx": 104, "./_export": 111, "./_for-of": 116, "./_global": 117, "./_is-object": 128, "./_iter-detect": 133, "./_library": 137, "./_microtask": 143, "./_redefine-all": 165, "./_set-species": 170, "./_set-to-string-tag": 171, "./_species-constructor": 174, "./_task": 183, "./_wks": 196 }], 278: [function (_dereq_, module, exports) {
      // 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
      var $export = _dereq_('./_export'),
          aFunction = _dereq_('./_a-function'),
          anObject = _dereq_('./_an-object'),
          rApply = (_dereq_('./_global').Reflect || {}).apply,
          fApply = Function.apply;
      // MS Edge argumentsList argument is optional
      $export($export.S + $export.F * !_dereq_('./_fails')(function () {
        rApply(function () {});
      }), 'Reflect', {
        apply: function apply(target, thisArgument, argumentsList) {
          var T = aFunction(target),
              L = anObject(argumentsList);
          return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
        }
      });
    }, { "./_a-function": 82, "./_an-object": 86, "./_export": 111, "./_fails": 113, "./_global": 117 }], 279: [function (_dereq_, module, exports) {
      // 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
      var $export = _dereq_('./_export'),
          create = _dereq_('./_object-create'),
          aFunction = _dereq_('./_a-function'),
          anObject = _dereq_('./_an-object'),
          isObject = _dereq_('./_is-object'),
          fails = _dereq_('./_fails'),
          bind = _dereq_('./_bind'),
          rConstruct = (_dereq_('./_global').Reflect || {}).construct;

      // MS Edge supports only 2 arguments and argumentsList argument is optional
      // FF Nightly sets third argument as `new.target`, but does not create `this` from it
      var NEW_TARGET_BUG = fails(function () {
        function F() {}
        return !(rConstruct(function () {}, [], F) instanceof F);
      });
      var ARGS_BUG = !fails(function () {
        rConstruct(function () {});
      });

      $export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
        construct: function construct(Target, args /*, newTarget*/) {
          aFunction(Target);
          anObject(args);
          var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
          if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
          if (Target == newTarget) {
            // w/o altered newTarget, optimization for 0-4 arguments
            switch (args.length) {
              case 0:
                return new Target();
              case 1:
                return new Target(args[0]);
              case 2:
                return new Target(args[0], args[1]);
              case 3:
                return new Target(args[0], args[1], args[2]);
              case 4:
                return new Target(args[0], args[1], args[2], args[3]);
            }
            // w/o altered newTarget, lot of arguments case
            var $args = [null];
            $args.push.apply($args, args);
            return new (bind.apply(Target, $args))();
          }
          // with altered newTarget, not support built-in constructors
          var proto = newTarget.prototype,
              instance = create(isObject(proto) ? proto : Object.prototype),
              result = Function.apply.call(Target, instance, args);
          return isObject(result) ? result : instance;
        }
      });
    }, { "./_a-function": 82, "./_an-object": 86, "./_bind": 95, "./_export": 111, "./_fails": 113, "./_global": 117, "./_is-object": 128, "./_object-create": 145 }], 280: [function (_dereq_, module, exports) {
      // 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
      var dP = _dereq_('./_object-dp'),
          $export = _dereq_('./_export'),
          anObject = _dereq_('./_an-object'),
          toPrimitive = _dereq_('./_to-primitive');

      // MS Edge has broken Reflect.defineProperty - throwing instead of returning false
      $export($export.S + $export.F * _dereq_('./_fails')(function () {
        Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 });
      }), 'Reflect', {
        defineProperty: function defineProperty(target, propertyKey, attributes) {
          anObject(target);
          propertyKey = toPrimitive(propertyKey, true);
          anObject(attributes);
          try {
            dP.f(target, propertyKey, attributes);
            return true;
          } catch (e) {
            return false;
          }
        }
      });
    }, { "./_an-object": 86, "./_export": 111, "./_fails": 113, "./_object-dp": 146, "./_to-primitive": 189 }], 281: [function (_dereq_, module, exports) {
      // 26.1.4 Reflect.deleteProperty(target, propertyKey)
      var $export = _dereq_('./_export'),
          gOPD = _dereq_('./_object-gopd').f,
          anObject = _dereq_('./_an-object');

      $export($export.S, 'Reflect', {
        deleteProperty: function deleteProperty(target, propertyKey) {
          var desc = gOPD(anObject(target), propertyKey);
          return desc && !desc.configurable ? false : delete target[propertyKey];
        }
      });
    }, { "./_an-object": 86, "./_export": 111, "./_object-gopd": 149 }], 282: [function (_dereq_, module, exports) {
      'use strict';
      // 26.1.5 Reflect.enumerate(target)

      var $export = _dereq_('./_export'),
          anObject = _dereq_('./_an-object');
      var Enumerate = function Enumerate(iterated) {
        this._t = anObject(iterated); // target
        this._i = 0; // next index
        var keys = this._k = [] // keys
        ,
            key;
        for (key in iterated) {
          keys.push(key);
        }
      };
      _dereq_('./_iter-create')(Enumerate, 'Object', function () {
        var that = this,
            keys = that._k,
            key;
        do {
          if (that._i >= keys.length) return { value: undefined, done: true };
        } while (!((key = keys[that._i++]) in that._t));
        return { value: key, done: false };
      });

      $export($export.S, 'Reflect', {
        enumerate: function enumerate(target) {
          return new Enumerate(target);
        }
      });
    }, { "./_an-object": 86, "./_export": 111, "./_iter-create": 131 }], 283: [function (_dereq_, module, exports) {
      // 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
      var gOPD = _dereq_('./_object-gopd'),
          $export = _dereq_('./_export'),
          anObject = _dereq_('./_an-object');

      $export($export.S, 'Reflect', {
        getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
          return gOPD.f(anObject(target), propertyKey);
        }
      });
    }, { "./_an-object": 86, "./_export": 111, "./_object-gopd": 149 }], 284: [function (_dereq_, module, exports) {
      // 26.1.8 Reflect.getPrototypeOf(target)
      var $export = _dereq_('./_export'),
          getProto = _dereq_('./_object-gpo'),
          anObject = _dereq_('./_an-object');

      $export($export.S, 'Reflect', {
        getPrototypeOf: function getPrototypeOf(target) {
          return getProto(anObject(target));
        }
      });
    }, { "./_an-object": 86, "./_export": 111, "./_object-gpo": 153 }], 285: [function (_dereq_, module, exports) {
      // 26.1.6 Reflect.get(target, propertyKey [, receiver])
      var gOPD = _dereq_('./_object-gopd'),
          getPrototypeOf = _dereq_('./_object-gpo'),
          has = _dereq_('./_has'),
          $export = _dereq_('./_export'),
          isObject = _dereq_('./_is-object'),
          anObject = _dereq_('./_an-object');

      function get(target, propertyKey /*, receiver*/) {
        var receiver = arguments.length < 3 ? target : arguments[2],
            desc,
            proto;
        if (anObject(target) === receiver) return target[propertyKey];
        if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value') ? desc.value : desc.get !== undefined ? desc.get.call(receiver) : undefined;
        if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
      }

      $export($export.S, 'Reflect', { get: get });
    }, { "./_an-object": 86, "./_export": 111, "./_has": 118, "./_is-object": 128, "./_object-gopd": 149, "./_object-gpo": 153 }], 286: [function (_dereq_, module, exports) {
      // 26.1.9 Reflect.has(target, propertyKey)
      var $export = _dereq_('./_export');

      $export($export.S, 'Reflect', {
        has: function has(target, propertyKey) {
          return propertyKey in target;
        }
      });
    }, { "./_export": 111 }], 287: [function (_dereq_, module, exports) {
      // 26.1.10 Reflect.isExtensible(target)
      var $export = _dereq_('./_export'),
          anObject = _dereq_('./_an-object'),
          $isExtensible = Object.isExtensible;

      $export($export.S, 'Reflect', {
        isExtensible: function isExtensible(target) {
          anObject(target);
          return $isExtensible ? $isExtensible(target) : true;
        }
      });
    }, { "./_an-object": 86, "./_export": 111 }], 288: [function (_dereq_, module, exports) {
      // 26.1.11 Reflect.ownKeys(target)
      var $export = _dereq_('./_export');

      $export($export.S, 'Reflect', { ownKeys: _dereq_('./_own-keys') });
    }, { "./_export": 111, "./_own-keys": 159 }], 289: [function (_dereq_, module, exports) {
      // 26.1.12 Reflect.preventExtensions(target)
      var $export = _dereq_('./_export'),
          anObject = _dereq_('./_an-object'),
          $preventExtensions = Object.preventExtensions;

      $export($export.S, 'Reflect', {
        preventExtensions: function preventExtensions(target) {
          anObject(target);
          try {
            if ($preventExtensions) $preventExtensions(target);
            return true;
          } catch (e) {
            return false;
          }
        }
      });
    }, { "./_an-object": 86, "./_export": 111 }], 290: [function (_dereq_, module, exports) {
      // 26.1.14 Reflect.setPrototypeOf(target, proto)
      var $export = _dereq_('./_export'),
          setProto = _dereq_('./_set-proto');

      if (setProto) $export($export.S, 'Reflect', {
        setPrototypeOf: function setPrototypeOf(target, proto) {
          setProto.check(target, proto);
          try {
            setProto.set(target, proto);
            return true;
          } catch (e) {
            return false;
          }
        }
      });
    }, { "./_export": 111, "./_set-proto": 169 }], 291: [function (_dereq_, module, exports) {
      // 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
      var dP = _dereq_('./_object-dp'),
          gOPD = _dereq_('./_object-gopd'),
          getPrototypeOf = _dereq_('./_object-gpo'),
          has = _dereq_('./_has'),
          $export = _dereq_('./_export'),
          createDesc = _dereq_('./_property-desc'),
          anObject = _dereq_('./_an-object'),
          isObject = _dereq_('./_is-object');

      function set(target, propertyKey, V /*, receiver*/) {
        var receiver = arguments.length < 4 ? target : arguments[3],
            ownDesc = gOPD.f(anObject(target), propertyKey),
            existingDescriptor,
            proto;
        if (!ownDesc) {
          if (isObject(proto = getPrototypeOf(target))) {
            return set(proto, propertyKey, V, receiver);
          }
          ownDesc = createDesc(0);
        }
        if (has(ownDesc, 'value')) {
          if (ownDesc.writable === false || !isObject(receiver)) return false;
          existingDescriptor = gOPD.f(receiver, propertyKey) || createDesc(0);
          existingDescriptor.value = V;
          dP.f(receiver, propertyKey, existingDescriptor);
          return true;
        }
        return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
      }

      $export($export.S, 'Reflect', { set: set });
    }, { "./_an-object": 86, "./_export": 111, "./_has": 118, "./_is-object": 128, "./_object-dp": 146, "./_object-gopd": 149, "./_object-gpo": 153, "./_property-desc": 164 }], 292: [function (_dereq_, module, exports) {
      var global = _dereq_('./_global'),
          inheritIfRequired = _dereq_('./_inherit-if-required'),
          dP = _dereq_('./_object-dp').f,
          gOPN = _dereq_('./_object-gopn').f,
          isRegExp = _dereq_('./_is-regexp'),
          $flags = _dereq_('./_flags'),
          $RegExp = global.RegExp,
          Base = $RegExp,
          proto = $RegExp.prototype,
          re1 = /a/g,
          re2 = /a/g
      // "new" creates a new object, old webkit buggy here
      ,
          CORRECT_NEW = new $RegExp(re1) !== re1;

      if (_dereq_('./_descriptors') && (!CORRECT_NEW || _dereq_('./_fails')(function () {
        re2[_dereq_('./_wks')('match')] = false;
        // RegExp constructor can alter flags and IsRegExp works correct with @@match
        return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
      }))) {
        $RegExp = function RegExp(p, f) {
          var tiRE = this instanceof $RegExp,
              piRE = isRegExp(p),
              fiU = f === undefined;
          return !tiRE && piRE && p.constructor === $RegExp && fiU ? p : inheritIfRequired(CORRECT_NEW ? new Base(piRE && !fiU ? p.source : p, f) : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f), tiRE ? this : proto, $RegExp);
        };
        var proxy = function proxy(key) {
          key in $RegExp || dP($RegExp, key, {
            configurable: true,
            get: function get() {
              return Base[key];
            },
            set: function set(it) {
              Base[key] = it;
            }
          });
        };
        for (var keys = gOPN(Base), i = 0; keys.length > i;) {
          proxy(keys[i++]);
        }proto.constructor = $RegExp;
        $RegExp.prototype = proto;
        _dereq_('./_redefine')(global, 'RegExp', $RegExp);
      }

      _dereq_('./_set-species')('RegExp');
    }, { "./_descriptors": 107, "./_fails": 113, "./_flags": 115, "./_global": 117, "./_inherit-if-required": 122, "./_is-regexp": 129, "./_object-dp": 146, "./_object-gopn": 151, "./_redefine": 166, "./_set-species": 170, "./_wks": 196 }], 293: [function (_dereq_, module, exports) {
      // 21.2.5.3 get RegExp.prototype.flags()
      if (_dereq_('./_descriptors') && /./g.flags != 'g') _dereq_('./_object-dp').f(RegExp.prototype, 'flags', {
        configurable: true,
        get: _dereq_('./_flags')
      });
    }, { "./_descriptors": 107, "./_flags": 115, "./_object-dp": 146 }], 294: [function (_dereq_, module, exports) {
      // @@match logic
      _dereq_('./_fix-re-wks')('match', 1, function (defined, MATCH, $match) {
        // 21.1.3.11 String.prototype.match(regexp)
        return [function match(regexp) {
          'use strict';

          var O = defined(this),
              fn = regexp == undefined ? undefined : regexp[MATCH];
          return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
        }, $match];
      });
    }, { "./_fix-re-wks": 114 }], 295: [function (_dereq_, module, exports) {
      // @@replace logic
      _dereq_('./_fix-re-wks')('replace', 2, function (defined, REPLACE, $replace) {
        // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
        return [function replace(searchValue, replaceValue) {
          'use strict';

          var O = defined(this),
              fn = searchValue == undefined ? undefined : searchValue[REPLACE];
          return fn !== undefined ? fn.call(searchValue, O, replaceValue) : $replace.call(String(O), searchValue, replaceValue);
        }, $replace];
      });
    }, { "./_fix-re-wks": 114 }], 296: [function (_dereq_, module, exports) {
      // @@search logic
      _dereq_('./_fix-re-wks')('search', 1, function (defined, SEARCH, $search) {
        // 21.1.3.15 String.prototype.search(regexp)
        return [function search(regexp) {
          'use strict';

          var O = defined(this),
              fn = regexp == undefined ? undefined : regexp[SEARCH];
          return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
        }, $search];
      });
    }, { "./_fix-re-wks": 114 }], 297: [function (_dereq_, module, exports) {
      // @@split logic
      _dereq_('./_fix-re-wks')('split', 2, function (defined, SPLIT, $split) {
        'use strict';

        var isRegExp = _dereq_('./_is-regexp'),
            _split = $split,
            $push = [].push,
            $SPLIT = 'split',
            LENGTH = 'length',
            LAST_INDEX = 'lastIndex';
        if ('abbc'[$SPLIT](/(b)*/)[1] == 'c' || 'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 || 'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 || '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 || '.'[$SPLIT](/()()/)[LENGTH] > 1 || ''[$SPLIT](/.?/)[LENGTH]) {
          var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group
          // based on es5-shim implementation, need to rework it
          $split = function $split(separator, limit) {
            var string = String(this);
            if (separator === undefined && limit === 0) return [];
            // If `separator` is not a regex, use native split
            if (!isRegExp(separator)) return _split.call(string, separator, limit);
            var output = [];
            var flags = (separator.ignoreCase ? 'i' : '') + (separator.multiline ? 'm' : '') + (separator.unicode ? 'u' : '') + (separator.sticky ? 'y' : '');
            var lastLastIndex = 0;
            var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
            // Make `global` and avoid `lastIndex` issues by working with a copy
            var separatorCopy = new RegExp(separator.source, flags + 'g');
            var separator2, match, lastIndex, lastLength, i;
            // Doesn't need flags gy, but they don't hurt
            if (!NPCG) separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
            while (match = separatorCopy.exec(string)) {
              // `separatorCopy.lastIndex` is not reliable cross-browser
              lastIndex = match.index + match[0][LENGTH];
              if (lastIndex > lastLastIndex) {
                output.push(string.slice(lastLastIndex, match.index));
                // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG
                if (!NPCG && match[LENGTH] > 1) match[0].replace(separator2, function () {
                  for (i = 1; i < arguments[LENGTH] - 2; i++) {
                    if (arguments[i] === undefined) match[i] = undefined;
                  }
                });
                if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
                lastLength = match[0][LENGTH];
                lastLastIndex = lastIndex;
                if (output[LENGTH] >= splitLimit) break;
              }
              if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
            }
            if (lastLastIndex === string[LENGTH]) {
              if (lastLength || !separatorCopy.test('')) output.push('');
            } else output.push(string.slice(lastLastIndex));
            return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
          };
          // Chakra, V8
        } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
          $split = function $split(separator, limit) {
            return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);
          };
        }
        // 21.1.3.17 String.prototype.split(separator, limit)
        return [function split(separator, limit) {
          var O = defined(this),
              fn = separator == undefined ? undefined : separator[SPLIT];
          return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
        }, $split];
      });
    }, { "./_fix-re-wks": 114, "./_is-regexp": 129 }], 298: [function (_dereq_, module, exports) {
      'use strict';

      _dereq_('./es6.regexp.flags');
      var anObject = _dereq_('./_an-object'),
          $flags = _dereq_('./_flags'),
          DESCRIPTORS = _dereq_('./_descriptors'),
          TO_STRING = 'toString',
          $toString = /./[TO_STRING];

      var define = function define(fn) {
        _dereq_('./_redefine')(RegExp.prototype, TO_STRING, fn, true);
      };

      // 21.2.5.14 RegExp.prototype.toString()
      if (_dereq_('./_fails')(function () {
        return $toString.call({ source: 'a', flags: 'b' }) != '/a/b';
      })) {
        define(function toString() {
          var R = anObject(this);
          return '/'.concat(R.source, '/', 'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
        });
        // FF44- RegExp#toString has a wrong name
      } else if ($toString.name != TO_STRING) {
        define(function toString() {
          return $toString.call(this);
        });
      }
    }, { "./_an-object": 86, "./_descriptors": 107, "./_fails": 113, "./_flags": 115, "./_redefine": 166, "./es6.regexp.flags": 293 }], 299: [function (_dereq_, module, exports) {
      'use strict';

      var strong = _dereq_('./_collection-strong');

      // 23.2 Set Objects
      module.exports = _dereq_('./_collection')('Set', function (get) {
        return function Set() {
          return get(this, arguments.length > 0 ? arguments[0] : undefined);
        };
      }, {
        // 23.2.3.1 Set.prototype.add(value)
        add: function add(value) {
          return strong.def(this, value = value === 0 ? 0 : value, value);
        }
      }, strong);
    }, { "./_collection": 101, "./_collection-strong": 98 }], 300: [function (_dereq_, module, exports) {
      'use strict';
      // B.2.3.2 String.prototype.anchor(name)

      _dereq_('./_string-html')('anchor', function (createHTML) {
        return function anchor(name) {
          return createHTML(this, 'a', 'name', name);
        };
      });
    }, { "./_string-html": 178 }], 301: [function (_dereq_, module, exports) {
      'use strict';
      // B.2.3.3 String.prototype.big()

      _dereq_('./_string-html')('big', function (createHTML) {
        return function big() {
          return createHTML(this, 'big', '', '');
        };
      });
    }, { "./_string-html": 178 }], 302: [function (_dereq_, module, exports) {
      'use strict';
      // B.2.3.4 String.prototype.blink()

      _dereq_('./_string-html')('blink', function (createHTML) {
        return function blink() {
          return createHTML(this, 'blink', '', '');
        };
      });
    }, { "./_string-html": 178 }], 303: [function (_dereq_, module, exports) {
      'use strict';
      // B.2.3.5 String.prototype.bold()

      _dereq_('./_string-html')('bold', function (createHTML) {
        return function bold() {
          return createHTML(this, 'b', '', '');
        };
      });
    }, { "./_string-html": 178 }], 304: [function (_dereq_, module, exports) {
      'use strict';

      var $export = _dereq_('./_export'),
          $at = _dereq_('./_string-at')(false);
      $export($export.P, 'String', {
        // 21.1.3.3 String.prototype.codePointAt(pos)
        codePointAt: function codePointAt(pos) {
          return $at(this, pos);
        }
      });
    }, { "./_export": 111, "./_string-at": 176 }], 305: [function (_dereq_, module, exports) {
      // 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
      'use strict';

      var $export = _dereq_('./_export'),
          toLength = _dereq_('./_to-length'),
          context = _dereq_('./_string-context'),
          ENDS_WITH = 'endsWith',
          $endsWith = ''[ENDS_WITH];

      $export($export.P + $export.F * _dereq_('./_fails-is-regexp')(ENDS_WITH), 'String', {
        endsWith: function endsWith(searchString /*, endPosition = @length */) {
          var that = context(this, searchString, ENDS_WITH),
              endPosition = arguments.length > 1 ? arguments[1] : undefined,
              len = toLength(that.length),
              end = endPosition === undefined ? len : Math.min(toLength(endPosition), len),
              search = String(searchString);
          return $endsWith ? $endsWith.call(that, search, end) : that.slice(end - search.length, end) === search;
        }
      });
    }, { "./_export": 111, "./_fails-is-regexp": 112, "./_string-context": 177, "./_to-length": 187 }], 306: [function (_dereq_, module, exports) {
      'use strict';
      // B.2.3.6 String.prototype.fixed()

      _dereq_('./_string-html')('fixed', function (createHTML) {
        return function fixed() {
          return createHTML(this, 'tt', '', '');
        };
      });
    }, { "./_string-html": 178 }], 307: [function (_dereq_, module, exports) {
      'use strict';
      // B.2.3.7 String.prototype.fontcolor(color)

      _dereq_('./_string-html')('fontcolor', function (createHTML) {
        return function fontcolor(color) {
          return createHTML(this, 'font', 'color', color);
        };
      });
    }, { "./_string-html": 178 }], 308: [function (_dereq_, module, exports) {
      'use strict';
      // B.2.3.8 String.prototype.fontsize(size)

      _dereq_('./_string-html')('fontsize', function (createHTML) {
        return function fontsize(size) {
          return createHTML(this, 'font', 'size', size);
        };
      });
    }, { "./_string-html": 178 }], 309: [function (_dereq_, module, exports) {
      var $export = _dereq_('./_export'),
          toIndex = _dereq_('./_to-index'),
          fromCharCode = String.fromCharCode,
          $fromCodePoint = String.fromCodePoint;

      // length should be 1, old FF problem
      $export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
        // 21.1.2.2 String.fromCodePoint(...codePoints)
        fromCodePoint: function fromCodePoint(x) {
          // eslint-disable-line no-unused-vars
          var res = [],
              aLen = arguments.length,
              i = 0,
              code;
          while (aLen > i) {
            code = +arguments[i++];
            if (toIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
            res.push(code < 0x10000 ? fromCharCode(code) : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00));
          }return res.join('');
        }
      });
    }, { "./_export": 111, "./_to-index": 184 }], 310: [function (_dereq_, module, exports) {
      // 21.1.3.7 String.prototype.includes(searchString, position = 0)
      'use strict';

      var $export = _dereq_('./_export'),
          context = _dereq_('./_string-context'),
          INCLUDES = 'includes';

      $export($export.P + $export.F * _dereq_('./_fails-is-regexp')(INCLUDES), 'String', {
        includes: function includes(searchString /*, position = 0 */) {
          return !!~context(this, searchString, INCLUDES).indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
        }
      });
    }, { "./_export": 111, "./_fails-is-regexp": 112, "./_string-context": 177 }], 311: [function (_dereq_, module, exports) {
      'use strict';
      // B.2.3.9 String.prototype.italics()

      _dereq_('./_string-html')('italics', function (createHTML) {
        return function italics() {
          return createHTML(this, 'i', '', '');
        };
      });
    }, { "./_string-html": 178 }], 312: [function (_dereq_, module, exports) {
      'use strict';

      var $at = _dereq_('./_string-at')(true);

      // 21.1.3.27 String.prototype[@@iterator]()
      _dereq_('./_iter-define')(String, 'String', function (iterated) {
        this._t = String(iterated); // target
        this._i = 0; // next index
        // 21.1.5.2.1 %StringIteratorPrototype%.next()
      }, function () {
        var O = this._t,
            index = this._i,
            point;
        if (index >= O.length) return { value: undefined, done: true };
        point = $at(O, index);
        this._i += point.length;
        return { value: point, done: false };
      });
    }, { "./_iter-define": 132, "./_string-at": 176 }], 313: [function (_dereq_, module, exports) {
      'use strict';
      // B.2.3.10 String.prototype.link(url)

      _dereq_('./_string-html')('link', function (createHTML) {
        return function link(url) {
          return createHTML(this, 'a', 'href', url);
        };
      });
    }, { "./_string-html": 178 }], 314: [function (_dereq_, module, exports) {
      var $export = _dereq_('./_export'),
          toIObject = _dereq_('./_to-iobject'),
          toLength = _dereq_('./_to-length');

      $export($export.S, 'String', {
        // 21.1.2.4 String.raw(callSite, ...substitutions)
        raw: function raw(callSite) {
          var tpl = toIObject(callSite.raw),
              len = toLength(tpl.length),
              aLen = arguments.length,
              res = [],
              i = 0;
          while (len > i) {
            res.push(String(tpl[i++]));
            if (i < aLen) res.push(String(arguments[i]));
          }return res.join('');
        }
      });
    }, { "./_export": 111, "./_to-iobject": 186, "./_to-length": 187 }], 315: [function (_dereq_, module, exports) {
      var $export = _dereq_('./_export');

      $export($export.P, 'String', {
        // 21.1.3.13 String.prototype.repeat(count)
        repeat: _dereq_('./_string-repeat')
      });
    }, { "./_export": 111, "./_string-repeat": 180 }], 316: [function (_dereq_, module, exports) {
      'use strict';
      // B.2.3.11 String.prototype.small()

      _dereq_('./_string-html')('small', function (createHTML) {
        return function small() {
          return createHTML(this, 'small', '', '');
        };
      });
    }, { "./_string-html": 178 }], 317: [function (_dereq_, module, exports) {
      // 21.1.3.18 String.prototype.startsWith(searchString [, position ])
      'use strict';

      var $export = _dereq_('./_export'),
          toLength = _dereq_('./_to-length'),
          context = _dereq_('./_string-context'),
          STARTS_WITH = 'startsWith',
          $startsWith = ''[STARTS_WITH];

      $export($export.P + $export.F * _dereq_('./_fails-is-regexp')(STARTS_WITH), 'String', {
        startsWith: function startsWith(searchString /*, position = 0 */) {
          var that = context(this, searchString, STARTS_WITH),
              index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length)),
              search = String(searchString);
          return $startsWith ? $startsWith.call(that, search, index) : that.slice(index, index + search.length) === search;
        }
      });
    }, { "./_export": 111, "./_fails-is-regexp": 112, "./_string-context": 177, "./_to-length": 187 }], 318: [function (_dereq_, module, exports) {
      'use strict';
      // B.2.3.12 String.prototype.strike()

      _dereq_('./_string-html')('strike', function (createHTML) {
        return function strike() {
          return createHTML(this, 'strike', '', '');
        };
      });
    }, { "./_string-html": 178 }], 319: [function (_dereq_, module, exports) {
      'use strict';
      // B.2.3.13 String.prototype.sub()

      _dereq_('./_string-html')('sub', function (createHTML) {
        return function sub() {
          return createHTML(this, 'sub', '', '');
        };
      });
    }, { "./_string-html": 178 }], 320: [function (_dereq_, module, exports) {
      'use strict';
      // B.2.3.14 String.prototype.sup()

      _dereq_('./_string-html')('sup', function (createHTML) {
        return function sup() {
          return createHTML(this, 'sup', '', '');
        };
      });
    }, { "./_string-html": 178 }], 321: [function (_dereq_, module, exports) {
      'use strict';
      // 21.1.3.25 String.prototype.trim()

      _dereq_('./_string-trim')('trim', function ($trim) {
        return function trim() {
          return $trim(this, 3);
        };
      });
    }, { "./_string-trim": 181 }], 322: [function (_dereq_, module, exports) {
      'use strict';
      // ECMAScript 6 symbols shim

      var global = _dereq_('./_global'),
          has = _dereq_('./_has'),
          DESCRIPTORS = _dereq_('./_descriptors'),
          $export = _dereq_('./_export'),
          redefine = _dereq_('./_redefine'),
          META = _dereq_('./_meta').KEY,
          $fails = _dereq_('./_fails'),
          shared = _dereq_('./_shared'),
          setToStringTag = _dereq_('./_set-to-string-tag'),
          uid = _dereq_('./_uid'),
          wks = _dereq_('./_wks'),
          wksExt = _dereq_('./_wks-ext'),
          wksDefine = _dereq_('./_wks-define'),
          keyOf = _dereq_('./_keyof'),
          enumKeys = _dereq_('./_enum-keys'),
          isArray = _dereq_('./_is-array'),
          anObject = _dereq_('./_an-object'),
          toIObject = _dereq_('./_to-iobject'),
          toPrimitive = _dereq_('./_to-primitive'),
          createDesc = _dereq_('./_property-desc'),
          _create = _dereq_('./_object-create'),
          gOPNExt = _dereq_('./_object-gopn-ext'),
          $GOPD = _dereq_('./_object-gopd'),
          $DP = _dereq_('./_object-dp'),
          $keys = _dereq_('./_object-keys'),
          gOPD = $GOPD.f,
          dP = $DP.f,
          gOPN = gOPNExt.f,
          $Symbol = global.Symbol,
          $JSON = global.JSON,
          _stringify = $JSON && $JSON.stringify,
          PROTOTYPE = 'prototype',
          HIDDEN = wks('_hidden'),
          TO_PRIMITIVE = wks('toPrimitive'),
          isEnum = {}.propertyIsEnumerable,
          SymbolRegistry = shared('symbol-registry'),
          AllSymbols = shared('symbols'),
          OPSymbols = shared('op-symbols'),
          ObjectProto = Object[PROTOTYPE],
          USE_NATIVE = typeof $Symbol == 'function',
          QObject = global.QObject;
      // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
      var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

      // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
      var setSymbolDesc = DESCRIPTORS && $fails(function () {
        return _create(dP({}, 'a', {
          get: function get() {
            return dP(this, 'a', { value: 7 }).a;
          }
        })).a != 7;
      }) ? function (it, key, D) {
        var protoDesc = gOPD(ObjectProto, key);
        if (protoDesc) delete ObjectProto[key];
        dP(it, key, D);
        if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
      } : dP;

      var wrap = function wrap(tag) {
        var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
        sym._k = tag;
        return sym;
      };

      var isSymbol = USE_NATIVE && _typeof2($Symbol.iterator) == 'symbol' ? function (it) {
        return (typeof it === "undefined" ? "undefined" : _typeof2(it)) == 'symbol';
      } : function (it) {
        return it instanceof $Symbol;
      };

      var $defineProperty = function defineProperty(it, key, D) {
        if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
        anObject(it);
        key = toPrimitive(key, true);
        anObject(D);
        if (has(AllSymbols, key)) {
          if (!D.enumerable) {
            if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
            it[HIDDEN][key] = true;
          } else {
            if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
            D = _create(D, { enumerable: createDesc(0, false) });
          }return setSymbolDesc(it, key, D);
        }return dP(it, key, D);
      };
      var $defineProperties = function defineProperties(it, P) {
        anObject(it);
        var keys = enumKeys(P = toIObject(P)),
            i = 0,
            l = keys.length,
            key;
        while (l > i) {
          $defineProperty(it, key = keys[i++], P[key]);
        }return it;
      };
      var $create = function create(it, P) {
        return P === undefined ? _create(it) : $defineProperties(_create(it), P);
      };
      var $propertyIsEnumerable = function propertyIsEnumerable(key) {
        var E = isEnum.call(this, key = toPrimitive(key, true));
        if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
        return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
      };
      var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
        it = toIObject(it);
        key = toPrimitive(key, true);
        if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
        var D = gOPD(it, key);
        if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
        return D;
      };
      var $getOwnPropertyNames = function getOwnPropertyNames(it) {
        var names = gOPN(toIObject(it)),
            result = [],
            i = 0,
            key;
        while (names.length > i) {
          if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
        }return result;
      };
      var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
        var IS_OP = it === ObjectProto,
            names = gOPN(IS_OP ? OPSymbols : toIObject(it)),
            result = [],
            i = 0,
            key;
        while (names.length > i) {
          if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
        }return result;
      };

      // 19.4.1.1 Symbol([description])
      if (!USE_NATIVE) {
        $Symbol = function _Symbol3() {
          if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
          var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
          var $set = function $set(value) {
            if (this === ObjectProto) $set.call(OPSymbols, value);
            if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
            setSymbolDesc(this, tag, createDesc(1, value));
          };
          if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
          return wrap(tag);
        };
        redefine($Symbol[PROTOTYPE], 'toString', function toString() {
          return this._k;
        });

        $GOPD.f = $getOwnPropertyDescriptor;
        $DP.f = $defineProperty;
        _dereq_('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;
        _dereq_('./_object-pie').f = $propertyIsEnumerable;
        _dereq_('./_object-gops').f = $getOwnPropertySymbols;

        if (DESCRIPTORS && !_dereq_('./_library')) {
          redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
        }

        wksExt.f = function (name) {
          return wrap(wks(name));
        };
      }

      $export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

      for (var symbols =
      // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
      'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'.split(','), i = 0; symbols.length > i;) {
        wks(symbols[i++]);
      }for (var symbols = $keys(wks.store), i = 0; symbols.length > i;) {
        wksDefine(symbols[i++]);
      }$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
        // 19.4.2.1 Symbol.for(key)
        'for': function _for(key) {
          return has(SymbolRegistry, key += '') ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
        },
        // 19.4.2.5 Symbol.keyFor(sym)
        keyFor: function keyFor(key) {
          if (isSymbol(key)) return keyOf(SymbolRegistry, key);
          throw TypeError(key + ' is not a symbol!');
        },
        useSetter: function useSetter() {
          setter = true;
        },
        useSimple: function useSimple() {
          setter = false;
        }
      });

      $export($export.S + $export.F * !USE_NATIVE, 'Object', {
        // 19.1.2.2 Object.create(O [, Properties])
        create: $create,
        // 19.1.2.4 Object.defineProperty(O, P, Attributes)
        defineProperty: $defineProperty,
        // 19.1.2.3 Object.defineProperties(O, Properties)
        defineProperties: $defineProperties,
        // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
        getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
        // 19.1.2.7 Object.getOwnPropertyNames(O)
        getOwnPropertyNames: $getOwnPropertyNames,
        // 19.1.2.8 Object.getOwnPropertySymbols(O)
        getOwnPropertySymbols: $getOwnPropertySymbols
      });

      // 24.3.2 JSON.stringify(value [, replacer [, space]])
      $JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
        var S = $Symbol();
        // MS Edge converts symbol values to JSON as {}
        // WebKit converts symbol values to JSON as null
        // V8 throws on boxed symbols
        return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
      })), 'JSON', {
        stringify: function stringify(it) {
          if (it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
          var args = [it],
              i = 1,
              replacer,
              $replacer;
          while (arguments.length > i) {
            args.push(arguments[i++]);
          }replacer = args[1];
          if (typeof replacer == 'function') $replacer = replacer;
          if ($replacer || !isArray(replacer)) replacer = function replacer(key, value) {
            if ($replacer) value = $replacer.call(this, key, value);
            if (!isSymbol(value)) return value;
          };
          args[1] = replacer;
          return _stringify.apply($JSON, args);
        }
      });

      // 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
      $Symbol[PROTOTYPE][TO_PRIMITIVE] || _dereq_('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
      // 19.4.3.5 Symbol.prototype[@@toStringTag]
      setToStringTag($Symbol, 'Symbol');
      // 20.2.1.9 Math[@@toStringTag]
      setToStringTag(Math, 'Math', true);
      // 24.3.3 JSON[@@toStringTag]
      setToStringTag(global.JSON, 'JSON', true);
    }, { "./_an-object": 86, "./_descriptors": 107, "./_enum-keys": 110, "./_export": 111, "./_fails": 113, "./_global": 117, "./_has": 118, "./_hide": 119, "./_is-array": 126, "./_keyof": 136, "./_library": 137, "./_meta": 141, "./_object-create": 145, "./_object-dp": 146, "./_object-gopd": 149, "./_object-gopn": 151, "./_object-gopn-ext": 150, "./_object-gops": 152, "./_object-keys": 155, "./_object-pie": 156, "./_property-desc": 164, "./_redefine": 166, "./_set-to-string-tag": 171, "./_shared": 173, "./_to-iobject": 186, "./_to-primitive": 189, "./_uid": 193, "./_wks": 196, "./_wks-define": 194, "./_wks-ext": 195 }], 323: [function (_dereq_, module, exports) {
      'use strict';

      var $export = _dereq_('./_export'),
          $typed = _dereq_('./_typed'),
          buffer = _dereq_('./_typed-buffer'),
          anObject = _dereq_('./_an-object'),
          toIndex = _dereq_('./_to-index'),
          toLength = _dereq_('./_to-length'),
          isObject = _dereq_('./_is-object'),
          ArrayBuffer = _dereq_('./_global').ArrayBuffer,
          speciesConstructor = _dereq_('./_species-constructor'),
          $ArrayBuffer = buffer.ArrayBuffer,
          $DataView = buffer.DataView,
          $isView = $typed.ABV && ArrayBuffer.isView,
          $slice = $ArrayBuffer.prototype.slice,
          VIEW = $typed.VIEW,
          ARRAY_BUFFER = 'ArrayBuffer';

      $export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer });

      $export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
        // 24.1.3.1 ArrayBuffer.isView(arg)
        isView: function isView(it) {
          return $isView && $isView(it) || isObject(it) && VIEW in it;
        }
      });

      $export($export.P + $export.U + $export.F * _dereq_('./_fails')(function () {
        return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
      }), ARRAY_BUFFER, {
        // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
        slice: function slice(start, end) {
          if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix
          var len = anObject(this).byteLength,
              first = toIndex(start, len),
              final = toIndex(end === undefined ? len : end, len),
              result = new (speciesConstructor(this, $ArrayBuffer))(toLength(final - first)),
              viewS = new $DataView(this),
              viewT = new $DataView(result),
              index = 0;
          while (first < final) {
            viewT.setUint8(index++, viewS.getUint8(first++));
          }return result;
        }
      });

      _dereq_('./_set-species')(ARRAY_BUFFER);
    }, { "./_an-object": 86, "./_export": 111, "./_fails": 113, "./_global": 117, "./_is-object": 128, "./_set-species": 170, "./_species-constructor": 174, "./_to-index": 184, "./_to-length": 187, "./_typed": 192, "./_typed-buffer": 191 }], 324: [function (_dereq_, module, exports) {
      var $export = _dereq_('./_export');
      $export($export.G + $export.W + $export.F * !_dereq_('./_typed').ABV, {
        DataView: _dereq_('./_typed-buffer').DataView
      });
    }, { "./_export": 111, "./_typed": 192, "./_typed-buffer": 191 }], 325: [function (_dereq_, module, exports) {
      _dereq_('./_typed-array')('Float32', 4, function (init) {
        return function Float32Array(data, byteOffset, length) {
          return init(this, data, byteOffset, length);
        };
      });
    }, { "./_typed-array": 190 }], 326: [function (_dereq_, module, exports) {
      _dereq_('./_typed-array')('Float64', 8, function (init) {
        return function Float64Array(data, byteOffset, length) {
          return init(this, data, byteOffset, length);
        };
      });
    }, { "./_typed-array": 190 }], 327: [function (_dereq_, module, exports) {
      _dereq_('./_typed-array')('Int16', 2, function (init) {
        return function Int16Array(data, byteOffset, length) {
          return init(this, data, byteOffset, length);
        };
      });
    }, { "./_typed-array": 190 }], 328: [function (_dereq_, module, exports) {
      _dereq_('./_typed-array')('Int32', 4, function (init) {
        return function Int32Array(data, byteOffset, length) {
          return init(this, data, byteOffset, length);
        };
      });
    }, { "./_typed-array": 190 }], 329: [function (_dereq_, module, exports) {
      _dereq_('./_typed-array')('Int8', 1, function (init) {
        return function Int8Array(data, byteOffset, length) {
          return init(this, data, byteOffset, length);
        };
      });
    }, { "./_typed-array": 190 }], 330: [function (_dereq_, module, exports) {
      _dereq_('./_typed-array')('Uint16', 2, function (init) {
        return function Uint16Array(data, byteOffset, length) {
          return init(this, data, byteOffset, length);
        };
      });
    }, { "./_typed-array": 190 }], 331: [function (_dereq_, module, exports) {
      _dereq_('./_typed-array')('Uint32', 4, function (init) {
        return function Uint32Array(data, byteOffset, length) {
          return init(this, data, byteOffset, length);
        };
      });
    }, { "./_typed-array": 190 }], 332: [function (_dereq_, module, exports) {
      _dereq_('./_typed-array')('Uint8', 1, function (init) {
        return function Uint8Array(data, byteOffset, length) {
          return init(this, data, byteOffset, length);
        };
      });
    }, { "./_typed-array": 190 }], 333: [function (_dereq_, module, exports) {
      _dereq_('./_typed-array')('Uint8', 1, function (init) {
        return function Uint8ClampedArray(data, byteOffset, length) {
          return init(this, data, byteOffset, length);
        };
      }, true);
    }, { "./_typed-array": 190 }], 334: [function (_dereq_, module, exports) {
      'use strict';

      var each = _dereq_('./_array-methods')(0),
          redefine = _dereq_('./_redefine'),
          meta = _dereq_('./_meta'),
          assign = _dereq_('./_object-assign'),
          weak = _dereq_('./_collection-weak'),
          isObject = _dereq_('./_is-object'),
          getWeak = meta.getWeak,
          isExtensible = Object.isExtensible,
          uncaughtFrozenStore = weak.ufstore,
          tmp = {},
          InternalMap;

      var wrapper = function wrapper(get) {
        return function WeakMap() {
          return get(this, arguments.length > 0 ? arguments[0] : undefined);
        };
      };

      var methods = {
        // 23.3.3.3 WeakMap.prototype.get(key)
        get: function get(key) {
          if (isObject(key)) {
            var data = getWeak(key);
            if (data === true) return uncaughtFrozenStore(this).get(key);
            return data ? data[this._i] : undefined;
          }
        },
        // 23.3.3.5 WeakMap.prototype.set(key, value)
        set: function set(key, value) {
          return weak.def(this, key, value);
        }
      };

      // 23.3 WeakMap Objects
      var $WeakMap = module.exports = _dereq_('./_collection')('WeakMap', wrapper, methods, weak, true, true);

      // IE11 WeakMap frozen keys fix
      if (new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7) {
        InternalMap = weak.getConstructor(wrapper);
        assign(InternalMap.prototype, methods);
        meta.NEED = true;
        each(['delete', 'has', 'get', 'set'], function (key) {
          var proto = $WeakMap.prototype,
              method = proto[key];
          redefine(proto, key, function (a, b) {
            // store frozen objects on internal weakmap shim
            if (isObject(a) && !isExtensible(a)) {
              if (!this._f) this._f = new InternalMap();
              var result = this._f[key](a, b);
              return key == 'set' ? this : result;
              // store all the rest on native weakmap
            }return method.call(this, a, b);
          });
        });
      }
    }, { "./_array-methods": 91, "./_collection": 101, "./_collection-weak": 100, "./_is-object": 128, "./_meta": 141, "./_object-assign": 144, "./_redefine": 166 }], 335: [function (_dereq_, module, exports) {
      'use strict';

      var weak = _dereq_('./_collection-weak');

      // 23.4 WeakSet Objects
      _dereq_('./_collection')('WeakSet', function (get) {
        return function WeakSet() {
          return get(this, arguments.length > 0 ? arguments[0] : undefined);
        };
      }, {
        // 23.4.3.1 WeakSet.prototype.add(value)
        add: function add(value) {
          return weak.def(this, value, true);
        }
      }, weak, false, true);
    }, { "./_collection": 101, "./_collection-weak": 100 }], 336: [function (_dereq_, module, exports) {
      'use strict';
      // https://github.com/tc39/Array.prototype.includes

      var $export = _dereq_('./_export'),
          $includes = _dereq_('./_array-includes')(true);

      $export($export.P, 'Array', {
        includes: function includes(el /*, fromIndex = 0 */) {
          return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
        }
      });

      _dereq_('./_add-to-unscopables')('includes');
    }, { "./_add-to-unscopables": 84, "./_array-includes": 90, "./_export": 111 }], 337: [function (_dereq_, module, exports) {
      // https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
      var $export = _dereq_('./_export'),
          microtask = _dereq_('./_microtask')(),
          process = _dereq_('./_global').process,
          isNode = _dereq_('./_cof')(process) == 'process';

      $export($export.G, {
        asap: function asap(fn) {
          var domain = isNode && process.domain;
          microtask(domain ? domain.bind(fn) : fn);
        }
      });
    }, { "./_cof": 97, "./_export": 111, "./_global": 117, "./_microtask": 143 }], 338: [function (_dereq_, module, exports) {
      // https://github.com/ljharb/proposal-is-error
      var $export = _dereq_('./_export'),
          cof = _dereq_('./_cof');

      $export($export.S, 'Error', {
        isError: function isError(it) {
          return cof(it) === 'Error';
        }
      });
    }, { "./_cof": 97, "./_export": 111 }], 339: [function (_dereq_, module, exports) {
      // https://github.com/DavidBruant/Map-Set.prototype.toJSON
      var $export = _dereq_('./_export');

      $export($export.P + $export.R, 'Map', { toJSON: _dereq_('./_collection-to-json')('Map') });
    }, { "./_collection-to-json": 99, "./_export": 111 }], 340: [function (_dereq_, module, exports) {
      // https://gist.github.com/BrendanEich/4294d5c212a6d2254703
      var $export = _dereq_('./_export');

      $export($export.S, 'Math', {
        iaddh: function iaddh(x0, x1, y0, y1) {
          var $x0 = x0 >>> 0,
              $x1 = x1 >>> 0,
              $y0 = y0 >>> 0;
          return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
        }
      });
    }, { "./_export": 111 }], 341: [function (_dereq_, module, exports) {
      // https://gist.github.com/BrendanEich/4294d5c212a6d2254703
      var $export = _dereq_('./_export');

      $export($export.S, 'Math', {
        imulh: function imulh(u, v) {
          var UINT16 = 0xffff,
              $u = +u,
              $v = +v,
              u0 = $u & UINT16,
              v0 = $v & UINT16,
              u1 = $u >> 16,
              v1 = $v >> 16,
              t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
          return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
        }
      });
    }, { "./_export": 111 }], 342: [function (_dereq_, module, exports) {
      // https://gist.github.com/BrendanEich/4294d5c212a6d2254703
      var $export = _dereq_('./_export');

      $export($export.S, 'Math', {
        isubh: function isubh(x0, x1, y0, y1) {
          var $x0 = x0 >>> 0,
              $x1 = x1 >>> 0,
              $y0 = y0 >>> 0;
          return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
        }
      });
    }, { "./_export": 111 }], 343: [function (_dereq_, module, exports) {
      // https://gist.github.com/BrendanEich/4294d5c212a6d2254703
      var $export = _dereq_('./_export');

      $export($export.S, 'Math', {
        umulh: function umulh(u, v) {
          var UINT16 = 0xffff,
              $u = +u,
              $v = +v,
              u0 = $u & UINT16,
              v0 = $v & UINT16,
              u1 = $u >>> 16,
              v1 = $v >>> 16,
              t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
          return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
        }
      });
    }, { "./_export": 111 }], 344: [function (_dereq_, module, exports) {
      'use strict';

      var $export = _dereq_('./_export'),
          toObject = _dereq_('./_to-object'),
          aFunction = _dereq_('./_a-function'),
          $defineProperty = _dereq_('./_object-dp');

      // B.2.2.2 Object.prototype.__defineGetter__(P, getter)
      _dereq_('./_descriptors') && $export($export.P + _dereq_('./_object-forced-pam'), 'Object', {
        __defineGetter__: function __defineGetter__(P, getter) {
          $defineProperty.f(toObject(this), P, { get: aFunction(getter), enumerable: true, configurable: true });
        }
      });
    }, { "./_a-function": 82, "./_descriptors": 107, "./_export": 111, "./_object-dp": 146, "./_object-forced-pam": 148, "./_to-object": 188 }], 345: [function (_dereq_, module, exports) {
      'use strict';

      var $export = _dereq_('./_export'),
          toObject = _dereq_('./_to-object'),
          aFunction = _dereq_('./_a-function'),
          $defineProperty = _dereq_('./_object-dp');

      // B.2.2.3 Object.prototype.__defineSetter__(P, setter)
      _dereq_('./_descriptors') && $export($export.P + _dereq_('./_object-forced-pam'), 'Object', {
        __defineSetter__: function __defineSetter__(P, setter) {
          $defineProperty.f(toObject(this), P, { set: aFunction(setter), enumerable: true, configurable: true });
        }
      });
    }, { "./_a-function": 82, "./_descriptors": 107, "./_export": 111, "./_object-dp": 146, "./_object-forced-pam": 148, "./_to-object": 188 }], 346: [function (_dereq_, module, exports) {
      // https://github.com/tc39/proposal-object-values-entries
      var $export = _dereq_('./_export'),
          $entries = _dereq_('./_object-to-array')(true);

      $export($export.S, 'Object', {
        entries: function entries(it) {
          return $entries(it);
        }
      });
    }, { "./_export": 111, "./_object-to-array": 158 }], 347: [function (_dereq_, module, exports) {
      // https://github.com/tc39/proposal-object-getownpropertydescriptors
      var $export = _dereq_('./_export'),
          ownKeys = _dereq_('./_own-keys'),
          toIObject = _dereq_('./_to-iobject'),
          gOPD = _dereq_('./_object-gopd'),
          createProperty = _dereq_('./_create-property');

      $export($export.S, 'Object', {
        getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
          var O = toIObject(object),
              getDesc = gOPD.f,
              keys = ownKeys(O),
              result = {},
              i = 0,
              key;
          while (keys.length > i) {
            createProperty(result, key = keys[i++], getDesc(O, key));
          }return result;
        }
      });
    }, { "./_create-property": 103, "./_export": 111, "./_object-gopd": 149, "./_own-keys": 159, "./_to-iobject": 186 }], 348: [function (_dereq_, module, exports) {
      'use strict';

      var $export = _dereq_('./_export'),
          toObject = _dereq_('./_to-object'),
          toPrimitive = _dereq_('./_to-primitive'),
          getPrototypeOf = _dereq_('./_object-gpo'),
          getOwnPropertyDescriptor = _dereq_('./_object-gopd').f;

      // B.2.2.4 Object.prototype.__lookupGetter__(P)
      _dereq_('./_descriptors') && $export($export.P + _dereq_('./_object-forced-pam'), 'Object', {
        __lookupGetter__: function __lookupGetter__(P) {
          var O = toObject(this),
              K = toPrimitive(P, true),
              D;
          do {
            if (D = getOwnPropertyDescriptor(O, K)) return D.get;
          } while (O = getPrototypeOf(O));
        }
      });
    }, { "./_descriptors": 107, "./_export": 111, "./_object-forced-pam": 148, "./_object-gopd": 149, "./_object-gpo": 153, "./_to-object": 188, "./_to-primitive": 189 }], 349: [function (_dereq_, module, exports) {
      'use strict';

      var $export = _dereq_('./_export'),
          toObject = _dereq_('./_to-object'),
          toPrimitive = _dereq_('./_to-primitive'),
          getPrototypeOf = _dereq_('./_object-gpo'),
          getOwnPropertyDescriptor = _dereq_('./_object-gopd').f;

      // B.2.2.5 Object.prototype.__lookupSetter__(P)
      _dereq_('./_descriptors') && $export($export.P + _dereq_('./_object-forced-pam'), 'Object', {
        __lookupSetter__: function __lookupSetter__(P) {
          var O = toObject(this),
              K = toPrimitive(P, true),
              D;
          do {
            if (D = getOwnPropertyDescriptor(O, K)) return D.set;
          } while (O = getPrototypeOf(O));
        }
      });
    }, { "./_descriptors": 107, "./_export": 111, "./_object-forced-pam": 148, "./_object-gopd": 149, "./_object-gpo": 153, "./_to-object": 188, "./_to-primitive": 189 }], 350: [function (_dereq_, module, exports) {
      // https://github.com/tc39/proposal-object-values-entries
      var $export = _dereq_('./_export'),
          $values = _dereq_('./_object-to-array')(false);

      $export($export.S, 'Object', {
        values: function values(it) {
          return $values(it);
        }
      });
    }, { "./_export": 111, "./_object-to-array": 158 }], 351: [function (_dereq_, module, exports) {
      'use strict';
      // https://github.com/zenparsing/es-observable

      var $export = _dereq_('./_export'),
          global = _dereq_('./_global'),
          core = _dereq_('./_core'),
          microtask = _dereq_('./_microtask')(),
          OBSERVABLE = _dereq_('./_wks')('observable'),
          aFunction = _dereq_('./_a-function'),
          anObject = _dereq_('./_an-object'),
          anInstance = _dereq_('./_an-instance'),
          redefineAll = _dereq_('./_redefine-all'),
          hide = _dereq_('./_hide'),
          forOf = _dereq_('./_for-of'),
          RETURN = forOf.RETURN;

      var getMethod = function getMethod(fn) {
        return fn == null ? undefined : aFunction(fn);
      };

      var cleanupSubscription = function cleanupSubscription(subscription) {
        var cleanup = subscription._c;
        if (cleanup) {
          subscription._c = undefined;
          cleanup();
        }
      };

      var subscriptionClosed = function subscriptionClosed(subscription) {
        return subscription._o === undefined;
      };

      var closeSubscription = function closeSubscription(subscription) {
        if (!subscriptionClosed(subscription)) {
          subscription._o = undefined;
          cleanupSubscription(subscription);
        }
      };

      var Subscription = function Subscription(observer, subscriber) {
        anObject(observer);
        this._c = undefined;
        this._o = observer;
        observer = new SubscriptionObserver(this);
        try {
          var cleanup = subscriber(observer),
              subscription = cleanup;
          if (cleanup != null) {
            if (typeof cleanup.unsubscribe === 'function') cleanup = function cleanup() {
              subscription.unsubscribe();
            };else aFunction(cleanup);
            this._c = cleanup;
          }
        } catch (e) {
          observer.error(e);
          return;
        }if (subscriptionClosed(this)) cleanupSubscription(this);
      };

      Subscription.prototype = redefineAll({}, {
        unsubscribe: function unsubscribe() {
          closeSubscription(this);
        }
      });

      var SubscriptionObserver = function SubscriptionObserver(subscription) {
        this._s = subscription;
      };

      SubscriptionObserver.prototype = redefineAll({}, {
        next: function next(value) {
          var subscription = this._s;
          if (!subscriptionClosed(subscription)) {
            var observer = subscription._o;
            try {
              var m = getMethod(observer.next);
              if (m) return m.call(observer, value);
            } catch (e) {
              try {
                closeSubscription(subscription);
              } finally {
                throw e;
              }
            }
          }
        },
        error: function error(value) {
          var subscription = this._s;
          if (subscriptionClosed(subscription)) throw value;
          var observer = subscription._o;
          subscription._o = undefined;
          try {
            var m = getMethod(observer.error);
            if (!m) throw value;
            value = m.call(observer, value);
          } catch (e) {
            try {
              cleanupSubscription(subscription);
            } finally {
              throw e;
            }
          }cleanupSubscription(subscription);
          return value;
        },
        complete: function complete(value) {
          var subscription = this._s;
          if (!subscriptionClosed(subscription)) {
            var observer = subscription._o;
            subscription._o = undefined;
            try {
              var m = getMethod(observer.complete);
              value = m ? m.call(observer, value) : undefined;
            } catch (e) {
              try {
                cleanupSubscription(subscription);
              } finally {
                throw e;
              }
            }cleanupSubscription(subscription);
            return value;
          }
        }
      });

      var $Observable = function Observable(subscriber) {
        anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
      };

      redefineAll($Observable.prototype, {
        subscribe: function subscribe(observer) {
          return new Subscription(observer, this._f);
        },
        forEach: function forEach(fn) {
          var that = this;
          return new (core.Promise || global.Promise)(function (resolve, reject) {
            aFunction(fn);
            var subscription = that.subscribe({
              next: function next(value) {
                try {
                  return fn(value);
                } catch (e) {
                  reject(e);
                  subscription.unsubscribe();
                }
              },
              error: reject,
              complete: resolve
            });
          });
        }
      });

      redefineAll($Observable, {
        from: function from(x) {
          var C = typeof this === 'function' ? this : $Observable;
          var method = getMethod(anObject(x)[OBSERVABLE]);
          if (method) {
            var observable = anObject(method.call(x));
            return observable.constructor === C ? observable : new C(function (observer) {
              return observable.subscribe(observer);
            });
          }
          return new C(function (observer) {
            var done = false;
            microtask(function () {
              if (!done) {
                try {
                  if (forOf(x, false, function (it) {
                    observer.next(it);
                    if (done) return RETURN;
                  }) === RETURN) return;
                } catch (e) {
                  if (done) throw e;
                  observer.error(e);
                  return;
                }observer.complete();
              }
            });
            return function () {
              done = true;
            };
          });
        },
        of: function of() {
          for (var i = 0, l = arguments.length, items = Array(l); i < l;) {
            items[i] = arguments[i++];
          }return new (typeof this === 'function' ? this : $Observable)(function (observer) {
            var done = false;
            microtask(function () {
              if (!done) {
                for (var i = 0; i < items.length; ++i) {
                  observer.next(items[i]);
                  if (done) return;
                }observer.complete();
              }
            });
            return function () {
              done = true;
            };
          });
        }
      });

      hide($Observable.prototype, OBSERVABLE, function () {
        return this;
      });

      $export($export.G, { Observable: $Observable });

      _dereq_('./_set-species')('Observable');
    }, { "./_a-function": 82, "./_an-instance": 85, "./_an-object": 86, "./_core": 102, "./_export": 111, "./_for-of": 116, "./_global": 117, "./_hide": 119, "./_microtask": 143, "./_redefine-all": 165, "./_set-species": 170, "./_wks": 196 }], 352: [function (_dereq_, module, exports) {
      var metadata = _dereq_('./_metadata'),
          anObject = _dereq_('./_an-object'),
          toMetaKey = metadata.key,
          ordinaryDefineOwnMetadata = metadata.set;

      metadata.exp({ defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey) {
          ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
        } });
    }, { "./_an-object": 86, "./_metadata": 142 }], 353: [function (_dereq_, module, exports) {
      var metadata = _dereq_('./_metadata'),
          anObject = _dereq_('./_an-object'),
          toMetaKey = metadata.key,
          getOrCreateMetadataMap = metadata.map,
          store = metadata.store;

      metadata.exp({ deleteMetadata: function deleteMetadata(metadataKey, target /*, targetKey */) {
          var targetKey = arguments.length < 3 ? undefined : toMetaKey(arguments[2]),
              metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
          if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false;
          if (metadataMap.size) return true;
          var targetMetadata = store.get(target);
          targetMetadata['delete'](targetKey);
          return !!targetMetadata.size || store['delete'](target);
        } });
    }, { "./_an-object": 86, "./_metadata": 142 }], 354: [function (_dereq_, module, exports) {
      var Set = _dereq_('./es6.set'),
          from = _dereq_('./_array-from-iterable'),
          metadata = _dereq_('./_metadata'),
          anObject = _dereq_('./_an-object'),
          getPrototypeOf = _dereq_('./_object-gpo'),
          ordinaryOwnMetadataKeys = metadata.keys,
          toMetaKey = metadata.key;

      var ordinaryMetadataKeys = function ordinaryMetadataKeys(O, P) {
        var oKeys = ordinaryOwnMetadataKeys(O, P),
            parent = getPrototypeOf(O);
        if (parent === null) return oKeys;
        var pKeys = ordinaryMetadataKeys(parent, P);
        return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
      };

      metadata.exp({ getMetadataKeys: function getMetadataKeys(target /*, targetKey */) {
          return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
        } });
    }, { "./_an-object": 86, "./_array-from-iterable": 89, "./_metadata": 142, "./_object-gpo": 153, "./es6.set": 299 }], 355: [function (_dereq_, module, exports) {
      var metadata = _dereq_('./_metadata'),
          anObject = _dereq_('./_an-object'),
          getPrototypeOf = _dereq_('./_object-gpo'),
          ordinaryHasOwnMetadata = metadata.has,
          ordinaryGetOwnMetadata = metadata.get,
          toMetaKey = metadata.key;

      var ordinaryGetMetadata = function ordinaryGetMetadata(MetadataKey, O, P) {
        var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
        if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P);
        var parent = getPrototypeOf(O);
        return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
      };

      metadata.exp({ getMetadata: function getMetadata(metadataKey, target /*, targetKey */) {
          return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
        } });
    }, { "./_an-object": 86, "./_metadata": 142, "./_object-gpo": 153 }], 356: [function (_dereq_, module, exports) {
      var metadata = _dereq_('./_metadata'),
          anObject = _dereq_('./_an-object'),
          ordinaryOwnMetadataKeys = metadata.keys,
          toMetaKey = metadata.key;

      metadata.exp({ getOwnMetadataKeys: function getOwnMetadataKeys(target /*, targetKey */) {
          return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
        } });
    }, { "./_an-object": 86, "./_metadata": 142 }], 357: [function (_dereq_, module, exports) {
      var metadata = _dereq_('./_metadata'),
          anObject = _dereq_('./_an-object'),
          ordinaryGetOwnMetadata = metadata.get,
          toMetaKey = metadata.key;

      metadata.exp({ getOwnMetadata: function getOwnMetadata(metadataKey, target /*, targetKey */) {
          return ordinaryGetOwnMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
        } });
    }, { "./_an-object": 86, "./_metadata": 142 }], 358: [function (_dereq_, module, exports) {
      var metadata = _dereq_('./_metadata'),
          anObject = _dereq_('./_an-object'),
          getPrototypeOf = _dereq_('./_object-gpo'),
          ordinaryHasOwnMetadata = metadata.has,
          toMetaKey = metadata.key;

      var ordinaryHasMetadata = function ordinaryHasMetadata(MetadataKey, O, P) {
        var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
        if (hasOwn) return true;
        var parent = getPrototypeOf(O);
        return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
      };

      metadata.exp({ hasMetadata: function hasMetadata(metadataKey, target /*, targetKey */) {
          return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
        } });
    }, { "./_an-object": 86, "./_metadata": 142, "./_object-gpo": 153 }], 359: [function (_dereq_, module, exports) {
      var metadata = _dereq_('./_metadata'),
          anObject = _dereq_('./_an-object'),
          ordinaryHasOwnMetadata = metadata.has,
          toMetaKey = metadata.key;

      metadata.exp({ hasOwnMetadata: function hasOwnMetadata(metadataKey, target /*, targetKey */) {
          return ordinaryHasOwnMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
        } });
    }, { "./_an-object": 86, "./_metadata": 142 }], 360: [function (_dereq_, module, exports) {
      var metadata = _dereq_('./_metadata'),
          anObject = _dereq_('./_an-object'),
          aFunction = _dereq_('./_a-function'),
          toMetaKey = metadata.key,
          ordinaryDefineOwnMetadata = metadata.set;

      metadata.exp({ metadata: function metadata(metadataKey, metadataValue) {
          return function decorator(target, targetKey) {
            ordinaryDefineOwnMetadata(metadataKey, metadataValue, (targetKey !== undefined ? anObject : aFunction)(target), toMetaKey(targetKey));
          };
        } });
    }, { "./_a-function": 82, "./_an-object": 86, "./_metadata": 142 }], 361: [function (_dereq_, module, exports) {
      // https://github.com/DavidBruant/Map-Set.prototype.toJSON
      var $export = _dereq_('./_export');

      $export($export.P + $export.R, 'Set', { toJSON: _dereq_('./_collection-to-json')('Set') });
    }, { "./_collection-to-json": 99, "./_export": 111 }], 362: [function (_dereq_, module, exports) {
      'use strict';
      // https://github.com/mathiasbynens/String.prototype.at

      var $export = _dereq_('./_export'),
          $at = _dereq_('./_string-at')(true);

      $export($export.P, 'String', {
        at: function at(pos) {
          return $at(this, pos);
        }
      });
    }, { "./_export": 111, "./_string-at": 176 }], 363: [function (_dereq_, module, exports) {
      'use strict';
      // https://tc39.github.io/String.prototype.matchAll/

      var $export = _dereq_('./_export'),
          defined = _dereq_('./_defined'),
          toLength = _dereq_('./_to-length'),
          isRegExp = _dereq_('./_is-regexp'),
          getFlags = _dereq_('./_flags'),
          RegExpProto = RegExp.prototype;

      var $RegExpStringIterator = function $RegExpStringIterator(regexp, string) {
        this._r = regexp;
        this._s = string;
      };

      _dereq_('./_iter-create')($RegExpStringIterator, 'RegExp String', function next() {
        var match = this._r.exec(this._s);
        return { value: match, done: match === null };
      });

      $export($export.P, 'String', {
        matchAll: function matchAll(regexp) {
          defined(this);
          if (!isRegExp(regexp)) throw TypeError(regexp + ' is not a regexp!');
          var S = String(this),
              flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp),
              rx = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
          rx.lastIndex = toLength(regexp.lastIndex);
          return new $RegExpStringIterator(rx, S);
        }
      });
    }, { "./_defined": 106, "./_export": 111, "./_flags": 115, "./_is-regexp": 129, "./_iter-create": 131, "./_to-length": 187 }], 364: [function (_dereq_, module, exports) {
      'use strict';
      // https://github.com/tc39/proposal-string-pad-start-end

      var $export = _dereq_('./_export'),
          $pad = _dereq_('./_string-pad');

      $export($export.P, 'String', {
        padEnd: function padEnd(maxLength /*, fillString = ' ' */) {
          return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
        }
      });
    }, { "./_export": 111, "./_string-pad": 179 }], 365: [function (_dereq_, module, exports) {
      'use strict';
      // https://github.com/tc39/proposal-string-pad-start-end

      var $export = _dereq_('./_export'),
          $pad = _dereq_('./_string-pad');

      $export($export.P, 'String', {
        padStart: function padStart(maxLength /*, fillString = ' ' */) {
          return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
        }
      });
    }, { "./_export": 111, "./_string-pad": 179 }], 366: [function (_dereq_, module, exports) {
      'use strict';
      // https://github.com/sebmarkbage/ecmascript-string-left-right-trim

      _dereq_('./_string-trim')('trimLeft', function ($trim) {
        return function trimLeft() {
          return $trim(this, 1);
        };
      }, 'trimStart');
    }, { "./_string-trim": 181 }], 367: [function (_dereq_, module, exports) {
      'use strict';
      // https://github.com/sebmarkbage/ecmascript-string-left-right-trim

      _dereq_('./_string-trim')('trimRight', function ($trim) {
        return function trimRight() {
          return $trim(this, 2);
        };
      }, 'trimEnd');
    }, { "./_string-trim": 181 }], 368: [function (_dereq_, module, exports) {
      _dereq_('./_wks-define')('asyncIterator');
    }, { "./_wks-define": 194 }], 369: [function (_dereq_, module, exports) {
      _dereq_('./_wks-define')('observable');
    }, { "./_wks-define": 194 }], 370: [function (_dereq_, module, exports) {
      // https://github.com/ljharb/proposal-global
      var $export = _dereq_('./_export');

      $export($export.S, 'System', { global: _dereq_('./_global') });
    }, { "./_export": 111, "./_global": 117 }], 371: [function (_dereq_, module, exports) {
      var $iterators = _dereq_('./es6.array.iterator'),
          redefine = _dereq_('./_redefine'),
          global = _dereq_('./_global'),
          hide = _dereq_('./_hide'),
          Iterators = _dereq_('./_iterators'),
          wks = _dereq_('./_wks'),
          ITERATOR = wks('iterator'),
          TO_STRING_TAG = wks('toStringTag'),
          ArrayValues = Iterators.Array;

      for (var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++) {
        var NAME = collections[i],
            Collection = global[NAME],
            proto = Collection && Collection.prototype,
            key;
        if (proto) {
          if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
          if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
          Iterators[NAME] = ArrayValues;
          for (key in $iterators) {
            if (!proto[key]) redefine(proto, key, $iterators[key], true);
          }
        }
      }
    }, { "./_global": 117, "./_hide": 119, "./_iterators": 135, "./_redefine": 166, "./_wks": 196, "./es6.array.iterator": 209 }], 372: [function (_dereq_, module, exports) {
      var $export = _dereq_('./_export'),
          $task = _dereq_('./_task');
      $export($export.G + $export.B, {
        setImmediate: $task.set,
        clearImmediate: $task.clear
      });
    }, { "./_export": 111, "./_task": 183 }], 373: [function (_dereq_, module, exports) {
      // ie9- setTimeout & setInterval additional parameters fix
      var global = _dereq_('./_global'),
          $export = _dereq_('./_export'),
          invoke = _dereq_('./_invoke'),
          partial = _dereq_('./_partial'),
          navigator = global.navigator,
          MSIE = !!navigator && /MSIE .\./.test(navigator.userAgent); // <- dirty ie9- check
      var wrap = function wrap(set) {
        return MSIE ? function (fn, time /*, ...args */) {
          return set(invoke(partial, [].slice.call(arguments, 2), typeof fn == 'function' ? fn : Function(fn)), time);
        } : set;
      };
      $export($export.G + $export.B + $export.F * MSIE, {
        setTimeout: wrap(global.setTimeout),
        setInterval: wrap(global.setInterval)
      });
    }, { "./_export": 111, "./_global": 117, "./_invoke": 123, "./_partial": 162 }], 374: [function (_dereq_, module, exports) {
      _dereq_('./modules/es6.symbol');
      _dereq_('./modules/es6.object.create');
      _dereq_('./modules/es6.object.define-property');
      _dereq_('./modules/es6.object.define-properties');
      _dereq_('./modules/es6.object.get-own-property-descriptor');
      _dereq_('./modules/es6.object.get-prototype-of');
      _dereq_('./modules/es6.object.keys');
      _dereq_('./modules/es6.object.get-own-property-names');
      _dereq_('./modules/es6.object.freeze');
      _dereq_('./modules/es6.object.seal');
      _dereq_('./modules/es6.object.prevent-extensions');
      _dereq_('./modules/es6.object.is-frozen');
      _dereq_('./modules/es6.object.is-sealed');
      _dereq_('./modules/es6.object.is-extensible');
      _dereq_('./modules/es6.object.assign');
      _dereq_('./modules/es6.object.is');
      _dereq_('./modules/es6.object.set-prototype-of');
      _dereq_('./modules/es6.object.to-string');
      _dereq_('./modules/es6.function.bind');
      _dereq_('./modules/es6.function.name');
      _dereq_('./modules/es6.function.has-instance');
      _dereq_('./modules/es6.parse-int');
      _dereq_('./modules/es6.parse-float');
      _dereq_('./modules/es6.number.constructor');
      _dereq_('./modules/es6.number.to-fixed');
      _dereq_('./modules/es6.number.to-precision');
      _dereq_('./modules/es6.number.epsilon');
      _dereq_('./modules/es6.number.is-finite');
      _dereq_('./modules/es6.number.is-integer');
      _dereq_('./modules/es6.number.is-nan');
      _dereq_('./modules/es6.number.is-safe-integer');
      _dereq_('./modules/es6.number.max-safe-integer');
      _dereq_('./modules/es6.number.min-safe-integer');
      _dereq_('./modules/es6.number.parse-float');
      _dereq_('./modules/es6.number.parse-int');
      _dereq_('./modules/es6.math.acosh');
      _dereq_('./modules/es6.math.asinh');
      _dereq_('./modules/es6.math.atanh');
      _dereq_('./modules/es6.math.cbrt');
      _dereq_('./modules/es6.math.clz32');
      _dereq_('./modules/es6.math.cosh');
      _dereq_('./modules/es6.math.expm1');
      _dereq_('./modules/es6.math.fround');
      _dereq_('./modules/es6.math.hypot');
      _dereq_('./modules/es6.math.imul');
      _dereq_('./modules/es6.math.log10');
      _dereq_('./modules/es6.math.log1p');
      _dereq_('./modules/es6.math.log2');
      _dereq_('./modules/es6.math.sign');
      _dereq_('./modules/es6.math.sinh');
      _dereq_('./modules/es6.math.tanh');
      _dereq_('./modules/es6.math.trunc');
      _dereq_('./modules/es6.string.from-code-point');
      _dereq_('./modules/es6.string.raw');
      _dereq_('./modules/es6.string.trim');
      _dereq_('./modules/es6.string.iterator');
      _dereq_('./modules/es6.string.code-point-at');
      _dereq_('./modules/es6.string.ends-with');
      _dereq_('./modules/es6.string.includes');
      _dereq_('./modules/es6.string.repeat');
      _dereq_('./modules/es6.string.starts-with');
      _dereq_('./modules/es6.string.anchor');
      _dereq_('./modules/es6.string.big');
      _dereq_('./modules/es6.string.blink');
      _dereq_('./modules/es6.string.bold');
      _dereq_('./modules/es6.string.fixed');
      _dereq_('./modules/es6.string.fontcolor');
      _dereq_('./modules/es6.string.fontsize');
      _dereq_('./modules/es6.string.italics');
      _dereq_('./modules/es6.string.link');
      _dereq_('./modules/es6.string.small');
      _dereq_('./modules/es6.string.strike');
      _dereq_('./modules/es6.string.sub');
      _dereq_('./modules/es6.string.sup');
      _dereq_('./modules/es6.date.now');
      _dereq_('./modules/es6.date.to-json');
      _dereq_('./modules/es6.date.to-iso-string');
      _dereq_('./modules/es6.date.to-string');
      _dereq_('./modules/es6.date.to-primitive');
      _dereq_('./modules/es6.array.is-array');
      _dereq_('./modules/es6.array.from');
      _dereq_('./modules/es6.array.of');
      _dereq_('./modules/es6.array.join');
      _dereq_('./modules/es6.array.slice');
      _dereq_('./modules/es6.array.sort');
      _dereq_('./modules/es6.array.for-each');
      _dereq_('./modules/es6.array.map');
      _dereq_('./modules/es6.array.filter');
      _dereq_('./modules/es6.array.some');
      _dereq_('./modules/es6.array.every');
      _dereq_('./modules/es6.array.reduce');
      _dereq_('./modules/es6.array.reduce-right');
      _dereq_('./modules/es6.array.index-of');
      _dereq_('./modules/es6.array.last-index-of');
      _dereq_('./modules/es6.array.copy-within');
      _dereq_('./modules/es6.array.fill');
      _dereq_('./modules/es6.array.find');
      _dereq_('./modules/es6.array.find-index');
      _dereq_('./modules/es6.array.species');
      _dereq_('./modules/es6.array.iterator');
      _dereq_('./modules/es6.regexp.constructor');
      _dereq_('./modules/es6.regexp.to-string');
      _dereq_('./modules/es6.regexp.flags');
      _dereq_('./modules/es6.regexp.match');
      _dereq_('./modules/es6.regexp.replace');
      _dereq_('./modules/es6.regexp.search');
      _dereq_('./modules/es6.regexp.split');
      _dereq_('./modules/es6.promise');
      _dereq_('./modules/es6.map');
      _dereq_('./modules/es6.set');
      _dereq_('./modules/es6.weak-map');
      _dereq_('./modules/es6.weak-set');
      _dereq_('./modules/es6.typed.array-buffer');
      _dereq_('./modules/es6.typed.data-view');
      _dereq_('./modules/es6.typed.int8-array');
      _dereq_('./modules/es6.typed.uint8-array');
      _dereq_('./modules/es6.typed.uint8-clamped-array');
      _dereq_('./modules/es6.typed.int16-array');
      _dereq_('./modules/es6.typed.uint16-array');
      _dereq_('./modules/es6.typed.int32-array');
      _dereq_('./modules/es6.typed.uint32-array');
      _dereq_('./modules/es6.typed.float32-array');
      _dereq_('./modules/es6.typed.float64-array');
      _dereq_('./modules/es6.reflect.apply');
      _dereq_('./modules/es6.reflect.construct');
      _dereq_('./modules/es6.reflect.define-property');
      _dereq_('./modules/es6.reflect.delete-property');
      _dereq_('./modules/es6.reflect.enumerate');
      _dereq_('./modules/es6.reflect.get');
      _dereq_('./modules/es6.reflect.get-own-property-descriptor');
      _dereq_('./modules/es6.reflect.get-prototype-of');
      _dereq_('./modules/es6.reflect.has');
      _dereq_('./modules/es6.reflect.is-extensible');
      _dereq_('./modules/es6.reflect.own-keys');
      _dereq_('./modules/es6.reflect.prevent-extensions');
      _dereq_('./modules/es6.reflect.set');
      _dereq_('./modules/es6.reflect.set-prototype-of');
      _dereq_('./modules/es7.array.includes');
      _dereq_('./modules/es7.string.at');
      _dereq_('./modules/es7.string.pad-start');
      _dereq_('./modules/es7.string.pad-end');
      _dereq_('./modules/es7.string.trim-left');
      _dereq_('./modules/es7.string.trim-right');
      _dereq_('./modules/es7.string.match-all');
      _dereq_('./modules/es7.symbol.async-iterator');
      _dereq_('./modules/es7.symbol.observable');
      _dereq_('./modules/es7.object.get-own-property-descriptors');
      _dereq_('./modules/es7.object.values');
      _dereq_('./modules/es7.object.entries');
      _dereq_('./modules/es7.object.define-getter');
      _dereq_('./modules/es7.object.define-setter');
      _dereq_('./modules/es7.object.lookup-getter');
      _dereq_('./modules/es7.object.lookup-setter');
      _dereq_('./modules/es7.map.to-json');
      _dereq_('./modules/es7.set.to-json');
      _dereq_('./modules/es7.system.global');
      _dereq_('./modules/es7.error.is-error');
      _dereq_('./modules/es7.math.iaddh');
      _dereq_('./modules/es7.math.isubh');
      _dereq_('./modules/es7.math.imulh');
      _dereq_('./modules/es7.math.umulh');
      _dereq_('./modules/es7.reflect.define-metadata');
      _dereq_('./modules/es7.reflect.delete-metadata');
      _dereq_('./modules/es7.reflect.get-metadata');
      _dereq_('./modules/es7.reflect.get-metadata-keys');
      _dereq_('./modules/es7.reflect.get-own-metadata');
      _dereq_('./modules/es7.reflect.get-own-metadata-keys');
      _dereq_('./modules/es7.reflect.has-metadata');
      _dereq_('./modules/es7.reflect.has-own-metadata');
      _dereq_('./modules/es7.reflect.metadata');
      _dereq_('./modules/es7.asap');
      _dereq_('./modules/es7.observable');
      _dereq_('./modules/web.timers');
      _dereq_('./modules/web.immediate');
      _dereq_('./modules/web.dom.iterable');
      module.exports = _dereq_('./modules/_core');
    }, { "./modules/_core": 102, "./modules/es6.array.copy-within": 199, "./modules/es6.array.every": 200, "./modules/es6.array.fill": 201, "./modules/es6.array.filter": 202, "./modules/es6.array.find": 204, "./modules/es6.array.find-index": 203, "./modules/es6.array.for-each": 205, "./modules/es6.array.from": 206, "./modules/es6.array.index-of": 207, "./modules/es6.array.is-array": 208, "./modules/es6.array.iterator": 209, "./modules/es6.array.join": 210, "./modules/es6.array.last-index-of": 211, "./modules/es6.array.map": 212, "./modules/es6.array.of": 213, "./modules/es6.array.reduce": 215, "./modules/es6.array.reduce-right": 214, "./modules/es6.array.slice": 216, "./modules/es6.array.some": 217, "./modules/es6.array.sort": 218, "./modules/es6.array.species": 219, "./modules/es6.date.now": 220, "./modules/es6.date.to-iso-string": 221, "./modules/es6.date.to-json": 222, "./modules/es6.date.to-primitive": 223, "./modules/es6.date.to-string": 224, "./modules/es6.function.bind": 225, "./modules/es6.function.has-instance": 226, "./modules/es6.function.name": 227, "./modules/es6.map": 228, "./modules/es6.math.acosh": 229, "./modules/es6.math.asinh": 230, "./modules/es6.math.atanh": 231, "./modules/es6.math.cbrt": 232, "./modules/es6.math.clz32": 233, "./modules/es6.math.cosh": 234, "./modules/es6.math.expm1": 235, "./modules/es6.math.fround": 236, "./modules/es6.math.hypot": 237, "./modules/es6.math.imul": 238, "./modules/es6.math.log10": 239, "./modules/es6.math.log1p": 240, "./modules/es6.math.log2": 241, "./modules/es6.math.sign": 242, "./modules/es6.math.sinh": 243, "./modules/es6.math.tanh": 244, "./modules/es6.math.trunc": 245, "./modules/es6.number.constructor": 246, "./modules/es6.number.epsilon": 247, "./modules/es6.number.is-finite": 248, "./modules/es6.number.is-integer": 249, "./modules/es6.number.is-nan": 250, "./modules/es6.number.is-safe-integer": 251, "./modules/es6.number.max-safe-integer": 252, "./modules/es6.number.min-safe-integer": 253, "./modules/es6.number.parse-float": 254, "./modules/es6.number.parse-int": 255, "./modules/es6.number.to-fixed": 256, "./modules/es6.number.to-precision": 257, "./modules/es6.object.assign": 258, "./modules/es6.object.create": 259, "./modules/es6.object.define-properties": 260, "./modules/es6.object.define-property": 261, "./modules/es6.object.freeze": 262, "./modules/es6.object.get-own-property-descriptor": 263, "./modules/es6.object.get-own-property-names": 264, "./modules/es6.object.get-prototype-of": 265, "./modules/es6.object.is": 269, "./modules/es6.object.is-extensible": 266, "./modules/es6.object.is-frozen": 267, "./modules/es6.object.is-sealed": 268, "./modules/es6.object.keys": 270, "./modules/es6.object.prevent-extensions": 271, "./modules/es6.object.seal": 272, "./modules/es6.object.set-prototype-of": 273, "./modules/es6.object.to-string": 274, "./modules/es6.parse-float": 275, "./modules/es6.parse-int": 276, "./modules/es6.promise": 277, "./modules/es6.reflect.apply": 278, "./modules/es6.reflect.construct": 279, "./modules/es6.reflect.define-property": 280, "./modules/es6.reflect.delete-property": 281, "./modules/es6.reflect.enumerate": 282, "./modules/es6.reflect.get": 285, "./modules/es6.reflect.get-own-property-descriptor": 283, "./modules/es6.reflect.get-prototype-of": 284, "./modules/es6.reflect.has": 286, "./modules/es6.reflect.is-extensible": 287, "./modules/es6.reflect.own-keys": 288, "./modules/es6.reflect.prevent-extensions": 289, "./modules/es6.reflect.set": 291, "./modules/es6.reflect.set-prototype-of": 290, "./modules/es6.regexp.constructor": 292, "./modules/es6.regexp.flags": 293, "./modules/es6.regexp.match": 294, "./modules/es6.regexp.replace": 295, "./modules/es6.regexp.search": 296, "./modules/es6.regexp.split": 297, "./modules/es6.regexp.to-string": 298, "./modules/es6.set": 299, "./modules/es6.string.anchor": 300, "./modules/es6.string.big": 301, "./modules/es6.string.blink": 302, "./modules/es6.string.bold": 303, "./modules/es6.string.code-point-at": 304, "./modules/es6.string.ends-with": 305, "./modules/es6.string.fixed": 306, "./modules/es6.string.fontcolor": 307, "./modules/es6.string.fontsize": 308, "./modules/es6.string.from-code-point": 309, "./modules/es6.string.includes": 310, "./modules/es6.string.italics": 311, "./modules/es6.string.iterator": 312, "./modules/es6.string.link": 313, "./modules/es6.string.raw": 314, "./modules/es6.string.repeat": 315, "./modules/es6.string.small": 316, "./modules/es6.string.starts-with": 317, "./modules/es6.string.strike": 318, "./modules/es6.string.sub": 319, "./modules/es6.string.sup": 320, "./modules/es6.string.trim": 321, "./modules/es6.symbol": 322, "./modules/es6.typed.array-buffer": 323, "./modules/es6.typed.data-view": 324, "./modules/es6.typed.float32-array": 325, "./modules/es6.typed.float64-array": 326, "./modules/es6.typed.int16-array": 327, "./modules/es6.typed.int32-array": 328, "./modules/es6.typed.int8-array": 329, "./modules/es6.typed.uint16-array": 330, "./modules/es6.typed.uint32-array": 331, "./modules/es6.typed.uint8-array": 332, "./modules/es6.typed.uint8-clamped-array": 333, "./modules/es6.weak-map": 334, "./modules/es6.weak-set": 335, "./modules/es7.array.includes": 336, "./modules/es7.asap": 337, "./modules/es7.error.is-error": 338, "./modules/es7.map.to-json": 339, "./modules/es7.math.iaddh": 340, "./modules/es7.math.imulh": 341, "./modules/es7.math.isubh": 342, "./modules/es7.math.umulh": 343, "./modules/es7.object.define-getter": 344, "./modules/es7.object.define-setter": 345, "./modules/es7.object.entries": 346, "./modules/es7.object.get-own-property-descriptors": 347, "./modules/es7.object.lookup-getter": 348, "./modules/es7.object.lookup-setter": 349, "./modules/es7.object.values": 350, "./modules/es7.observable": 351, "./modules/es7.reflect.define-metadata": 352, "./modules/es7.reflect.delete-metadata": 353, "./modules/es7.reflect.get-metadata": 355, "./modules/es7.reflect.get-metadata-keys": 354, "./modules/es7.reflect.get-own-metadata": 357, "./modules/es7.reflect.get-own-metadata-keys": 356, "./modules/es7.reflect.has-metadata": 358, "./modules/es7.reflect.has-own-metadata": 359, "./modules/es7.reflect.metadata": 360, "./modules/es7.set.to-json": 361, "./modules/es7.string.at": 362, "./modules/es7.string.match-all": 363, "./modules/es7.string.pad-end": 364, "./modules/es7.string.pad-start": 365, "./modules/es7.string.trim-left": 366, "./modules/es7.string.trim-right": 367, "./modules/es7.symbol.async-iterator": 368, "./modules/es7.symbol.observable": 369, "./modules/es7.system.global": 370, "./modules/web.dom.iterable": 371, "./modules/web.immediate": 372, "./modules/web.timers": 373 }], 375: [function (_dereq_, module, exports) {

      /**
       * Expose `Emitter`.
       */

      module.exports = Emitter;

      /**
       * Initialize a new `Emitter`.
       *
       * @api public
       */

      function Emitter(obj) {
        if (obj) return mixin(obj);
      };

      /**
       * Mixin the emitter properties.
       *
       * @param {Object} obj
       * @return {Object}
       * @api private
       */

      function mixin(obj) {
        for (var key in Emitter.prototype) {
          obj[key] = Emitter.prototype[key];
        }
        return obj;
      }

      /**
       * Listen on the given `event` with `fn`.
       *
       * @param {String} event
       * @param {Function} fn
       * @return {Emitter}
       * @api public
       */

      Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {
        this._callbacks = this._callbacks || {};
        (this._callbacks[event] = this._callbacks[event] || []).push(fn);
        return this;
      };

      /**
       * Adds an `event` listener that will be invoked a single
       * time then automatically removed.
       *
       * @param {String} event
       * @param {Function} fn
       * @return {Emitter}
       * @api public
       */

      Emitter.prototype.once = function (event, fn) {
        var self = this;
        this._callbacks = this._callbacks || {};

        function on() {
          self.off(event, on);
          fn.apply(this, arguments);
        }

        on.fn = fn;
        this.on(event, on);
        return this;
      };

      /**
       * Remove the given callback for `event` or all
       * registered callbacks.
       *
       * @param {String} event
       * @param {Function} fn
       * @return {Emitter}
       * @api public
       */

      Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {
        this._callbacks = this._callbacks || {};

        // all
        if (0 == arguments.length) {
          this._callbacks = {};
          return this;
        }

        // specific event
        var callbacks = this._callbacks[event];
        if (!callbacks) return this;

        // remove all handlers
        if (1 == arguments.length) {
          delete this._callbacks[event];
          return this;
        }

        // remove specific handler
        var cb;
        for (var i = 0; i < callbacks.length; i++) {
          cb = callbacks[i];
          if (cb === fn || cb.fn === fn) {
            callbacks.splice(i, 1);
            break;
          }
        }
        return this;
      };

      /**
       * Emit `event` with the given args.
       *
       * @param {String} event
       * @param {Mixed} ...
       * @return {Emitter}
       */

      Emitter.prototype.emit = function (event) {
        this._callbacks = this._callbacks || {};
        var args = [].slice.call(arguments, 1),
            callbacks = this._callbacks[event];

        if (callbacks) {
          callbacks = callbacks.slice(0);
          for (var i = 0, len = callbacks.length; i < len; ++i) {
            callbacks[i].apply(this, args);
          }
        }

        return this;
      };

      /**
       * Return array of callbacks for `event`.
       *
       * @param {String} event
       * @return {Array}
       * @api public
       */

      Emitter.prototype.listeners = function (event) {
        this._callbacks = this._callbacks || {};
        return this._callbacks[event] || [];
      };

      /**
       * Check if this emitter has `event` handlers.
       *
       * @param {String} event
       * @return {Boolean}
       * @api public
       */

      Emitter.prototype.hasListeners = function (event) {
        return !!this.listeners(event).length;
      };
    }, {}], 376: [function (_dereq_, module, exports) {
      // shim for using process in browser
      var process = module.exports = {};

      // cached from whatever global is present so that test runners that stub it
      // don't break things.  But we need to wrap it in a try catch in case it is
      // wrapped in strict mode code which doesn't define any globals.  It's inside a
      // function because try/catches deoptimize in certain engines.

      var cachedSetTimeout;
      var cachedClearTimeout;

      function defaultSetTimout() {
        throw new Error('setTimeout has not been defined');
      }
      function defaultClearTimeout() {
        throw new Error('clearTimeout has not been defined');
      }
      (function () {
        try {
          if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
          } else {
            cachedSetTimeout = defaultSetTimout;
          }
        } catch (e) {
          cachedSetTimeout = defaultSetTimout;
        }
        try {
          if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
          } else {
            cachedClearTimeout = defaultClearTimeout;
          }
        } catch (e) {
          cachedClearTimeout = defaultClearTimeout;
        }
      })();
      function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
          //normal enviroments in sane situations
          return setTimeout(fun, 0);
        }
        // if setTimeout wasn't available but was latter defined
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
        }
        try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedSetTimeout(fun, 0);
        } catch (e) {
          try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
          } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
          }
        }
      }
      function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
          //normal enviroments in sane situations
          return clearTimeout(marker);
        }
        // if clearTimeout wasn't available but was latter defined
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
        }
        try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedClearTimeout(marker);
        } catch (e) {
          try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
          } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
          }
        }
      }
      var queue = [];
      var draining = false;
      var currentQueue;
      var queueIndex = -1;

      function cleanUpNextTick() {
        if (!draining || !currentQueue) {
          return;
        }
        draining = false;
        if (currentQueue.length) {
          queue = currentQueue.concat(queue);
        } else {
          queueIndex = -1;
        }
        if (queue.length) {
          drainQueue();
        }
      }

      function drainQueue() {
        if (draining) {
          return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;

        var len = queue.length;
        while (len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
            if (currentQueue) {
              currentQueue[queueIndex].run();
            }
          }
          queueIndex = -1;
          len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
      }

      process.nextTick = function (fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
          }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
        }
      };

      // v8 likes predictible objects
      function Item(fun, array) {
        this.fun = fun;
        this.array = array;
      }
      Item.prototype.run = function () {
        this.fun.apply(null, this.array);
      };
      process.title = 'browser';
      process.browser = true;
      process.env = {};
      process.argv = [];
      process.version = ''; // empty string to avoid regexp issues
      process.versions = {};

      function noop() {}

      process.on = noop;
      process.addListener = noop;
      process.once = noop;
      process.off = noop;
      process.removeListener = noop;
      process.removeAllListeners = noop;
      process.emit = noop;

      process.binding = function (name) {
        throw new Error('process.binding is not supported');
      };

      process.cwd = function () {
        return '/';
      };
      process.chdir = function (dir) {
        throw new Error('process.chdir is not supported');
      };
      process.umask = function () {
        return 0;
      };
    }, {}], 377: [function (_dereq_, module, exports) {
      (function (process, global) {
        /**
         * Copyright (c) 2014, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
         * additional grant of patent rights can be found in the PATENTS file in
         * the same directory.
         */

        !function (global) {
          "use strict";

          var Op = Object.prototype;
          var hasOwn = Op.hasOwnProperty;
          var undefined; // More compressible than void 0.
          var $Symbol = typeof Symbol === "function" ? Symbol : {};
          var iteratorSymbol = $Symbol.iterator || "@@iterator";
          var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

          var inModule = (typeof module === "undefined" ? "undefined" : _typeof2(module)) === "object";
          var runtime = global.regeneratorRuntime;
          if (runtime) {
            if (inModule) {
              // If regeneratorRuntime is defined globally and we're in a module,
              // make the exports object identical to regeneratorRuntime.
              module.exports = runtime;
            }
            // Don't bother evaluating the rest of this file if the runtime was
            // already defined globally.
            return;
          }

          // Define the runtime globally (as expected by generated code) as either
          // module.exports (if we're in a module) or a new, empty object.
          runtime = global.regeneratorRuntime = inModule ? module.exports : {};

          function wrap(innerFn, outerFn, self, tryLocsList) {
            // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
            var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
            var generator = Object.create(protoGenerator.prototype);
            var context = new Context(tryLocsList || []);

            // The ._invoke method unifies the implementations of the .next,
            // .throw, and .return methods.
            generator._invoke = makeInvokeMethod(innerFn, self, context);

            return generator;
          }
          runtime.wrap = wrap;

          // Try/catch helper to minimize deoptimizations. Returns a completion
          // record like context.tryEntries[i].completion. This interface could
          // have been (and was previously) designed to take a closure to be
          // invoked without arguments, but in all the cases we care about we
          // already have an existing method we want to call, so there's no need
          // to create a new function object. We can even get away with assuming
          // the method takes exactly one argument, since that happens to be true
          // in every case, so we don't have to touch the arguments object. The
          // only additional allocation required is the completion record, which
          // has a stable shape and so hopefully should be cheap to allocate.
          function tryCatch(fn, obj, arg) {
            try {
              return { type: "normal", arg: fn.call(obj, arg) };
            } catch (err) {
              return { type: "throw", arg: err };
            }
          }

          var GenStateSuspendedStart = "suspendedStart";
          var GenStateSuspendedYield = "suspendedYield";
          var GenStateExecuting = "executing";
          var GenStateCompleted = "completed";

          // Returning this object from the innerFn has the same effect as
          // breaking out of the dispatch switch statement.
          var ContinueSentinel = {};

          // Dummy constructor functions that we use as the .constructor and
          // .constructor.prototype properties for functions that return Generator
          // objects. For full spec compliance, you may wish to configure your
          // minifier not to mangle the names of these two functions.
          function Generator() {}
          function GeneratorFunction() {}
          function GeneratorFunctionPrototype() {}

          // This is a polyfill for %IteratorPrototype% for environments that
          // don't natively support it.
          var IteratorPrototype = {};
          IteratorPrototype[iteratorSymbol] = function () {
            return this;
          };

          var getProto = Object.getPrototypeOf;
          var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
          if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
            // This environment has a native %IteratorPrototype%; use it instead
            // of the polyfill.
            IteratorPrototype = NativeIteratorPrototype;
          }

          var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
          GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
          GeneratorFunctionPrototype.constructor = GeneratorFunction;
          GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";

          // Helper for defining the .next, .throw, and .return methods of the
          // Iterator interface in terms of a single ._invoke method.
          function defineIteratorMethods(prototype) {
            ["next", "throw", "return"].forEach(function (method) {
              prototype[method] = function (arg) {
                return this._invoke(method, arg);
              };
            });
          }

          runtime.isGeneratorFunction = function (genFun) {
            var ctor = typeof genFun === "function" && genFun.constructor;
            return ctor ? ctor === GeneratorFunction ||
            // For the native GeneratorFunction constructor, the best we can
            // do is to check its .name property.
            (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
          };

          runtime.mark = function (genFun) {
            if (Object.setPrototypeOf) {
              Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
            } else {
              genFun.__proto__ = GeneratorFunctionPrototype;
              if (!(toStringTagSymbol in genFun)) {
                genFun[toStringTagSymbol] = "GeneratorFunction";
              }
            }
            genFun.prototype = Object.create(Gp);
            return genFun;
          };

          // Within the body of any async function, `await x` is transformed to
          // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
          // `hasOwn.call(value, "__await")` to determine if the yielded value is
          // meant to be awaited.
          runtime.awrap = function (arg) {
            return { __await: arg };
          };

          function AsyncIterator(generator) {
            function invoke(method, arg, resolve, reject) {
              var record = tryCatch(generator[method], generator, arg);
              if (record.type === "throw") {
                reject(record.arg);
              } else {
                var result = record.arg;
                var value = result.value;
                if (value && (typeof value === "undefined" ? "undefined" : _typeof2(value)) === "object" && hasOwn.call(value, "__await")) {
                  return Promise.resolve(value.__await).then(function (value) {
                    invoke("next", value, resolve, reject);
                  }, function (err) {
                    invoke("throw", err, resolve, reject);
                  });
                }

                return Promise.resolve(value).then(function (unwrapped) {
                  // When a yielded Promise is resolved, its final value becomes
                  // the .value of the Promise<{value,done}> result for the
                  // current iteration. If the Promise is rejected, however, the
                  // result for this iteration will be rejected with the same
                  // reason. Note that rejections of yielded Promises are not
                  // thrown back into the generator function, as is the case
                  // when an awaited Promise is rejected. This difference in
                  // behavior between yield and await is important, because it
                  // allows the consumer to decide what to do with the yielded
                  // rejection (swallow it and continue, manually .throw it back
                  // into the generator, abandon iteration, whatever). With
                  // await, by contrast, there is no opportunity to examine the
                  // rejection reason outside the generator function, so the
                  // only option is to throw it from the await expression, and
                  // let the generator function handle the exception.
                  result.value = unwrapped;
                  resolve(result);
                }, reject);
              }
            }

            if ((typeof process === "undefined" ? "undefined" : _typeof2(process)) === "object" && process.domain) {
              invoke = process.domain.bind(invoke);
            }

            var previousPromise;

            function enqueue(method, arg) {
              function callInvokeWithMethodAndArg() {
                return new Promise(function (resolve, reject) {
                  invoke(method, arg, resolve, reject);
                });
              }

              return previousPromise =
              // If enqueue has been called before, then we want to wait until
              // all previous Promises have been resolved before calling invoke,
              // so that results are always delivered in the correct order. If
              // enqueue has not been called before, then it is important to
              // call invoke immediately, without waiting on a callback to fire,
              // so that the async generator function has the opportunity to do
              // any necessary setup in a predictable way. This predictability
              // is why the Promise constructor synchronously invokes its
              // executor callback, and why async functions synchronously
              // execute code before the first await. Since we implement simple
              // async functions in terms of async generators, it is especially
              // important to get this right, even though it requires care.
              previousPromise ? previousPromise.then(callInvokeWithMethodAndArg,
              // Avoid propagating failures to Promises returned by later
              // invocations of the iterator.
              callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
            }

            // Define the unified helper method that is used to implement .next,
            // .throw, and .return (see defineIteratorMethods).
            this._invoke = enqueue;
          }

          defineIteratorMethods(AsyncIterator.prototype);
          runtime.AsyncIterator = AsyncIterator;

          // Note that simple async functions are implemented on top of
          // AsyncIterator objects; they just return a Promise for the value of
          // the final result produced by the iterator.
          runtime.async = function (innerFn, outerFn, self, tryLocsList) {
            var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));

            return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
            : iter.next().then(function (result) {
              return result.done ? result.value : iter.next();
            });
          };

          function makeInvokeMethod(innerFn, self, context) {
            var state = GenStateSuspendedStart;

            return function invoke(method, arg) {
              if (state === GenStateExecuting) {
                throw new Error("Generator is already running");
              }

              if (state === GenStateCompleted) {
                if (method === "throw") {
                  throw arg;
                }

                // Be forgiving, per 25.3.3.3.3 of the spec:
                // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
                return doneResult();
              }

              context.method = method;
              context.arg = arg;

              while (true) {
                var delegate = context.delegate;
                if (delegate) {
                  var delegateResult = maybeInvokeDelegate(delegate, context);
                  if (delegateResult) {
                    if (delegateResult === ContinueSentinel) continue;
                    return delegateResult;
                  }
                }

                if (context.method === "next") {
                  // Setting context._sent for legacy support of Babel's
                  // function.sent implementation.
                  context.sent = context._sent = context.arg;
                } else if (context.method === "throw") {
                  if (state === GenStateSuspendedStart) {
                    state = GenStateCompleted;
                    throw context.arg;
                  }

                  context.dispatchException(context.arg);
                } else if (context.method === "return") {
                  context.abrupt("return", context.arg);
                }

                state = GenStateExecuting;

                var record = tryCatch(innerFn, self, context);
                if (record.type === "normal") {
                  // If an exception is thrown from innerFn, we leave state ===
                  // GenStateExecuting and loop back for another invocation.
                  state = context.done ? GenStateCompleted : GenStateSuspendedYield;

                  if (record.arg === ContinueSentinel) {
                    continue;
                  }

                  return {
                    value: record.arg,
                    done: context.done
                  };
                } else if (record.type === "throw") {
                  state = GenStateCompleted;
                  // Dispatch the exception by looping back around to the
                  // context.dispatchException(context.arg) call above.
                  context.method = "throw";
                  context.arg = record.arg;
                }
              }
            };
          }

          // Call delegate.iterator[context.method](context.arg) and handle the
          // result, either by returning a { value, done } result from the
          // delegate iterator, or by modifying context.method and context.arg,
          // setting context.delegate to null, and returning the ContinueSentinel.
          function maybeInvokeDelegate(delegate, context) {
            var method = delegate.iterator[context.method];
            if (method === undefined) {
              // A .throw or .return when the delegate iterator has no .throw
              // method always terminates the yield* loop.
              context.delegate = null;

              if (context.method === "throw") {
                if (delegate.iterator.return) {
                  // If the delegate iterator has a return method, give it a
                  // chance to clean up.
                  context.method = "return";
                  context.arg = undefined;
                  maybeInvokeDelegate(delegate, context);

                  if (context.method === "throw") {
                    // If maybeInvokeDelegate(context) changed context.method from
                    // "return" to "throw", let that override the TypeError below.
                    return ContinueSentinel;
                  }
                }

                context.method = "throw";
                context.arg = new TypeError("The iterator does not provide a 'throw' method");
              }

              return ContinueSentinel;
            }

            var record = tryCatch(method, delegate.iterator, context.arg);

            if (record.type === "throw") {
              context.method = "throw";
              context.arg = record.arg;
              context.delegate = null;
              return ContinueSentinel;
            }

            var info = record.arg;

            if (!info) {
              context.method = "throw";
              context.arg = new TypeError("iterator result is not an object");
              context.delegate = null;
              return ContinueSentinel;
            }

            if (info.done) {
              // Assign the result of the finished delegate to the temporary
              // variable specified by delegate.resultName (see delegateYield).
              context[delegate.resultName] = info.value;

              // Resume execution at the desired location (see delegateYield).
              context.next = delegate.nextLoc;

              // If context.method was "throw" but the delegate handled the
              // exception, let the outer generator proceed normally. If
              // context.method was "next", forget context.arg since it has been
              // "consumed" by the delegate iterator. If context.method was
              // "return", allow the original .return call to continue in the
              // outer generator.
              if (context.method !== "return") {
                context.method = "next";
                context.arg = undefined;
              }
            } else {
              // Re-yield the result returned by the delegate method.
              return info;
            }

            // The delegate iterator is finished, so forget it and continue with
            // the outer generator.
            context.delegate = null;
            return ContinueSentinel;
          }

          // Define Generator.prototype.{next,throw,return} in terms of the
          // unified ._invoke helper method.
          defineIteratorMethods(Gp);

          Gp[toStringTagSymbol] = "Generator";

          Gp.toString = function () {
            return "[object Generator]";
          };

          function pushTryEntry(locs) {
            var entry = { tryLoc: locs[0] };

            if (1 in locs) {
              entry.catchLoc = locs[1];
            }

            if (2 in locs) {
              entry.finallyLoc = locs[2];
              entry.afterLoc = locs[3];
            }

            this.tryEntries.push(entry);
          }

          function resetTryEntry(entry) {
            var record = entry.completion || {};
            record.type = "normal";
            delete record.arg;
            entry.completion = record;
          }

          function Context(tryLocsList) {
            // The root entry object (effectively a try statement without a catch
            // or a finally block) gives us a place to store values thrown from
            // locations where there is no enclosing try statement.
            this.tryEntries = [{ tryLoc: "root" }];
            tryLocsList.forEach(pushTryEntry, this);
            this.reset(true);
          }

          runtime.keys = function (object) {
            var keys = [];
            for (var key in object) {
              keys.push(key);
            }
            keys.reverse();

            // Rather than returning an object with a next method, we keep
            // things simple and return the next function itself.
            return function next() {
              while (keys.length) {
                var key = keys.pop();
                if (key in object) {
                  next.value = key;
                  next.done = false;
                  return next;
                }
              }

              // To avoid creating an additional object, we just hang the .value
              // and .done properties off the next function object itself. This
              // also ensures that the minifier will not anonymize the function.
              next.done = true;
              return next;
            };
          };

          function values(iterable) {
            if (iterable) {
              var iteratorMethod = iterable[iteratorSymbol];
              if (iteratorMethod) {
                return iteratorMethod.call(iterable);
              }

              if (typeof iterable.next === "function") {
                return iterable;
              }

              if (!isNaN(iterable.length)) {
                var i = -1,
                    next = function next() {
                  while (++i < iterable.length) {
                    if (hasOwn.call(iterable, i)) {
                      next.value = iterable[i];
                      next.done = false;
                      return next;
                    }
                  }

                  next.value = undefined;
                  next.done = true;

                  return next;
                };

                return next.next = next;
              }
            }

            // Return an iterator with no values.
            return { next: doneResult };
          }
          runtime.values = values;

          function doneResult() {
            return { value: undefined, done: true };
          }

          Context.prototype = {
            constructor: Context,

            reset: function reset(skipTempReset) {
              this.prev = 0;
              this.next = 0;
              // Resetting context._sent for legacy support of Babel's
              // function.sent implementation.
              this.sent = this._sent = undefined;
              this.done = false;
              this.delegate = null;

              this.method = "next";
              this.arg = undefined;

              this.tryEntries.forEach(resetTryEntry);

              if (!skipTempReset) {
                for (var name in this) {
                  // Not sure about the optimal order of these conditions:
                  if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                    this[name] = undefined;
                  }
                }
              }
            },

            stop: function stop() {
              this.done = true;

              var rootEntry = this.tryEntries[0];
              var rootRecord = rootEntry.completion;
              if (rootRecord.type === "throw") {
                throw rootRecord.arg;
              }

              return this.rval;
            },

            dispatchException: function dispatchException(exception) {
              if (this.done) {
                throw exception;
              }

              var context = this;
              function handle(loc, caught) {
                record.type = "throw";
                record.arg = exception;
                context.next = loc;

                if (caught) {
                  // If the dispatched exception was caught by a catch block,
                  // then let that catch block handle the exception normally.
                  context.method = "next";
                  context.arg = undefined;
                }

                return !!caught;
              }

              for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                var entry = this.tryEntries[i];
                var record = entry.completion;

                if (entry.tryLoc === "root") {
                  // Exception thrown outside of any try block that could handle
                  // it, so set the completion value of the entire function to
                  // throw the exception.
                  return handle("end");
                }

                if (entry.tryLoc <= this.prev) {
                  var hasCatch = hasOwn.call(entry, "catchLoc");
                  var hasFinally = hasOwn.call(entry, "finallyLoc");

                  if (hasCatch && hasFinally) {
                    if (this.prev < entry.catchLoc) {
                      return handle(entry.catchLoc, true);
                    } else if (this.prev < entry.finallyLoc) {
                      return handle(entry.finallyLoc);
                    }
                  } else if (hasCatch) {
                    if (this.prev < entry.catchLoc) {
                      return handle(entry.catchLoc, true);
                    }
                  } else if (hasFinally) {
                    if (this.prev < entry.finallyLoc) {
                      return handle(entry.finallyLoc);
                    }
                  } else {
                    throw new Error("try statement without catch or finally");
                  }
                }
              }
            },

            abrupt: function abrupt(type, arg) {
              for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                var entry = this.tryEntries[i];
                if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
                  var finallyEntry = entry;
                  break;
                }
              }

              if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
                // Ignore the finally entry if control is not jumping to a
                // location outside the try/catch block.
                finallyEntry = null;
              }

              var record = finallyEntry ? finallyEntry.completion : {};
              record.type = type;
              record.arg = arg;

              if (finallyEntry) {
                this.method = "next";
                this.next = finallyEntry.finallyLoc;
                return ContinueSentinel;
              }

              return this.complete(record);
            },

            complete: function complete(record, afterLoc) {
              if (record.type === "throw") {
                throw record.arg;
              }

              if (record.type === "break" || record.type === "continue") {
                this.next = record.arg;
              } else if (record.type === "return") {
                this.rval = this.arg = record.arg;
                this.method = "return";
                this.next = "end";
              } else if (record.type === "normal" && afterLoc) {
                this.next = afterLoc;
              }

              return ContinueSentinel;
            },

            finish: function finish(finallyLoc) {
              for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                var entry = this.tryEntries[i];
                if (entry.finallyLoc === finallyLoc) {
                  this.complete(entry.completion, entry.afterLoc);
                  resetTryEntry(entry);
                  return ContinueSentinel;
                }
              }
            },

            "catch": function _catch(tryLoc) {
              for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                var entry = this.tryEntries[i];
                if (entry.tryLoc === tryLoc) {
                  var record = entry.completion;
                  if (record.type === "throw") {
                    var thrown = record.arg;
                    resetTryEntry(entry);
                  }
                  return thrown;
                }
              }

              // The context.catch method must only be called with a location
              // argument that corresponds to a known catch block.
              throw new Error("illegal catch attempt");
            },

            delegateYield: function delegateYield(iterable, resultName, nextLoc) {
              this.delegate = {
                iterator: values(iterable),
                resultName: resultName,
                nextLoc: nextLoc
              };

              if (this.method === "next") {
                // Deliberately forget the last sent value so that we don't
                // accidentally pass it on to the delegate.
                this.arg = undefined;
              }

              return ContinueSentinel;
            }
          };
        }(
        // Among the various tricks for obtaining a reference to the global
        // object, this seems to be the most reliable technique that does not
        // use indirect eval (which violates Content Security Policy).
        (typeof global === "undefined" ? "undefined" : _typeof2(global)) === "object" ? global : (typeof window === "undefined" ? "undefined" : _typeof2(window)) === "object" ? window : (typeof self === "undefined" ? "undefined" : _typeof2(self)) === "object" ? self : this);
      }).call(this, _dereq_('_process'), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, { "_process": 376 }], 378: [function (_dereq_, module, exports) {
      "use strict";

      var Attribute = function () {
        function Attribute() {}
        Attribute.QUALIFIER_PROPERTY = "qualifier";
        Attribute.VALUE = "value";
        return Attribute;
      }();
      exports.__esModule = true;
      exports["default"] = Attribute;
    }, {}], 379: [function (_dereq_, module, exports) {
      "use strict";

      var __extends = undefined && undefined.__extends || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
      var Command_1 = _dereq_("./Command");
      var AttributeCreatedNotification = function (_super) {
        __extends(AttributeCreatedNotification, _super);
        function AttributeCreatedNotification(pmId, attributeId, propertyName, newValue, qualifier) {
          _super.call(this);
          this.pmId = pmId;
          this.attributeId = attributeId;
          this.propertyName = propertyName;
          this.newValue = newValue;
          this.qualifier = qualifier;
          this.id = 'AttributeCreated';
          this.className = "org.opendolphin.core.comm.AttributeCreatedNotification";
        }
        return AttributeCreatedNotification;
      }(Command_1["default"]);
      exports.__esModule = true;
      exports["default"] = AttributeCreatedNotification;
    }, { "./Command": 387 }], 380: [function (_dereq_, module, exports) {
      "use strict";

      var __extends = undefined && undefined.__extends || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
      var Command_1 = _dereq_('./Command');
      var ChangeAttributeMetadataCommand = function (_super) {
        __extends(ChangeAttributeMetadataCommand, _super);
        function ChangeAttributeMetadataCommand(attributeId, metadataName, value) {
          _super.call(this);
          this.attributeId = attributeId;
          this.metadataName = metadataName;
          this.value = value;
          this.id = 'ChangeAttributeMetadata';
          this.className = "org.opendolphin.core.comm.ChangeAttributeMetadataCommand";
        }
        return ChangeAttributeMetadataCommand;
      }(Command_1["default"]);
      exports.__esModule = true;
      exports["default"] = ChangeAttributeMetadataCommand;
    }, { "./Command": 387 }], 381: [function (_dereq_, module, exports) {
      "use strict";

      var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
        return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
      } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
      };

      var EventBus_1 = _dereq_('./EventBus');
      var ClientAttribute = function () {
        function ClientAttribute(propertyName, qualifier, value) {
          this.propertyName = propertyName;
          this.id = "" + ClientAttribute.clientAttributeInstanceCount++ + "C";
          this.valueChangeBus = new EventBus_1["default"]();
          this.qualifierChangeBus = new EventBus_1["default"]();
          this.setValue(value);
          this.setQualifier(qualifier);
        }
        /** a copy constructor with new id and no presentation model */
        ClientAttribute.prototype.copy = function () {
          var result = new ClientAttribute(this.propertyName, this.getQualifier(), this.getValue());
          return result;
        };
        ClientAttribute.prototype.setPresentationModel = function (presentationModel) {
          if (this.presentationModel) {
            alert("You can not set a presentation model for an attribute that is already bound.");
          }
          this.presentationModel = presentationModel;
        };
        ClientAttribute.prototype.getPresentationModel = function () {
          return this.presentationModel;
        };
        ClientAttribute.prototype.getValue = function () {
          return this.value;
        };
        ClientAttribute.prototype.setValue = function (newValue) {
          var verifiedValue = ClientAttribute.checkValue(newValue);
          if (this.value == verifiedValue) return;
          var oldValue = this.value;
          this.value = verifiedValue;
          this.valueChangeBus.trigger({ 'oldValue': oldValue, 'newValue': verifiedValue });
        };
        ClientAttribute.prototype.setQualifier = function (newQualifier) {
          if (this.qualifier == newQualifier) return;
          var oldQualifier = this.qualifier;
          this.qualifier = newQualifier;
          this.qualifierChangeBus.trigger({ 'oldValue': oldQualifier, 'newValue': newQualifier });
        };
        ClientAttribute.prototype.getQualifier = function () {
          return this.qualifier;
        };
        ClientAttribute.checkValue = function (value) {
          if (value == null || value == undefined) {
            return null;
          }
          var result = value;
          if (result instanceof String || result instanceof Boolean || result instanceof Number) {
            result = value.valueOf();
          }
          if (result instanceof ClientAttribute) {
            console.log("An Attribute may not itself contain an attribute as a value. Assuming you forgot to call value.");
            result = this.checkValue(value.value);
          }
          var ok = false;
          if (this.SUPPORTED_VALUE_TYPES.indexOf(typeof result === "undefined" ? "undefined" : _typeof(result)) > -1 || result instanceof Date) {
            ok = true;
          }
          if (!ok) {
            throw new Error("Attribute values of this type are not allowed: " + (typeof value === "undefined" ? "undefined" : _typeof(value)));
          }
          return result;
        };
        ClientAttribute.prototype.onValueChange = function (eventHandler) {
          this.valueChangeBus.onEvent(eventHandler);
          eventHandler({ "oldValue": this.value, "newValue": this.value });
        };
        ClientAttribute.prototype.onQualifierChange = function (eventHandler) {
          this.qualifierChangeBus.onEvent(eventHandler);
        };
        ClientAttribute.prototype.syncWith = function (sourceAttribute) {
          if (sourceAttribute) {
            this.setQualifier(sourceAttribute.getQualifier()); // sequence is important
            this.setValue(sourceAttribute.value);
          }
        };
        ClientAttribute.SUPPORTED_VALUE_TYPES = ["string", "number", "boolean"];
        ClientAttribute.clientAttributeInstanceCount = 0;
        return ClientAttribute;
      }();
      exports.ClientAttribute = ClientAttribute;
    }, { "./EventBus": 394 }], 382: [function (_dereq_, module, exports) {
      "use strict";

      var ClientAttribute_1 = _dereq_("./ClientAttribute");
      var ClientPresentationModel_1 = _dereq_("./ClientPresentationModel");
      var Codec_1 = _dereq_("./Codec");
      var CommandBatcher_1 = _dereq_("./CommandBatcher");
      var ClientConnector = function () {
        function ClientConnector(transmitter, clientDolphin, slackMS, maxBatchSize) {
          if (slackMS === void 0) {
            slackMS = 0;
          }
          if (maxBatchSize === void 0) {
            maxBatchSize = 50;
          }
          this.commandQueue = [];
          this.currentlySending = false;
          this.pushEnabled = false;
          this.waiting = false;
          this.transmitter = transmitter;
          this.clientDolphin = clientDolphin;
          this.slackMS = slackMS;
          this.codec = new Codec_1["default"]();
          this.commandBatcher = new CommandBatcher_1.BlindCommandBatcher(true, maxBatchSize);
        }
        ClientConnector.prototype.setCommandBatcher = function (newBatcher) {
          this.commandBatcher = newBatcher;
        };
        ClientConnector.prototype.setPushEnabled = function (enabled) {
          this.pushEnabled = enabled;
        };
        ClientConnector.prototype.setPushListener = function (newListener) {
          this.pushListener = newListener;
        };
        ClientConnector.prototype.setReleaseCommand = function (newCommand) {
          this.releaseCommand = newCommand;
        };
        ClientConnector.prototype.reset = function (successHandler) {
          this.transmitter.reset(successHandler);
        };
        ClientConnector.prototype.send = function (command, onFinished) {
          this.commandQueue.push({ command: command, handler: onFinished });
          if (this.currentlySending) {
            this.release(); // there is not point in releasing if we do not send atm
            return;
          }
          this.doSendNext();
        };
        ClientConnector.prototype.doSendNext = function () {
          var _this = this;
          if (this.commandQueue.length < 1) {
            if (this.pushEnabled) {
              this.enqueuePushCommand();
            } else {
              this.currentlySending = false;
              return;
            }
          }
          this.currentlySending = true;
          var cmdsAndHandlers = this.commandBatcher.batch(this.commandQueue);
          var callback = cmdsAndHandlers[cmdsAndHandlers.length - 1].handler;
          var commands = cmdsAndHandlers.map(function (cah) {
            return cah.command;
          });
          this.transmitter.transmit(commands, function (response) {
            //console.log("server response: [" + response.map(it => it.id).join(", ") + "] ");
            var touchedPMs = [];
            response.forEach(function (command) {
              var touched = _this.handle(command);
              if (touched) touchedPMs.push(touched);
            });
            if (callback) {
              callback.onFinished(touchedPMs); // todo: make them unique?
            }
            // recursive call: fetch the next in line but allow a bit of slack such that
            // document events can fire, rendering is done and commands can batch up
            setTimeout(function () {
              return _this.doSendNext();
            }, _this.slackMS);
          });
        };
        ClientConnector.prototype.handle = function (command) {
          if (command.id == "Data") {
            return this.handleDataCommand(command);
          } else if (command.id == "DeletePresentationModel") {
            return this.handleDeletePresentationModelCommand(command);
          } else if (command.id == "DeleteAllPresentationModelsOfType") {
            return this.handleDeleteAllPresentationModelOfTypeCommand(command);
          } else if (command.id == "CreatePresentationModel") {
            return this.handleCreatePresentationModelCommand(command);
          } else if (command.id == "ValueChanged") {
            return this.handleValueChangedCommand(command);
          } else if (command.id == "SwitchPresentationModel") {
            return this.handleSwitchPresentationModelCommand(command);
          } else if (command.id == "InitializeAttribute") {
            return this.handleInitializeAttributeCommand(command);
          } else if (command.id == "AttributeMetadataChanged") {
            return this.handleAttributeMetadataChangedCommand(command);
          } else if (command.id == "CallNamedAction") {
            return this.handleCallNamedActionCommand(command);
          } else {
            console.log("Cannot handle, unknown command " + command);
          }
          return null;
        };
        ClientConnector.prototype.handleDataCommand = function (serverCommand) {
          return serverCommand.data;
        };
        ClientConnector.prototype.handleDeletePresentationModelCommand = function (serverCommand) {
          var model = this.clientDolphin.findPresentationModelById(serverCommand.pmId);
          if (!model) return null;
          this.clientDolphin.getClientModelStore().deletePresentationModel(model, true);
          return model;
        };
        ClientConnector.prototype.handleDeleteAllPresentationModelOfTypeCommand = function (serverCommand) {
          this.clientDolphin.deleteAllPresentationModelOfType(serverCommand.pmType);
          return null;
        };
        ClientConnector.prototype.handleCreatePresentationModelCommand = function (serverCommand) {
          var _this = this;
          if (this.clientDolphin.getClientModelStore().containsPresentationModel(serverCommand.pmId)) {
            throw new Error("There already is a presentation model with id " + serverCommand.pmId + "  known to the client.");
          }
          var attributes = [];
          serverCommand.attributes.forEach(function (attr) {
            var clientAttribute = _this.clientDolphin.attribute(attr.propertyName, attr.qualifier, attr.value);
            if (attr.id && attr.id.match(".*S$")) {
              clientAttribute.id = attr.id;
            }
            attributes.push(clientAttribute);
          });
          var clientPm = new ClientPresentationModel_1.ClientPresentationModel(serverCommand.pmId, serverCommand.pmType);
          clientPm.addAttributes(attributes);
          if (serverCommand.clientSideOnly) {
            clientPm.clientSideOnly = true;
          }
          this.clientDolphin.getClientModelStore().add(clientPm);
          this.clientDolphin.updatePresentationModelQualifier(clientPm);
          return clientPm;
        };
        ClientConnector.prototype.handleValueChangedCommand = function (serverCommand) {
          var clientAttribute = this.clientDolphin.getClientModelStore().findAttributeById(serverCommand.attributeId);
          if (!clientAttribute) {
            console.log("attribute with id " + serverCommand.attributeId + " not found, cannot update old value " + serverCommand.oldValue + " to new value " + serverCommand.newValue);
            return null;
          }
          if (clientAttribute.getValue() == serverCommand.newValue) {
            //console.log("nothing to do. new value == old value");
            return null;
          }
          // Below was the code that would enforce that value changes only appear when the proper oldValue is given.
          // While that seemed appropriate at first, there are actually valid command sequences where the oldValue is not properly set.
          // We leave the commented code in the codebase to allow for logging/debugging such cases.
          //            if(clientAttribute.getValue() != serverCommand.oldValue) {
          //                console.log("attribute with id "+serverCommand.attributeId+" and value " + clientAttribute.getValue() +
          //                            " was set to value " + serverCommand.newValue + " even though the change was based on an outdated old value of " + serverCommand.oldValue);
          //            }
          clientAttribute.setValue(serverCommand.newValue);
          return null;
        };
        ClientConnector.prototype.handleSwitchPresentationModelCommand = function (serverCommand) {
          var switchPm = this.clientDolphin.getClientModelStore().findPresentationModelById(serverCommand.pmId);
          if (!switchPm) {
            console.log("switch model with id " + serverCommand.pmId + " not found, cannot switch.");
            return null;
          }
          var sourcePm = this.clientDolphin.getClientModelStore().findPresentationModelById(serverCommand.sourcePmId);
          if (!sourcePm) {
            console.log("source model with id " + serverCommand.sourcePmId + " not found, cannot switch.");
            return null;
          }
          switchPm.syncWith(sourcePm);
          return switchPm;
        };
        ClientConnector.prototype.handleInitializeAttributeCommand = function (serverCommand) {
          var attribute = new ClientAttribute_1.ClientAttribute(serverCommand.propertyName, serverCommand.qualifier, serverCommand.newValue);
          if (serverCommand.qualifier) {
            var attributesCopy = this.clientDolphin.getClientModelStore().findAllAttributesByQualifier(serverCommand.qualifier);
            if (attributesCopy) {
              if (!serverCommand.newValue) {
                var attr = attributesCopy.shift();
                if (attr) {
                  attribute.setValue(attr.getValue());
                }
              } else {
                attributesCopy.forEach(function (attr) {
                  attr.setValue(attribute.getValue());
                });
              }
            }
          }
          var presentationModel;
          if (serverCommand.pmId) {
            presentationModel = this.clientDolphin.getClientModelStore().findPresentationModelById(serverCommand.pmId);
          }
          if (!presentationModel) {
            presentationModel = new ClientPresentationModel_1.ClientPresentationModel(serverCommand.pmId, serverCommand.pmType);
            this.clientDolphin.getClientModelStore().add(presentationModel);
          }
          this.clientDolphin.addAttributeToModel(presentationModel, attribute);
          this.clientDolphin.updatePresentationModelQualifier(presentationModel);
          return presentationModel;
        };
        ClientConnector.prototype.handleAttributeMetadataChangedCommand = function (serverCommand) {
          var clientAttribute = this.clientDolphin.getClientModelStore().findAttributeById(serverCommand.attributeId);
          if (!clientAttribute) return null;
          clientAttribute[serverCommand.metadataName] = serverCommand.value;
          return null;
        };
        ClientConnector.prototype.handleCallNamedActionCommand = function (serverCommand) {
          this.clientDolphin.send(serverCommand.actionName, null);
          return null;
        };
        ///////////// push support ///////////////
        ClientConnector.prototype.listen = function () {
          if (!this.pushEnabled) return;
          if (this.waiting) return;
          // todo: how to issue a warning if no pushListener is set?
          if (!this.currentlySending) {
            this.doSendNext();
          }
        };
        ClientConnector.prototype.enqueuePushCommand = function () {
          var me = this;
          this.waiting = true;
          this.commandQueue.push({
            command: this.pushListener,
            handler: {
              onFinished: function onFinished(models) {
                me.waiting = false;
              },
              onFinishedData: null
            }
          });
        };
        ClientConnector.prototype.release = function () {
          if (!this.waiting) return;
          this.waiting = false;
          // todo: how to issue a warning if no releaseCommand is set?
          this.transmitter.signal(this.releaseCommand);
        };
        return ClientConnector;
      }();
      exports.ClientConnector = ClientConnector;
    }, { "./ClientAttribute": 381, "./ClientPresentationModel": 385, "./Codec": 386, "./CommandBatcher": 388 }], 383: [function (_dereq_, module, exports) {
      "use strict";

      var AttributeCreatedNotification_1 = _dereq_("./AttributeCreatedNotification");
      var ClientAttribute_1 = _dereq_("./ClientAttribute");
      var ClientPresentationModel_1 = _dereq_("./ClientPresentationModel");
      var EmptyNotification_1 = _dereq_("./EmptyNotification");
      var NamedCommand_1 = _dereq_("./NamedCommand");
      var SignalCommand_1 = _dereq_("./SignalCommand");
      var ClientDolphin = function () {
        function ClientDolphin() {}
        ClientDolphin.prototype.setClientConnector = function (clientConnector) {
          this.clientConnector = clientConnector;
        };
        ClientDolphin.prototype.getClientConnector = function () {
          return this.clientConnector;
        };
        ClientDolphin.prototype.send = function (commandName, onFinished) {
          this.clientConnector.send(new NamedCommand_1["default"](commandName), onFinished);
        };
        ClientDolphin.prototype.reset = function (successHandler) {
          this.clientConnector.reset(successHandler);
        };
        ClientDolphin.prototype.sendEmpty = function (onFinished) {
          this.clientConnector.send(new EmptyNotification_1["default"](), onFinished);
        };
        // factory method for attributes
        ClientDolphin.prototype.attribute = function (propertyName, qualifier, value) {
          return new ClientAttribute_1.ClientAttribute(propertyName, qualifier, value);
        };
        // factory method for presentation models
        ClientDolphin.prototype.presentationModel = function (id, type) {
          var attributes = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            attributes[_i - 2] = arguments[_i];
          }
          var model = new ClientPresentationModel_1.ClientPresentationModel(id, type);
          if (attributes && attributes.length > 0) {
            attributes.forEach(function (attribute) {
              model.addAttribute(attribute);
            });
          }
          this.getClientModelStore().add(model);
          return model;
        };
        ClientDolphin.prototype.setClientModelStore = function (clientModelStore) {
          this.clientModelStore = clientModelStore;
        };
        ClientDolphin.prototype.getClientModelStore = function () {
          return this.clientModelStore;
        };
        ClientDolphin.prototype.listPresentationModelIds = function () {
          return this.getClientModelStore().listPresentationModelIds();
        };
        ClientDolphin.prototype.listPresentationModels = function () {
          return this.getClientModelStore().listPresentationModels();
        };
        ClientDolphin.prototype.findAllPresentationModelByType = function (presentationModelType) {
          return this.getClientModelStore().findAllPresentationModelByType(presentationModelType);
        };
        ClientDolphin.prototype.getAt = function (id) {
          return this.findPresentationModelById(id);
        };
        ClientDolphin.prototype.findPresentationModelById = function (id) {
          return this.getClientModelStore().findPresentationModelById(id);
        };
        ClientDolphin.prototype.deletePresentationModel = function (modelToDelete) {
          this.getClientModelStore().deletePresentationModel(modelToDelete, true);
        };
        ClientDolphin.prototype.deleteAllPresentationModelOfType = function (presentationModelType) {
          this.getClientModelStore().deleteAllPresentationModelOfType(presentationModelType);
        };
        ClientDolphin.prototype.updatePresentationModelQualifier = function (presentationModel) {
          var _this = this;
          presentationModel.getAttributes().forEach(function (sourceAttribute) {
            _this.updateAttributeQualifier(sourceAttribute);
          });
        };
        ClientDolphin.prototype.updateAttributeQualifier = function (sourceAttribute) {
          if (!sourceAttribute.getQualifier()) return;
          var attributes = this.getClientModelStore().findAllAttributesByQualifier(sourceAttribute.getQualifier());
          attributes.forEach(function (targetAttribute) {
            targetAttribute.setValue(sourceAttribute.getValue()); // should always have the same value
          });
        };
        ClientDolphin.prototype.addAttributeToModel = function (presentationModel, clientAttribute) {
          presentationModel.addAttribute(clientAttribute);
          this.getClientModelStore().registerAttribute(clientAttribute);
          if (!presentationModel.clientSideOnly) {
            this.clientConnector.send(new AttributeCreatedNotification_1["default"](presentationModel.id, clientAttribute.id, clientAttribute.propertyName, clientAttribute.getValue(), clientAttribute.getQualifier()), null);
          }
        };
        ////// push support ///////
        ClientDolphin.prototype.startPushListening = function (pushActionName, releaseActionName) {
          this.clientConnector.setPushListener(new NamedCommand_1["default"](pushActionName));
          this.clientConnector.setReleaseCommand(new SignalCommand_1["default"](releaseActionName));
          this.clientConnector.setPushEnabled(true);
          this.clientConnector.listen();
        };
        ClientDolphin.prototype.stopPushListening = function () {
          this.clientConnector.setPushEnabled(false);
        };
        return ClientDolphin;
      }();
      exports.__esModule = true;
      exports["default"] = ClientDolphin;
    }, { "./AttributeCreatedNotification": 379, "./ClientAttribute": 381, "./ClientPresentationModel": 385, "./EmptyNotification": 393, "./NamedCommand": 396, "./SignalCommand": 399 }], 384: [function (_dereq_, module, exports) {
      /// <reference path="./core-js.d.ts" />
      "use strict";

      var Attribute_1 = _dereq_("./Attribute");
      var ChangeAttributeMetadataCommand_1 = _dereq_("./ChangeAttributeMetadataCommand");
      var CreatePresentationModelCommand_1 = _dereq_("./CreatePresentationModelCommand");
      var DeletedAllPresentationModelsOfTypeNotification_1 = _dereq_("./DeletedAllPresentationModelsOfTypeNotification");
      var DeletedPresentationModelNotification_1 = _dereq_("./DeletedPresentationModelNotification");
      var EventBus_1 = _dereq_("./EventBus");
      var ValueChangedCommand_1 = _dereq_("./ValueChangedCommand");
      (function (Type) {
        Type[Type["ADDED"] = 'ADDED'] = "ADDED";
        Type[Type["REMOVED"] = 'REMOVED'] = "REMOVED";
      })(exports.Type || (exports.Type = {}));
      var Type = exports.Type;
      var ClientModelStore = function () {
        function ClientModelStore(clientDolphin) {
          this.clientDolphin = clientDolphin;
          this.presentationModels = new Map();
          this.presentationModelsPerType = new Map();
          this.attributesPerId = new Map();
          this.attributesPerQualifier = new Map();
          this.modelStoreChangeBus = new EventBus_1["default"]();
        }
        ClientModelStore.prototype.getClientDolphin = function () {
          return this.clientDolphin;
        };
        ClientModelStore.prototype.registerModel = function (model) {
          var _this = this;
          if (model.clientSideOnly) {
            return;
          }
          var connector = this.clientDolphin.getClientConnector();
          var createPMCommand = new CreatePresentationModelCommand_1["default"](model);
          connector.send(createPMCommand, null);
          model.getAttributes().forEach(function (attribute) {
            _this.registerAttribute(attribute);
          });
        };
        ClientModelStore.prototype.registerAttribute = function (attribute) {
          var _this = this;
          this.addAttributeById(attribute);
          if (attribute.getQualifier()) {
            this.addAttributeByQualifier(attribute);
          }
          // whenever an attribute changes its value, the server needs to be notified
          // and all other attributes with the same qualifier are given the same value
          attribute.onValueChange(function (evt) {
            var valueChangeCommand = new ValueChangedCommand_1["default"](attribute.id, evt.oldValue, evt.newValue);
            _this.clientDolphin.getClientConnector().send(valueChangeCommand, null);
            if (attribute.getQualifier()) {
              var attrs = _this.findAttributesByFilter(function (attr) {
                return attr !== attribute && attr.getQualifier() == attribute.getQualifier();
              });
              attrs.forEach(function (attr) {
                attr.setValue(attribute.getValue());
              });
            }
          });
          attribute.onQualifierChange(function (evt) {
            var changeAttrMetadataCmd = new ChangeAttributeMetadataCommand_1["default"](attribute.id, Attribute_1["default"].QUALIFIER_PROPERTY, evt.newValue);
            _this.clientDolphin.getClientConnector().send(changeAttrMetadataCmd, null);
          });
        };
        ClientModelStore.prototype.add = function (model) {
          if (!model) {
            return false;
          }
          if (this.presentationModels.has(model.id)) {
            console.log("There already is a PM with id " + model.id);
          }
          var added = false;
          if (!this.presentationModels.has(model.id)) {
            this.presentationModels.set(model.id, model);
            this.addPresentationModelByType(model);
            this.registerModel(model);
            this.modelStoreChangeBus.trigger({ 'eventType': Type.ADDED, 'clientPresentationModel': model });
            added = true;
          }
          return added;
        };
        ClientModelStore.prototype.remove = function (model) {
          var _this = this;
          if (!model) {
            return false;
          }
          var removed = false;
          if (this.presentationModels.has(model.id)) {
            this.removePresentationModelByType(model);
            this.presentationModels.delete(model.id);
            model.getAttributes().forEach(function (attribute) {
              _this.removeAttributeById(attribute);
              if (attribute.getQualifier()) {
                _this.removeAttributeByQualifier(attribute);
              }
            });
            this.modelStoreChangeBus.trigger({ 'eventType': Type.REMOVED, 'clientPresentationModel': model });
            removed = true;
          }
          return removed;
        };
        ClientModelStore.prototype.findAttributesByFilter = function (filter) {
          var matches = [];
          this.presentationModels.forEach(function (model) {
            model.getAttributes().forEach(function (attr) {
              if (filter(attr)) {
                matches.push(attr);
              }
            });
          });
          return matches;
        };
        ClientModelStore.prototype.addPresentationModelByType = function (model) {
          if (!model) {
            return;
          }
          var type = model.presentationModelType;
          if (!type) {
            return;
          }
          var presentationModels = this.presentationModelsPerType.get(type);
          if (!presentationModels) {
            presentationModels = [];
            this.presentationModelsPerType.set(type, presentationModels);
          }
          if (!(presentationModels.indexOf(model) > -1)) {
            presentationModels.push(model);
          }
        };
        ClientModelStore.prototype.removePresentationModelByType = function (model) {
          if (!model || !model.presentationModelType) {
            return;
          }
          var presentationModels = this.presentationModelsPerType.get(model.presentationModelType);
          if (!presentationModels) {
            return;
          }
          if (presentationModels.length > -1) {
            presentationModels.splice(presentationModels.indexOf(model), 1);
          }
          if (presentationModels.length === 0) {
            this.presentationModelsPerType.delete(model.presentationModelType);
          }
        };
        ClientModelStore.prototype.listPresentationModelIds = function () {
          var result = [];
          var iter = this.presentationModels.keys();
          var next = iter.next();
          while (!next.done) {
            result.push(next.value);
            next = iter.next();
          }
          return result;
        };
        ClientModelStore.prototype.listPresentationModels = function () {
          var result = [];
          var iter = this.presentationModels.values();
          var next = iter.next();
          while (!next.done) {
            result.push(next.value);
            next = iter.next();
          }
          return result;
        };
        ClientModelStore.prototype.findPresentationModelById = function (id) {
          return this.presentationModels.get(id);
        };
        ClientModelStore.prototype.findAllPresentationModelByType = function (type) {
          if (!type || !this.presentationModelsPerType.has(type)) {
            return [];
          }
          return this.presentationModelsPerType.get(type).slice(0); // slice is used to clone the array
        };
        ClientModelStore.prototype.deleteAllPresentationModelOfType = function (presentationModelType) {
          var _this = this;
          var presentationModels = this.findAllPresentationModelByType(presentationModelType);
          presentationModels.forEach(function (pm) {
            _this.deletePresentationModel(pm, false);
          });
          this.clientDolphin.getClientConnector().send(new DeletedAllPresentationModelsOfTypeNotification_1["default"](presentationModelType), undefined);
        };
        ClientModelStore.prototype.deletePresentationModel = function (model, notify) {
          if (!model) {
            return;
          }
          if (this.containsPresentationModel(model.id)) {
            this.remove(model);
            if (!notify || model.clientSideOnly) {
              return;
            }
            this.clientDolphin.getClientConnector().send(new DeletedPresentationModelNotification_1["default"](model.id), null);
          }
        };
        ClientModelStore.prototype.containsPresentationModel = function (id) {
          return this.presentationModels.has(id);
        };
        ClientModelStore.prototype.addAttributeById = function (attribute) {
          if (!attribute || this.attributesPerId.has(attribute.id)) {
            return;
          }
          this.attributesPerId.set(attribute.id, attribute);
        };
        ClientModelStore.prototype.removeAttributeById = function (attribute) {
          if (!attribute || !this.attributesPerId.has(attribute.id)) {
            return;
          }
          this.attributesPerId.delete(attribute.id);
        };
        ClientModelStore.prototype.findAttributeById = function (id) {
          return this.attributesPerId.get(id);
        };
        ClientModelStore.prototype.addAttributeByQualifier = function (attribute) {
          if (!attribute || !attribute.getQualifier()) {
            return;
          }
          var attributes = this.attributesPerQualifier.get(attribute.getQualifier());
          if (!attributes) {
            attributes = [];
            this.attributesPerQualifier.set(attribute.getQualifier(), attributes);
          }
          if (!(attributes.indexOf(attribute) > -1)) {
            attributes.push(attribute);
          }
        };
        ClientModelStore.prototype.removeAttributeByQualifier = function (attribute) {
          if (!attribute || !attribute.getQualifier()) {
            return;
          }
          var attributes = this.attributesPerQualifier.get(attribute.getQualifier());
          if (!attributes) {
            return;
          }
          if (attributes.length > -1) {
            attributes.splice(attributes.indexOf(attribute), 1);
          }
          if (attributes.length === 0) {
            this.attributesPerQualifier.delete(attribute.getQualifier());
          }
        };
        ClientModelStore.prototype.findAllAttributesByQualifier = function (qualifier) {
          if (!qualifier || !this.attributesPerQualifier.has(qualifier)) {
            return [];
          }
          return this.attributesPerQualifier.get(qualifier).slice(0); // slice is used to clone the array
        };
        ClientModelStore.prototype.onModelStoreChange = function (eventHandler) {
          this.modelStoreChangeBus.onEvent(eventHandler);
        };
        ClientModelStore.prototype.onModelStoreChangeForType = function (presentationModelType, eventHandler) {
          this.modelStoreChangeBus.onEvent(function (pmStoreEvent) {
            if (pmStoreEvent.clientPresentationModel.presentationModelType == presentationModelType) {
              eventHandler(pmStoreEvent);
            }
          });
        };
        return ClientModelStore;
      }();
      exports.ClientModelStore = ClientModelStore;
    }, { "./Attribute": 378, "./ChangeAttributeMetadataCommand": 380, "./CreatePresentationModelCommand": 389, "./DeletedAllPresentationModelsOfTypeNotification": 390, "./DeletedPresentationModelNotification": 391, "./EventBus": 394, "./ValueChangedCommand": 400 }], 385: [function (_dereq_, module, exports) {
      "use strict";

      var EventBus_1 = _dereq_('./EventBus');
      var presentationModelInstanceCount = 0; // todo dk: consider making this static in class
      var ClientPresentationModel = function () {
        function ClientPresentationModel(id, presentationModelType) {
          this.id = id;
          this.presentationModelType = presentationModelType;
          this.attributes = [];
          this.clientSideOnly = false;
          this.dirty = false;
          if (typeof id !== 'undefined' && id != null) {
            this.id = id;
          } else {
            this.id = (presentationModelInstanceCount++).toString();
          }
          this.invalidBus = new EventBus_1["default"]();
          this.dirtyValueChangeBus = new EventBus_1["default"]();
        }
        // todo dk: align with Java version: move to ClientDolphin and auto-add to model store
        /** a copy constructor for anything but IDs. Per default, copies are client side only, no automatic update applies. */
        ClientPresentationModel.prototype.copy = function () {
          var result = new ClientPresentationModel(null, this.presentationModelType);
          result.clientSideOnly = true;
          this.getAttributes().forEach(function (attribute) {
            var attributeCopy = attribute.copy();
            result.addAttribute(attributeCopy);
          });
          return result;
        };
        //add array of attributes
        ClientPresentationModel.prototype.addAttributes = function (attributes) {
          var _this = this;
          if (!attributes || attributes.length < 1) return;
          attributes.forEach(function (attr) {
            _this.addAttribute(attr);
          });
        };
        ClientPresentationModel.prototype.addAttribute = function (attribute) {
          var _this = this;
          if (!attribute || this.attributes.indexOf(attribute) > -1) {
            return;
          }
          if (this.findAttributeByPropertyName(attribute.propertyName)) {
            throw new Error("There already is an attribute with property name: " + attribute.propertyName + " in presentation model with id: " + this.id);
          }
          if (attribute.getQualifier() && this.findAttributeByQualifier(attribute.getQualifier())) {
            throw new Error("There already is an attribute with qualifier: " + attribute.getQualifier() + " in presentation model with id: " + this.id);
          }
          attribute.setPresentationModel(this);
          this.attributes.push(attribute);
          attribute.onValueChange(function (evt) {
            _this.invalidBus.trigger({ source: _this });
          });
        };
        ClientPresentationModel.prototype.onInvalidated = function (handleInvalidate) {
          this.invalidBus.onEvent(handleInvalidate);
        };
        /** returns a copy of the internal state */
        ClientPresentationModel.prototype.getAttributes = function () {
          return this.attributes.slice(0);
        };
        ClientPresentationModel.prototype.getAt = function (propertyName) {
          return this.findAttributeByPropertyName(propertyName);
        };
        ClientPresentationModel.prototype.findAllAttributesByPropertyName = function (propertyName) {
          var result = [];
          if (!propertyName) return null;
          this.attributes.forEach(function (attribute) {
            if (attribute.propertyName == propertyName) {
              result.push(attribute);
            }
          });
          return result;
        };
        ClientPresentationModel.prototype.findAttributeByPropertyName = function (propertyName) {
          if (!propertyName) return null;
          for (var i = 0; i < this.attributes.length; i++) {
            if (this.attributes[i].propertyName == propertyName) {
              return this.attributes[i];
            }
          }
          return null;
        };
        ClientPresentationModel.prototype.findAttributeByQualifier = function (qualifier) {
          if (!qualifier) return null;
          for (var i = 0; i < this.attributes.length; i++) {
            if (this.attributes[i].getQualifier() == qualifier) {
              return this.attributes[i];
            }
          }
          ;
          return null;
        };
        ClientPresentationModel.prototype.findAttributeById = function (id) {
          if (!id) return null;
          for (var i = 0; i < this.attributes.length; i++) {
            if (this.attributes[i].id == id) {
              return this.attributes[i];
            }
          }
          ;
          return null;
        };
        ClientPresentationModel.prototype.syncWith = function (sourcePresentationModel) {
          this.attributes.forEach(function (targetAttribute) {
            var sourceAttribute = sourcePresentationModel.getAt(targetAttribute.propertyName);
            if (sourceAttribute) {
              targetAttribute.syncWith(sourceAttribute);
            }
          });
        };
        return ClientPresentationModel;
      }();
      exports.ClientPresentationModel = ClientPresentationModel;
    }, { "./EventBus": 394 }], 386: [function (_dereq_, module, exports) {
      "use strict";

      var Codec = function () {
        function Codec() {}
        Codec.prototype.encode = function (commands) {
          return JSON.stringify(commands); // todo dk: look for possible API support for character encoding
        };
        Codec.prototype.decode = function (transmitted) {
          if (typeof transmitted == 'string') {
            return JSON.parse(transmitted);
          } else {
            return transmitted;
          }
        };
        return Codec;
      }();
      exports.__esModule = true;
      exports["default"] = Codec;
    }, {}], 387: [function (_dereq_, module, exports) {
      "use strict";

      var Command = function () {
        function Command() {
          this.id = "dolphin-core-command";
        }
        return Command;
      }();
      exports.__esModule = true;
      exports["default"] = Command;
    }, {}], 388: [function (_dereq_, module, exports) {
      "use strict";

      var ValueChangedCommand_1 = _dereq_('./ValueChangedCommand');
      /** A Batcher that does no batching but merely takes the first element of the queue as the single item in the batch */
      var NoCommandBatcher = function () {
        function NoCommandBatcher() {}
        NoCommandBatcher.prototype.batch = function (queue) {
          return [queue.shift()];
        };
        return NoCommandBatcher;
      }();
      exports.NoCommandBatcher = NoCommandBatcher;
      /** A batcher that batches the blinds (commands with no callback) and optionally also folds value changes */
      var BlindCommandBatcher = function () {
        /** folding: whether we should try folding ValueChangedCommands */
        function BlindCommandBatcher(folding, maxBatchSize) {
          if (folding === void 0) {
            folding = true;
          }
          if (maxBatchSize === void 0) {
            maxBatchSize = 50;
          }
          this.folding = folding;
          this.maxBatchSize = maxBatchSize;
        }
        BlindCommandBatcher.prototype.batch = function (queue) {
          var batch = [];
          var n = Math.min(queue.length, this.maxBatchSize);
          for (var counter = 0; counter < n; counter++) {
            var candidate = queue.shift();
            if (this.folding && candidate.command instanceof ValueChangedCommand_1["default"] && !candidate.handler) {
              var found = null;
              var canCmd = candidate.command;
              for (var i = 0; i < batch.length && found == null; i++) {
                if (batch[i].command instanceof ValueChangedCommand_1["default"]) {
                  var batchCmd = batch[i].command;
                  if (canCmd.attributeId == batchCmd.attributeId && batchCmd.newValue == canCmd.oldValue) {
                    found = batchCmd;
                  }
                }
              }
              if (found) {
                found.newValue = canCmd.newValue; // change existing value, do not batch
              } else {
                batch.push(candidate); // we cannot merge, so batch the candidate
              }
            } else {
              batch.push(candidate);
            }
            if (candidate.handler || candidate.command['className'] == "org.opendolphin.core.comm.NamedCommand" || candidate.command['className'] == "org.opendolphin.core.comm.EmptyNotification" // or unknown client side effect
            ) {
                break; // leave the loop
              }
          }
          return batch;
        };
        return BlindCommandBatcher;
      }();
      exports.BlindCommandBatcher = BlindCommandBatcher;
    }, { "./ValueChangedCommand": 400 }], 389: [function (_dereq_, module, exports) {
      "use strict";

      var __extends = undefined && undefined.__extends || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
      var Command_1 = _dereq_('./Command');
      var CreatePresentationModelCommand = function (_super) {
        __extends(CreatePresentationModelCommand, _super);
        function CreatePresentationModelCommand(presentationModel) {
          _super.call(this);
          this.attributes = [];
          this.clientSideOnly = false;
          this.id = "CreatePresentationModel";
          this.className = "org.opendolphin.core.comm.CreatePresentationModelCommand";
          this.pmId = presentationModel.id;
          this.pmType = presentationModel.presentationModelType;
          var attrs = this.attributes;
          presentationModel.getAttributes().forEach(function (attr) {
            attrs.push({
              propertyName: attr.propertyName,
              id: attr.id,
              qualifier: attr.getQualifier(),
              value: attr.getValue()
            });
          });
        }
        return CreatePresentationModelCommand;
      }(Command_1["default"]);
      exports.__esModule = true;
      exports["default"] = CreatePresentationModelCommand;
    }, { "./Command": 387 }], 390: [function (_dereq_, module, exports) {
      "use strict";

      var __extends = undefined && undefined.__extends || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
      var Command_1 = _dereq_('./Command');
      var DeletedAllPresentationModelsOfTypeNotification = function (_super) {
        __extends(DeletedAllPresentationModelsOfTypeNotification, _super);
        function DeletedAllPresentationModelsOfTypeNotification(pmType) {
          _super.call(this);
          this.pmType = pmType;
          this.id = 'DeletedAllPresentationModelsOfType';
          this.className = "org.opendolphin.core.comm.DeletedAllPresentationModelsOfTypeNotification";
        }
        return DeletedAllPresentationModelsOfTypeNotification;
      }(Command_1["default"]);
      exports.__esModule = true;
      exports["default"] = DeletedAllPresentationModelsOfTypeNotification;
    }, { "./Command": 387 }], 391: [function (_dereq_, module, exports) {
      "use strict";

      var __extends = undefined && undefined.__extends || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
      var Command_1 = _dereq_('./Command');
      var DeletedPresentationModelNotification = function (_super) {
        __extends(DeletedPresentationModelNotification, _super);
        function DeletedPresentationModelNotification(pmId) {
          _super.call(this);
          this.pmId = pmId;
          this.id = 'DeletedPresentationModel';
          this.className = "org.opendolphin.core.comm.DeletedPresentationModelNotification";
        }
        return DeletedPresentationModelNotification;
      }(Command_1["default"]);
      exports.__esModule = true;
      exports["default"] = DeletedPresentationModelNotification;
    }, { "./Command": 387 }], 392: [function (_dereq_, module, exports) {
      "use strict";

      var ClientConnector_1 = _dereq_("./ClientConnector");
      var ClientDolphin_1 = _dereq_("./ClientDolphin");
      var ClientModelStore_1 = _dereq_("./ClientModelStore");
      var HttpTransmitter_1 = _dereq_("./HttpTransmitter");
      var NoTransmitter_1 = _dereq_("./NoTransmitter");
      var DolphinBuilder = function () {
        function DolphinBuilder() {
          this.reset_ = false;
          this.slackMS_ = 300;
          this.maxBatchSize_ = 50;
          this.supportCORS_ = false;
        }
        DolphinBuilder.prototype.url = function (url) {
          this.url_ = url;
          return this;
        };
        DolphinBuilder.prototype.reset = function (reset) {
          this.reset_ = reset;
          return this;
        };
        DolphinBuilder.prototype.slackMS = function (slackMS) {
          this.slackMS_ = slackMS;
          return this;
        };
        DolphinBuilder.prototype.maxBatchSize = function (maxBatchSize) {
          this.maxBatchSize_ = maxBatchSize;
          return this;
        };
        DolphinBuilder.prototype.supportCORS = function (supportCORS) {
          this.supportCORS_ = supportCORS;
          return this;
        };
        DolphinBuilder.prototype.errorHandler = function (errorHandler) {
          this.errorHandler_ = errorHandler;
          return this;
        };
        DolphinBuilder.prototype.headersInfo = function (headersInfo) {
          this.headersInfo_ = headersInfo;
          return this;
        };
        DolphinBuilder.prototype.build = function () {
          console.log("OpenDolphin js found");
          var clientDolphin = new ClientDolphin_1["default"]();
          var transmitter;
          if (this.url_ != null && this.url_.length > 0) {
            transmitter = new HttpTransmitter_1["default"](this.url_, this.reset_, "UTF-8", this.errorHandler_, this.supportCORS_, this.headersInfo_);
          } else {
            transmitter = new NoTransmitter_1["default"]();
          }
          clientDolphin.setClientConnector(new ClientConnector_1.ClientConnector(transmitter, clientDolphin, this.slackMS_, this.maxBatchSize_));
          clientDolphin.setClientModelStore(new ClientModelStore_1.ClientModelStore(clientDolphin));
          console.log("ClientDolphin initialized");
          return clientDolphin;
        };
        return DolphinBuilder;
      }();
      exports.__esModule = true;
      exports["default"] = DolphinBuilder;
    }, { "./ClientConnector": 382, "./ClientDolphin": 383, "./ClientModelStore": 384, "./HttpTransmitter": 395, "./NoTransmitter": 397 }], 393: [function (_dereq_, module, exports) {
      "use strict";

      var __extends = undefined && undefined.__extends || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
      var Command_1 = _dereq_('./Command');
      var EmptyNotification = function (_super) {
        __extends(EmptyNotification, _super);
        function EmptyNotification() {
          _super.call(this);
          this.id = "Empty";
          this.className = "org.opendolphin.core.comm.EmptyNotification";
        }
        return EmptyNotification;
      }(Command_1["default"]);
      exports.__esModule = true;
      exports["default"] = EmptyNotification;
    }, { "./Command": 387 }], 394: [function (_dereq_, module, exports) {
      "use strict";

      var EventBus = function () {
        function EventBus() {
          this.eventHandlers = [];
        }
        EventBus.prototype.onEvent = function (eventHandler) {
          this.eventHandlers.push(eventHandler);
        };
        EventBus.prototype.trigger = function (event) {
          this.eventHandlers.forEach(function (handle) {
            return handle(event);
          });
        };
        return EventBus;
      }();
      exports.__esModule = true;
      exports["default"] = EventBus;
    }, {}], 395: [function (_dereq_, module, exports) {
      "use strict";

      var Codec_1 = _dereq_("./Codec");
      var HttpTransmitter = function () {
        function HttpTransmitter(url, reset, charset, errorHandler, supportCORS, headersInfo) {
          if (reset === void 0) {
            reset = true;
          }
          if (charset === void 0) {
            charset = "UTF-8";
          }
          if (errorHandler === void 0) {
            errorHandler = null;
          }
          if (supportCORS === void 0) {
            supportCORS = false;
          }
          if (headersInfo === void 0) {
            headersInfo = null;
          }
          this.url = url;
          this.charset = charset;
          this.HttpCodes = {
            finished: 4,
            success: 200
          };
          this.errorHandler = errorHandler;
          this.supportCORS = supportCORS;
          this.headersInfo = headersInfo;
          this.http = new XMLHttpRequest();
          this.sig = new XMLHttpRequest();
          if (this.supportCORS) {
            if ("withCredentials" in this.http) {
              this.http.withCredentials = true; // NOTE: doing this for non CORS requests has no impact
              this.sig.withCredentials = true;
            }
          }
          this.codec = new Codec_1["default"]();
          if (reset) {
            console.log('HttpTransmitter.invalidate() is deprecated. Use ClientDolphin.reset(OnSuccessHandler) instead');
            this.invalidate();
          }
        }
        HttpTransmitter.prototype.transmit = function (commands, onDone) {
          var _this = this;
          this.http.onerror = function (evt) {
            _this.handleError('onerror', "");
            onDone([]);
          };
          this.http.onreadystatechange = function (evt) {
            if (_this.http.readyState == _this.HttpCodes.finished) {
              if (_this.http.status == _this.HttpCodes.success) {
                var responseText = _this.http.responseText;
                if (responseText.trim().length > 0) {
                  try {
                    var responseCommands = _this.codec.decode(responseText);
                    onDone(responseCommands);
                  } catch (err) {
                    console.log("Error occurred parsing responseText: ", err);
                    console.log("Incorrect responseText: ", responseText);
                    _this.handleError('application', "HttpTransmitter: Incorrect responseText: " + responseText);
                    onDone([]);
                  }
                } else {
                  _this.handleError('application', "HttpTransmitter: empty responseText");
                  onDone([]);
                }
              } else {
                _this.handleError('application', "HttpTransmitter: HTTP Status != 200");
                onDone([]);
              }
            }
          };
          this.http.open('POST', this.url, true);
          this.setHeaders(this.http);
          if ("overrideMimeType" in this.http) {
            this.http.overrideMimeType("application/json; charset=" + this.charset); // todo make injectable
          }
          this.http.send(this.codec.encode(commands));
        };
        HttpTransmitter.prototype.setHeaders = function (httpReq) {
          if (this.headersInfo) {
            for (var i in this.headersInfo) {
              if (this.headersInfo.hasOwnProperty(i)) {
                httpReq.setRequestHeader(i, this.headersInfo[i]);
              }
            }
          }
        };
        HttpTransmitter.prototype.handleError = function (kind, message) {
          var errorEvent = { kind: kind, url: this.url, httpStatus: this.http.status, message: message };
          if (this.errorHandler) {
            this.errorHandler(errorEvent);
          } else {
            console.log("Error occurred: ", errorEvent);
          }
        };
        HttpTransmitter.prototype.signal = function (command) {
          this.sig.open('POST', this.url, true);
          this.setHeaders(this.sig);
          this.sig.send(this.codec.encode([command]));
        };
        // Deprecated ! Use 'reset(OnSuccessHandler) instead
        HttpTransmitter.prototype.invalidate = function () {
          this.http.open('POST', this.url + 'invalidate?', false);
          this.http.send();
        };
        HttpTransmitter.prototype.reset = function (successHandler) {
          var _this = this;
          this.http.onreadystatechange = function (evt) {
            if (_this.http.readyState == _this.HttpCodes.finished) {
              if (_this.http.status == _this.HttpCodes.success) {
                successHandler.onSuccess();
              } else {
                _this.handleError('application', "HttpTransmitter.reset(): HTTP Status != 200");
              }
            }
          };
          this.http.open('POST', this.url + 'invalidate?', true);
          this.http.send();
        };
        return HttpTransmitter;
      }();
      exports.__esModule = true;
      exports["default"] = HttpTransmitter;
    }, { "./Codec": 386 }], 396: [function (_dereq_, module, exports) {
      "use strict";

      var __extends = undefined && undefined.__extends || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
      var Command_1 = _dereq_('./Command');
      var NamedCommand = function (_super) {
        __extends(NamedCommand, _super);
        function NamedCommand(name) {
          _super.call(this);
          this.id = name;
          this.className = "org.opendolphin.core.comm.NamedCommand";
        }
        return NamedCommand;
      }(Command_1["default"]);
      exports.__esModule = true;
      exports["default"] = NamedCommand;
    }, { "./Command": 387 }], 397: [function (_dereq_, module, exports) {
      "use strict";
      /**
       * A transmitter that is not transmitting at all.
       * It may serve as a stand-in when no real transmitter is needed.
       */

      var NoTransmitter = function () {
        function NoTransmitter() {}
        NoTransmitter.prototype.transmit = function (commands, onDone) {
          // do nothing special
          onDone([]);
        };
        NoTransmitter.prototype.signal = function (command) {
          // do nothing
        };
        NoTransmitter.prototype.reset = function (successHandler) {
          // do nothing
        };
        return NoTransmitter;
      }();
      exports.__esModule = true;
      exports["default"] = NoTransmitter;
    }, {}], 398: [function (_dereq_, module, exports) {
      "use strict";

      var DolphinBuilder_1 = _dereq_("./DolphinBuilder");
      /**
       * JS-friendly facade to avoid too many dependencies in plain JS code.
       * The name of this file is also used for the initial lookup of the
       * one javascript file that contains all the dolphin code.
       * Changing the name requires the build support and all users
       * to be updated as well.
       * Dierk Koenig
       */
      // factory method for the initialized dolphin
      // Deprecated ! Use 'makeDolphin() instead
      function dolphin(url, reset, slackMS) {
        if (slackMS === void 0) {
          slackMS = 300;
        }
        return makeDolphin().url(url).reset(reset).slackMS(slackMS).build();
      }
      exports.dolphin = dolphin;
      // factory method to build an initialized dolphin
      function makeDolphin() {
        return new DolphinBuilder_1["default"]();
      }
      exports.makeDolphin = makeDolphin;
    }, { "./DolphinBuilder": 392 }], 399: [function (_dereq_, module, exports) {
      "use strict";

      var __extends = undefined && undefined.__extends || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
      var Command_1 = _dereq_('./Command');
      var SignalCommand = function (_super) {
        __extends(SignalCommand, _super);
        function SignalCommand(name) {
          _super.call(this);
          this.id = name;
          this.className = "org.opendolphin.core.comm.SignalCommand";
        }
        return SignalCommand;
      }(Command_1["default"]);
      exports.__esModule = true;
      exports["default"] = SignalCommand;
    }, { "./Command": 387 }], 400: [function (_dereq_, module, exports) {
      "use strict";

      var __extends = undefined && undefined.__extends || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
      var Command_1 = _dereq_('./Command');
      var ValueChangedCommand = function (_super) {
        __extends(ValueChangedCommand, _super);
        function ValueChangedCommand(attributeId, oldValue, newValue) {
          _super.call(this);
          this.attributeId = attributeId;
          this.oldValue = oldValue;
          this.newValue = newValue;
          this.id = "ValueChanged";
          this.className = "org.opendolphin.core.comm.ValueChangedCommand";
        }
        return ValueChangedCommand;
      }(Command_1["default"]);
      exports.__esModule = true;
      exports["default"] = ValueChangedCommand;
    }, { "./Command": 387 }], 401: [function (_dereq_, module, exports) {
      /* Copyright 2015 Canoo Engineering AG.
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *     http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      /*jslint browserify: true */
      /* global console */
      "use strict";

      var Map = _dereq_('../bower_components/core.js/library/fn/map');
      var utils = _dereq_('./utils.js');
      var exists = utils.exists;
      var checkMethod = utils.checkMethod;
      var checkParam = utils.checkParam;

      function BeanManager(classRepository) {
        checkMethod('BeanManager(classRepository)');
        checkParam(classRepository, 'classRepository');

        this.classRepository = classRepository;
        this.addedHandlers = new Map();
        this.removedHandlers = new Map();
        this.updatedHandlers = new Map();
        this.arrayUpdatedHandlers = new Map();
        this.allAddedHandlers = [];
        this.allRemovedHandlers = [];
        this.allUpdatedHandlers = [];
        this.allArrayUpdatedHandlers = [];

        var self = this;
        this.classRepository.onBeanAdded(function (type, bean) {
          var handlerList = self.addedHandlers.get(type);
          if (exists(handlerList)) {
            handlerList.forEach(function (handler) {
              try {
                handler(bean);
              } catch (e) {
                console.warn('An exception occurred while calling an onBeanAdded-handler for type', type, e);
              }
            });
          }
          self.allAddedHandlers.forEach(function (handler) {
            try {
              handler(bean);
            } catch (e) {
              console.warn('An exception occurred while calling a general onBeanAdded-handler', e);
            }
          });
        });
        this.classRepository.onBeanRemoved(function (type, bean) {
          var handlerList = self.removedHandlers.get(type);
          if (exists(handlerList)) {
            handlerList.forEach(function (handler) {
              try {
                handler(bean);
              } catch (e) {
                console.warn('An exception occurred while calling an onBeanRemoved-handler for type', type, e);
              }
            });
          }
          self.allRemovedHandlers.forEach(function (handler) {
            try {
              handler(bean);
            } catch (e) {
              console.warn('An exception occurred while calling a general onBeanRemoved-handler', e);
            }
          });
        });
        this.classRepository.onBeanUpdate(function (type, bean, propertyName, newValue, oldValue) {
          var handlerList = self.updatedHandlers.get(type);
          if (exists(handlerList)) {
            handlerList.forEach(function (handler) {
              try {
                handler(bean, propertyName, newValue, oldValue);
              } catch (e) {
                console.warn('An exception occurred while calling an onBeanUpdate-handler for type', type, e);
              }
            });
          }
          self.allUpdatedHandlers.forEach(function (handler) {
            try {
              handler(bean, propertyName, newValue, oldValue);
            } catch (e) {
              console.warn('An exception occurred while calling a general onBeanUpdate-handler', e);
            }
          });
        });
        this.classRepository.onArrayUpdate(function (type, bean, propertyName, index, count, newElements) {
          var handlerList = self.arrayUpdatedHandlers.get(type);
          if (exists(handlerList)) {
            handlerList.forEach(function (handler) {
              try {
                handler(bean, propertyName, index, count, newElements);
              } catch (e) {
                console.warn('An exception occurred while calling an onArrayUpdate-handler for type', type, e);
              }
            });
          }
          self.allArrayUpdatedHandlers.forEach(function (handler) {
            try {
              handler(bean, propertyName, index, count, newElements);
            } catch (e) {
              console.warn('An exception occurred while calling a general onArrayUpdate-handler', e);
            }
          });
        });
      }

      BeanManager.prototype.notifyBeanChange = function (bean, propertyName, newValue) {
        checkMethod('BeanManager.notifyBeanChange(bean, propertyName, newValue)');
        checkParam(bean, 'bean');
        checkParam(propertyName, 'propertyName');

        return this.classRepository.notifyBeanChange(bean, propertyName, newValue);
      };

      BeanManager.prototype.notifyArrayChange = function (bean, propertyName, index, count, removedElements) {
        checkMethod('BeanManager.notifyArrayChange(bean, propertyName, index, count, removedElements)');
        checkParam(bean, 'bean');
        checkParam(propertyName, 'propertyName');
        checkParam(index, 'index');
        checkParam(count, 'count');
        checkParam(removedElements, 'removedElements');

        this.classRepository.notifyArrayChange(bean, propertyName, index, count, removedElements);
      };

      BeanManager.prototype.isManaged = function (bean) {
        checkMethod('BeanManager.isManaged(bean)');
        checkParam(bean, 'bean');

        // TODO: Implement dolphin.isManaged() [DP-7]
        throw new Error("Not implemented yet");
      };

      BeanManager.prototype.create = function (type) {
        checkMethod('BeanManager.create(type)');
        checkParam(type, 'type');

        // TODO: Implement dolphin.create() [DP-7]
        throw new Error("Not implemented yet");
      };

      BeanManager.prototype.add = function (type, bean) {
        checkMethod('BeanManager.add(type, bean)');
        checkParam(type, 'type');
        checkParam(bean, 'bean');

        // TODO: Implement dolphin.add() [DP-7]
        throw new Error("Not implemented yet");
      };

      BeanManager.prototype.addAll = function (type, collection) {
        checkMethod('BeanManager.addAll(type, collection)');
        checkParam(type, 'type');
        checkParam(collection, 'collection');

        // TODO: Implement dolphin.addAll() [DP-7]
        throw new Error("Not implemented yet");
      };

      BeanManager.prototype.remove = function (bean) {
        checkMethod('BeanManager.remove(bean)');
        checkParam(bean, 'bean');

        // TODO: Implement dolphin.remove() [DP-7]
        throw new Error("Not implemented yet");
      };

      BeanManager.prototype.removeAll = function (collection) {
        checkMethod('BeanManager.removeAll(collection)');
        checkParam(collection, 'collection');

        // TODO: Implement dolphin.removeAll() [DP-7]
        throw new Error("Not implemented yet");
      };

      BeanManager.prototype.removeIf = function (predicate) {
        checkMethod('BeanManager.removeIf(predicate)');
        checkParam(predicate, 'predicate');

        // TODO: Implement dolphin.removeIf() [DP-7]
        throw new Error("Not implemented yet");
      };

      BeanManager.prototype.onAdded = function (type, eventHandler) {
        var self = this;
        if (!exists(eventHandler)) {
          eventHandler = type;
          checkMethod('BeanManager.onAdded(eventHandler)');
          checkParam(eventHandler, 'eventHandler');

          self.allAddedHandlers = self.allAddedHandlers.concat(eventHandler);
          return {
            unsubscribe: function unsubscribe() {
              self.allAddedHandlers = self.allAddedHandlers.filter(function (value) {
                return value !== eventHandler;
              });
            }
          };
        } else {
          checkMethod('BeanManager.onAdded(type, eventHandler)');
          checkParam(type, 'type');
          checkParam(eventHandler, 'eventHandler');

          var handlerList = self.addedHandlers.get(type);
          if (!exists(handlerList)) {
            handlerList = [];
          }
          self.addedHandlers.set(type, handlerList.concat(eventHandler));
          return {
            unsubscribe: function unsubscribe() {
              var handlerList = self.addedHandlers.get(type);
              if (exists(handlerList)) {
                self.addedHandlers.set(type, handlerList.filter(function (value) {
                  return value !== eventHandler;
                }));
              }
            }
          };
        }
      };

      BeanManager.prototype.onRemoved = function (type, eventHandler) {
        var self = this;
        if (!exists(eventHandler)) {
          eventHandler = type;
          checkMethod('BeanManager.onRemoved(eventHandler)');
          checkParam(eventHandler, 'eventHandler');

          self.allRemovedHandlers = self.allRemovedHandlers.concat(eventHandler);
          return {
            unsubscribe: function unsubscribe() {
              self.allRemovedHandlers = self.allRemovedHandlers.filter(function (value) {
                return value !== eventHandler;
              });
            }
          };
        } else {
          checkMethod('BeanManager.onRemoved(type, eventHandler)');
          checkParam(type, 'type');
          checkParam(eventHandler, 'eventHandler');

          var handlerList = self.removedHandlers.get(type);
          if (!exists(handlerList)) {
            handlerList = [];
          }
          self.removedHandlers.set(type, handlerList.concat(eventHandler));
          return {
            unsubscribe: function unsubscribe() {
              var handlerList = self.removedHandlers.get(type);
              if (exists(handlerList)) {
                self.removedHandlers.set(type, handlerList.filter(function (value) {
                  return value !== eventHandler;
                }));
              }
            }
          };
        }
      };

      BeanManager.prototype.onBeanUpdate = function (type, eventHandler) {
        var self = this;
        if (!exists(eventHandler)) {
          eventHandler = type;
          checkMethod('BeanManager.onBeanUpdate(eventHandler)');
          checkParam(eventHandler, 'eventHandler');

          self.allUpdatedHandlers = self.allUpdatedHandlers.concat(eventHandler);
          return {
            unsubscribe: function unsubscribe() {
              self.allUpdatedHandlers = self.allUpdatedHandlers.filter(function (value) {
                return value !== eventHandler;
              });
            }
          };
        } else {
          checkMethod('BeanManager.onBeanUpdate(type, eventHandler)');
          checkParam(type, 'type');
          checkParam(eventHandler, 'eventHandler');

          var handlerList = self.updatedHandlers.get(type);
          if (!exists(handlerList)) {
            handlerList = [];
          }
          self.updatedHandlers.set(type, handlerList.concat(eventHandler));
          return {
            unsubscribe: function unsubscribe() {
              var handlerList = self.updatedHandlers.get(type);
              if (exists(handlerList)) {
                self.updatedHandlers.set(type, handlerList.filter(function (value) {
                  return value !== eventHandler;
                }));
              }
            }
          };
        }
      };

      BeanManager.prototype.onArrayUpdate = function (type, eventHandler) {
        var self = this;
        if (!exists(eventHandler)) {
          eventHandler = type;
          checkMethod('BeanManager.onArrayUpdate(eventHandler)');
          checkParam(eventHandler, 'eventHandler');

          self.allArrayUpdatedHandlers = self.allArrayUpdatedHandlers.concat(eventHandler);
          return {
            unsubscribe: function unsubscribe() {
              self.allArrayUpdatedHandlers = self.allArrayUpdatedHandlers.filter(function (value) {
                return value !== eventHandler;
              });
            }
          };
        } else {
          checkMethod('BeanManager.onArrayUpdate(type, eventHandler)');
          checkParam(type, 'type');
          checkParam(eventHandler, 'eventHandler');

          var handlerList = self.arrayUpdatedHandlers.get(type);
          if (!exists(handlerList)) {
            handlerList = [];
          }
          self.arrayUpdatedHandlers.set(type, handlerList.concat(eventHandler));
          return {
            unsubscribe: function unsubscribe() {
              var handlerList = self.arrayUpdatedHandlers.get(type);
              if (exists(handlerList)) {
                self.arrayUpdatedHandlers.set(type, handlerList.filter(function (value) {
                  return value !== eventHandler;
                }));
              }
            }
          };
        }
      };

      exports.BeanManager = BeanManager;
    }, { "../bower_components/core.js/library/fn/map": 1, "./utils.js": 412 }], 402: [function (_dereq_, module, exports) {
      /* Copyright 2015 Canoo Engineering AG.
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *     http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      /*jslint browserify: true */
      /* global Platform, console */
      "use strict";

      var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
        return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
      } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
      };

      var Map = _dereq_('../bower_components/core.js/library/fn/map');
      var consts = _dereq_('./constants');

      var utils = _dereq_('./utils.js');
      var exists = utils.exists;
      var checkMethod = utils.checkMethod;
      var checkParam = utils.checkParam;

      var blocked = null;

      function fixType(type, value) {
        switch (type) {
          case consts.BYTE:
          case consts.SHORT:
          case consts.INT:
          case consts.LONG:
            return parseInt(value);
          case consts.FLOAT:
          case consts.DOUBLE:
            return parseFloat(value);
          case consts.BOOLEAN:
            return 'true' === String(value).toLowerCase();
          case consts.STRING:
          case consts.ENUM:
            return String(value);
          default:
            return value;
        }
      }

      function fromDolphin(classRepository, type, value) {
        if (!exists(value)) {
          return null;
        }
        switch (type) {
          case consts.DOLPHIN_BEAN:
            return classRepository.beanFromDolphin.get(String(value));
          case consts.DATE:
            return new Date(String(value));
          default:
            return fixType(type, value);
        }
      }

      function toDolphin(classRepository, type, value) {
        if (!exists(value)) {
          return null;
        }
        switch (type) {
          case consts.DOLPHIN_BEAN:
            return classRepository.beanToDolphin.get(value);
          case consts.DATE:
            return value instanceof Date ? value.toISOString() : value;
          default:
            return fixType(type, value);
        }
      }

      function sendListSplice(classRepository, modelId, propertyName, from, to, newElements) {
        var dolphin = classRepository.dolphin;
        var model = dolphin.findPresentationModelById(modelId);
        if (exists(model)) {
          var classInfo = classRepository.classes.get(model.presentationModelType);
          var type = classInfo[propertyName];
          if (exists(type)) {

            var attributes = [dolphin.attribute('@@@ SOURCE_SYSTEM @@@', null, 'client'), dolphin.attribute('source', null, modelId), dolphin.attribute('attribute', null, propertyName), dolphin.attribute('from', null, from), dolphin.attribute('to', null, to), dolphin.attribute('count', null, newElements.length)];
            newElements.forEach(function (element, index) {
              attributes.push(dolphin.attribute(index.toString(), null, toDolphin(classRepository, type, element)));
            });
            dolphin.presentationModel.apply(dolphin, [null, '@DP:LS@'].concat(attributes));
          }
        }
      }

      function validateList(classRepository, type, bean, propertyName) {
        var list = bean[propertyName];
        if (!exists(list)) {
          classRepository.propertyUpdateHandlers.forEach(function (handler) {
            try {
              handler(type, bean, propertyName, [], undefined);
            } catch (e) {
              console.warn('An exception occurred while calling an onBeanUpdate-handler', e);
            }
          });
        }
      }

      function block(bean, propertyName) {
        if (exists(blocked)) {
          throw new Error('Trying to create a block while another block exists');
        }
        blocked = {
          bean: bean,
          propertyName: propertyName
        };
      }

      function isBlocked(bean, propertyName) {
        return exists(blocked) && blocked.bean === bean && blocked.propertyName === propertyName;
      }

      function unblock() {
        blocked = null;
      }

      function ClassRepository(dolphin) {
        checkMethod('ClassRepository(dolphin)');
        checkParam(dolphin, 'dolphin');

        this.dolphin = dolphin;
        this.classes = new Map();
        this.beanFromDolphin = new Map();
        this.beanToDolphin = new Map();
        this.classInfos = new Map();
        this.beanAddedHandlers = [];
        this.beanRemovedHandlers = [];
        this.propertyUpdateHandlers = [];
        this.arrayUpdateHandlers = [];
      }

      ClassRepository.prototype.notifyBeanChange = function (bean, propertyName, newValue) {
        checkMethod('ClassRepository.notifyBeanChange(bean, propertyName, newValue)');
        checkParam(bean, 'bean');
        checkParam(propertyName, 'propertyName');

        var modelId = this.beanToDolphin.get(bean);
        if (exists(modelId)) {
          var model = this.dolphin.findPresentationModelById(modelId);
          if (exists(model)) {
            var classInfo = this.classes.get(model.presentationModelType);
            var type = classInfo[propertyName];
            var attribute = model.findAttributeByPropertyName(propertyName);
            if (exists(type) && exists(attribute)) {
              var oldValue = attribute.getValue();
              attribute.setValue(toDolphin(this, type, newValue));
              return fromDolphin(this, type, oldValue);
            }
          }
        }
      };

      ClassRepository.prototype.notifyArrayChange = function (bean, propertyName, index, count, removedElements) {
        checkMethod('ClassRepository.notifyArrayChange(bean, propertyName, index, count, removedElements)');
        checkParam(bean, 'bean');
        checkParam(propertyName, 'propertyName');
        checkParam(index, 'index');
        checkParam(count, 'count');
        checkParam(removedElements, 'removedElements');

        if (isBlocked(bean, propertyName)) {
          return;
        }
        var modelId = this.beanToDolphin.get(bean);
        var array = bean[propertyName];
        if (exists(modelId) && exists(array)) {
          var removedElementsCount = Array.isArray(removedElements) ? removedElements.length : 0;
          sendListSplice(this, modelId, propertyName, index, index + removedElementsCount, array.slice(index, index + count));
        }
      };

      ClassRepository.prototype.onBeanAdded = function (handler) {
        checkMethod('ClassRepository.onBeanAdded(handler)');
        checkParam(handler, 'handler');
        this.beanAddedHandlers.push(handler);
      };

      ClassRepository.prototype.onBeanRemoved = function (handler) {
        checkMethod('ClassRepository.onBeanRemoved(handler)');
        checkParam(handler, 'handler');
        this.beanRemovedHandlers.push(handler);
      };

      ClassRepository.prototype.onBeanUpdate = function (handler) {
        checkMethod('ClassRepository.onBeanUpdate(handler)');
        checkParam(handler, 'handler');
        this.propertyUpdateHandlers.push(handler);
      };

      ClassRepository.prototype.onArrayUpdate = function (handler) {
        checkMethod('ClassRepository.onArrayUpdate(handler)');
        checkParam(handler, 'handler');
        this.arrayUpdateHandlers.push(handler);
      };

      ClassRepository.prototype.registerClass = function (model) {
        checkMethod('ClassRepository.registerClass(model)');
        checkParam(model, 'model');

        if (this.classes.has(model.id)) {
          return;
        }

        var classInfo = {};
        model.attributes.filter(function (attribute) {
          return attribute.propertyName.search(/^@/) < 0;
        }).forEach(function (attribute) {
          classInfo[attribute.propertyName] = attribute.value;
        });
        this.classes.set(model.id, classInfo);
      };

      ClassRepository.prototype.unregisterClass = function (model) {
        checkMethod('ClassRepository.unregisterClass(model)');
        checkParam(model, 'model');

        this.classes['delete'](model.id);
      };

      ClassRepository.prototype.load = function (model) {
        checkMethod('ClassRepository.load(model)');
        checkParam(model, 'model');

        var self = this;
        var classInfo = this.classes.get(model.presentationModelType);
        var bean = {};
        model.attributes.filter(function (attribute) {
          return attribute.propertyName.search(/^@/) < 0;
        }).forEach(function (attribute) {
          bean[attribute.propertyName] = null;
          attribute.onValueChange(function (event) {
            if (event.oldValue !== event.newValue) {
              var oldValue = fromDolphin(self, classInfo[attribute.propertyName], event.oldValue);
              var newValue = fromDolphin(self, classInfo[attribute.propertyName], event.newValue);
              self.propertyUpdateHandlers.forEach(function (handler) {
                try {
                  handler(model.presentationModelType, bean, attribute.propertyName, newValue, oldValue);
                } catch (e) {
                  console.warn('An exception occurred while calling an onBeanUpdate-handler', e);
                }
              });
            }
          });
        });
        this.beanFromDolphin.set(model.id, bean);
        this.beanToDolphin.set(bean, model.id);
        this.classInfos.set(model.id, classInfo);
        this.beanAddedHandlers.forEach(function (handler) {
          try {
            handler(model.presentationModelType, bean);
          } catch (e) {
            console.warn('An exception occurred while calling an onBeanAdded-handler', e);
          }
        });
        return bean;
      };

      ClassRepository.prototype.unload = function (model) {
        checkMethod('ClassRepository.unload(model)');
        checkParam(model, 'model');

        var bean = this.beanFromDolphin.get(model.id);
        this.beanFromDolphin['delete'](model.id);
        this.beanToDolphin['delete'](bean);
        this.classInfos['delete'](model.id);
        if (exists(bean)) {
          this.beanRemovedHandlers.forEach(function (handler) {
            try {
              handler(model.presentationModelType, bean);
            } catch (e) {
              console.warn('An exception occurred while calling an onBeanRemoved-handler', e);
            }
          });
        }
        return bean;
      };

      ClassRepository.prototype.spliceListEntry = function (model) {
        checkMethod('ClassRepository.spliceListEntry(model)');
        checkParam(model, 'model');

        var source = model.findAttributeByPropertyName('source');
        var attribute = model.findAttributeByPropertyName('attribute');
        var from = model.findAttributeByPropertyName('from');
        var to = model.findAttributeByPropertyName('to');
        var count = model.findAttributeByPropertyName('count');

        if (exists(source) && exists(attribute) && exists(from) && exists(to) && exists(count)) {
          var classInfo = this.classInfos.get(source.value);
          var bean = this.beanFromDolphin.get(source.value);
          if (exists(bean) && exists(classInfo)) {
            var type = model.presentationModelType;
            //var entry = fromDolphin(this, classInfo[attribute.value], element.value);
            validateList(this, type, bean, attribute.value);
            var newElements = [],
                element = null;
            for (var i = 0; i < count.value; i++) {
              element = model.findAttributeByPropertyName(i.toString());
              if (!exists(element)) {
                throw new Error("Invalid list modification update received");
              }
              newElements.push(fromDolphin(this, classInfo[attribute.value], element.value));
            }
            try {
              block(bean, attribute.value);
              this.arrayUpdateHandlers.forEach(function (handler) {
                try {
                  handler(type, bean, attribute.value, from.value, to.value - from.value, newElements);
                } catch (e) {
                  console.warn('An exception occurred while calling an onArrayUpdate-handler', e);
                }
              });
            } finally {
              unblock();
            }
          } else {
            throw new Error("Invalid list modification update received. Source bean unknown.");
          }
        } else {
          throw new Error("Invalid list modification update received");
        }
      };

      ClassRepository.prototype.mapParamToDolphin = function (param) {
        if (!exists(param)) {
          return param;
        }
        var type = typeof param === 'undefined' ? 'undefined' : _typeof(param);
        if (type === 'object') {
          if (param instanceof Date) {
            return param.toISOString();
          } else {
            var value = this.beanToDolphin.get(param);
            if (exists(value)) {
              return value;
            }
            throw new TypeError("Only managed Dolphin Beans can be used");
          }
        }
        if (type === 'string' || type === 'number' || type === 'boolean') {
          return param;
        }
        throw new TypeError("Only managed Dolphin Beans and primitive types can be used");
      };

      ClassRepository.prototype.mapDolphinToBean = function (value) {
        return fromDolphin(this, consts.DOLPHIN_BEAN, value);
      };

      exports.ClassRepository = ClassRepository;
    }, { "../bower_components/core.js/library/fn/map": 1, "./constants": 406, "./utils.js": 412 }], 403: [function (_dereq_, module, exports) {
      /* Copyright 2015 Canoo Engineering AG.
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *     http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      /*jslint browserify: true */
      /* global console */
      "use strict";

      var Emitter = _dereq_('emitter-component');
      var Promise = _dereq_('../bower_components/core.js/library/fn/promise');
      var utils = _dereq_('./utils.js');
      var checkMethod = utils.checkMethod;
      var checkParam = utils.checkParam;

      var DOLPHIN_PLATFORM_PREFIX = 'dolphin_platform_intern_';
      var INIT_COMMAND_NAME = DOLPHIN_PLATFORM_PREFIX + 'initClientContext';
      var DISCONNECT_COMMAND_NAME = DOLPHIN_PLATFORM_PREFIX + 'disconnectClientContext';

      function ClientContext(dolphin, beanManager, controllerManager, connector) {
        checkMethod('ClientContext(dolphin, beanManager, controllerManager, connector)');
        checkParam(dolphin, 'dolphin');
        checkParam(beanManager, 'beanManager');
        checkParam(controllerManager, 'controllerManager');
        checkParam(connector, 'connector');

        this.dolphin = dolphin;
        this.beanManager = beanManager;
        this._controllerManager = controllerManager;
        this._connector = connector;

        this._connector.invoke(INIT_COMMAND_NAME);
      }

      Emitter(ClientContext.prototype);

      ClientContext.prototype.createController = function (name) {
        checkMethod('ClientContext.createController(name)');
        checkParam(name, 'name');

        return this._controllerManager.createController(name);
      };

      ClientContext.prototype.disconnect = function () {
        // TODO: Implement ClientContext.disconnect [DP-46]
        var self = this;
        this.dolphin.stopPushListening();
        return new Promise(function (resolve) {
          self._controllerManager.destroy().then(function () {
            self._connector.invoke(DISCONNECT_COMMAND_NAME);
            self.dolphin = null;
            self.beanManager = null;
            self._controllerManager = null;
            self._connector = null;
            resolve();
          });
        });
      };

      exports.ClientContext = ClientContext;
    }, { "../bower_components/core.js/library/fn/promise": 2, "./utils.js": 412, "emitter-component": 375 }], 404: [function (_dereq_, module, exports) {
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.encode = encode;
      exports.decode = decode;

      var _utils = _dereq_('./utils.js');

      function encodeCreatePresentationModelCommand(command) {
        return {
          'p': command.pmId,
          't': command.pmType,
          'a': command.attributes.map(function (attribute) {
            var result = {
              'n': attribute.propertyName,
              'i': attribute.id
            };
            if ((0, _utils.exists)(attribute.value)) {
              result.v = attribute.value;
            }
            return result;
          }),
          'id': 'CreatePresentationModel'
        };
      } /* Copyright 2016 Canoo Engineering AG.
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *     http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

      /*jslint browserify: true */

      function decodeCreatePresentationModelCommand(command) {
        return {
          'id': 'CreatePresentationModel',
          'className': "org.opendolphin.core.comm.CreatePresentationModelCommand",
          'clientSideOnly': false,
          'pmId': command.p,
          'pmType': command.t,
          'attributes': command.a.map(function (attribute) {
            return {
              'propertyName': attribute.n,
              'id': attribute.i,
              'value': (0, _utils.exists)(attribute.v) ? attribute.v : null,
              'qualifier': null
            };
          })
        };
      }

      function encodeValueChangedCommand(command) {
        var result = {
          'a': command.attributeId
        };
        if ((0, _utils.exists)(command.oldValue)) {
          result.o = command.oldValue;
        }
        if ((0, _utils.exists)(command.newValue)) {
          result.n = command.newValue;
        }
        result.id = 'ValueChanged';
        return result;
      }

      function decodeValueChangedCommand(command) {
        return {
          'id': 'ValueChanged',
          'className': "org.opendolphin.core.comm.ValueChangedCommand",
          'attributeId': command.a,
          'oldValue': (0, _utils.exists)(command.o) ? command.o : null,
          'newValue': (0, _utils.exists)(command.n) ? command.n : null
        };
      }

      function encode(commands) {
        return JSON.stringify(commands.map(function (command) {
          if (command.id === 'CreatePresentationModel') {
            return encodeCreatePresentationModelCommand(command);
          } else if (command.id === 'ValueChanged') {
            return encodeValueChangedCommand(command);
          }
          return command;
        }));
      }

      function decode(transmitted) {
        if (typeof transmitted === 'string') {
          return JSON.parse(transmitted).map(function (command) {
            if (command.id === 'CreatePresentationModel') {
              return decodeCreatePresentationModelCommand(command);
            } else if (command.id === 'ValueChanged') {
              return decodeValueChangedCommand(command);
            }
            return command;
          });
        } else {
          return transmitted;
        }
      }
    }, { "./utils.js": 412 }], 405: [function (_dereq_, module, exports) {
      /* Copyright 2015 Canoo Engineering AG.
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *     http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      /*jslint browserify: true */
      /* global console */
      "use strict";

      var Promise = _dereq_('../bower_components/core.js/library/fn/promise');
      var ClientModelStore = _dereq_('../opendolphin/build/ClientModelStore');
      var utils = _dereq_('./utils.js');
      var exists = utils.exists;
      var checkMethod = utils.checkMethod;
      var checkParam = utils.checkParam;

      var DOLPHIN_PLATFORM_PREFIX = 'dolphin_platform_intern_';
      var POLL_COMMAND_NAME = DOLPHIN_PLATFORM_PREFIX + 'longPoll';
      var RELEASE_COMMAND_NAME = DOLPHIN_PLATFORM_PREFIX + 'release';

      var DOLPHIN_BEAN = '@@@ DOLPHIN_BEAN @@@';
      var ACTION_CALL_BEAN = '@@@ CONTROLLER_ACTION_CALL_BEAN @@@';
      var HIGHLANDER_BEAN = '@@@ HIGHLANDER_BEAN @@@';
      var DOLPHIN_LIST_SPLICE = '@DP:LS@';
      var SOURCE_SYSTEM = '@@@ SOURCE_SYSTEM @@@';
      var SOURCE_SYSTEM_CLIENT = 'client';
      var SOURCE_SYSTEM_SERVER = 'server';

      function Connector(url, dolphin, classRepository, config) {
        checkMethod('Connector(url, dolphin, classRepository, config)');
        checkParam(url, 'url');
        checkParam(dolphin, 'dolphin');
        checkParam(classRepository, 'classRepository');

        var self = this;
        this.dolphin = dolphin;
        this.classRepository = classRepository;
        this.highlanderPMResolver = function () {};
        this.highlanderPMPromise = new Promise(function (resolve) {
          self.highlanderPMResolver = resolve;
        });

        dolphin.getClientModelStore().onModelStoreChange(function (event) {
          var model = event.clientPresentationModel;
          var sourceSystem = model.findAttributeByPropertyName(SOURCE_SYSTEM);
          if (exists(sourceSystem) && sourceSystem.value === SOURCE_SYSTEM_SERVER) {
            if (event.eventType === ClientModelStore.Type.ADDED) {
              self.onModelAdded(model);
            } else if (event.eventType === ClientModelStore.Type.REMOVED) {
              self.onModelRemoved(model);
            }
          }
        });

        if (!exists(config) || !exists(config.serverPush) || config.serverPush === true) {
          setTimeout(function () {
            dolphin.startPushListening(POLL_COMMAND_NAME, RELEASE_COMMAND_NAME);
          }, 500);
        }
      }

      Connector.prototype.onModelAdded = function (model) {
        checkMethod('Connector.onModelAdded(model)');
        checkParam(model, 'model');

        var type = model.presentationModelType;
        switch (type) {
          case ACTION_CALL_BEAN:
            // ignore
            break;
          case DOLPHIN_BEAN:
            this.classRepository.registerClass(model);
            break;
          case HIGHLANDER_BEAN:
            this.highlanderPMResolver(model);
            break;
          case DOLPHIN_LIST_SPLICE:
            this.classRepository.spliceListEntry(model);
            this.dolphin.deletePresentationModel(model);
            break;
          default:
            this.classRepository.load(model);
            break;
        }
      };

      Connector.prototype.onModelRemoved = function (model) {
        checkMethod('Connector.onModelRemoved(model)');
        checkParam(model, 'model');

        var type = model.presentationModelType;
        switch (type) {
          case DOLPHIN_BEAN:
            this.classRepository.unregisterClass(model);
            break;
          case DOLPHIN_LIST_SPLICE:
            // do nothing
            break;
          default:
            this.classRepository.unload(model);
            break;
        }
      };

      Connector.prototype.invoke = function (command) {
        checkMethod('Connector.invoke(command)');
        checkParam(command, 'command');

        var dolphin = this.dolphin;
        return new Promise(function (resolve) {
          dolphin.send(command, {
            onFinished: function onFinished() {
              resolve();
            }
          });
        });
      };

      Connector.prototype.getHighlanderPM = function () {
        return this.highlanderPMPromise;
      };

      exports.Connector = Connector;
      exports.SOURCE_SYSTEM = SOURCE_SYSTEM;
      exports.SOURCE_SYSTEM_CLIENT = SOURCE_SYSTEM_CLIENT;
      exports.SOURCE_SYSTEM_SERVER = SOURCE_SYSTEM_SERVER;
      exports.ACTION_CALL_BEAN = ACTION_CALL_BEAN;
    }, { "../bower_components/core.js/library/fn/promise": 2, "../opendolphin/build/ClientModelStore": 384, "./utils.js": 412 }], 406: [function (_dereq_, module, exports) {
      "use strict";

      exports.DOLPHIN_BEAN = 0;
      exports.BYTE = 1;
      exports.SHORT = 2;
      exports.INT = 3;
      exports.LONG = 4;
      exports.FLOAT = 5;
      exports.DOUBLE = 6;
      exports.BOOLEAN = 7;
      exports.STRING = 8;
      exports.DATE = 9;
      exports.ENUM = 10;
    }, {}], 407: [function (_dereq_, module, exports) {
      /* Copyright 2015 Canoo Engineering AG.
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *     http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      /*jslint browserify: true */
      /* global console */
      "use strict";

      var Promise = _dereq_('../bower_components/core.js/library/fn/promise');
      var Set = _dereq_('../bower_components/core.js/library/fn/set');
      var utils = _dereq_('./utils.js');
      var exists = utils.exists;
      var checkMethod = utils.checkMethod;
      var checkParam = utils.checkParam;

      var ControllerProxy = _dereq_('./controllerproxy.js').ControllerProxy;

      var SOURCE_SYSTEM = _dereq_('./connector.js').SOURCE_SYSTEM;
      var SOURCE_SYSTEM_CLIENT = _dereq_('./connector.js').SOURCE_SYSTEM_CLIENT;
      var ACTION_CALL_BEAN = _dereq_('./connector.js').ACTION_CALL_BEAN;

      var DOLPHIN_PLATFORM_PREFIX = 'dolphin_platform_intern_';
      var REGISTER_CONTROLLER_COMMAND_NAME = DOLPHIN_PLATFORM_PREFIX + 'registerController';
      var CALL_CONTROLLER_ACTION_COMMAND_NAME = DOLPHIN_PLATFORM_PREFIX + 'callControllerAction';
      var DESTROY_CONTROLLER_COMMAND_NAME = DOLPHIN_PLATFORM_PREFIX + 'destroyController';

      var CONTROLLER_NAME = 'controllerName';
      var CONTROLLER_ID = 'controllerId';
      var MODEL = 'model';
      var ACTION_NAME = 'actionName';
      var ERROR_CODE = 'errorCode';
      var PARAM_PREFIX = '_';

      function ControllerManager(dolphin, classRepository, connector) {
        checkMethod('ControllerManager(dolphin, classRepository, connector)');
        checkParam(dolphin, 'dolphin');
        checkParam(classRepository, 'classRepository');
        checkParam(connector, 'connector');

        this.dolphin = dolphin;
        this.classRepository = classRepository;
        this.connector = connector;
        this.controllers = new Set();
      }

      ControllerManager.prototype.createController = function (name) {
        checkMethod('ControllerManager.createController(name)');
        checkParam(name, 'name');

        var self = this;
        var controllerId, modelId, model, controller;
        return new Promise(function (resolve) {
          self.connector.getHighlanderPM().then(function (highlanderPM) {
            highlanderPM.findAttributeByPropertyName(CONTROLLER_NAME).setValue(name);
            self.connector.invoke(REGISTER_CONTROLLER_COMMAND_NAME).then(function () {
              controllerId = highlanderPM.findAttributeByPropertyName(CONTROLLER_ID).getValue();
              modelId = highlanderPM.findAttributeByPropertyName(MODEL).getValue();
              model = self.classRepository.mapDolphinToBean(modelId);
              controller = new ControllerProxy(controllerId, model, self);
              self.controllers.add(controller);
              resolve(controller);
            });
          });
        });
      };

      ControllerManager.prototype.invokeAction = function (controllerId, actionName, params) {
        checkMethod('ControllerManager.invokeAction(controllerId, actionName, params)');
        checkParam(controllerId, 'controllerId');
        checkParam(actionName, 'actionName');

        var self = this;
        return new Promise(function (resolve, reject) {

          var attributes = [self.dolphin.attribute(SOURCE_SYSTEM, null, SOURCE_SYSTEM_CLIENT), self.dolphin.attribute(CONTROLLER_ID, null, controllerId), self.dolphin.attribute(ACTION_NAME, null, actionName), self.dolphin.attribute(ERROR_CODE)];

          if (exists(params)) {
            for (var prop in params) {
              if (params.hasOwnProperty(prop)) {
                var param = self.classRepository.mapParamToDolphin(params[prop]);
                attributes.push(self.dolphin.attribute(PARAM_PREFIX + prop, null, param, 'VALUE'));
              }
            }
          }

          var pm = self.dolphin.presentationModel.apply(self.dolphin, [null, ACTION_CALL_BEAN].concat(attributes));

          self.connector.invoke(CALL_CONTROLLER_ACTION_COMMAND_NAME, params).then(function () {
            var isError = pm.findAttributeByPropertyName(ERROR_CODE).getValue();
            if (isError) {
              reject(new Error("ControllerAction caused an error"));
            } else {
              resolve();
            }
            self.dolphin.deletePresentationModel(pm);
          });
        });
      };

      ControllerManager.prototype.destroyController = function (controller) {
        checkMethod('ControllerManager.destroyController(controller)');
        checkParam(controller, 'controller');

        var self = this;
        return new Promise(function (resolve) {
          self.connector.getHighlanderPM().then(function (highlanderPM) {
            self.controllers.delete(controller);
            highlanderPM.findAttributeByPropertyName(CONTROLLER_ID).setValue(controller.controllerId);
            self.connector.invoke(DESTROY_CONTROLLER_COMMAND_NAME).then(resolve);
          });
        });
      };

      ControllerManager.prototype.destroy = function () {
        var controllersCopy = this.controllers;
        var promises = [];
        this.controllers = new Set();
        controllersCopy.forEach(function (controller) {
          try {
            promises.push(controller.destroy());
          } catch (e) {
            // ignore
          }
        });
        return Promise.all(promises);
      };

      exports.ControllerManager = ControllerManager;
    }, { "../bower_components/core.js/library/fn/promise": 2, "../bower_components/core.js/library/fn/set": 3, "./connector.js": 405, "./controllerproxy.js": 408, "./utils.js": 412 }], 408: [function (_dereq_, module, exports) {
      /* Copyright 2015 Canoo Engineering AG.
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *     http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      /*jslint browserify: true */
      /* global console */
      "use strict";

      var Set = _dereq_('../bower_components/core.js/library/fn/set');
      var utils = _dereq_('./utils.js');
      var checkMethod = utils.checkMethod;
      var checkParam = utils.checkParam;

      function ControllerProxy(controllerId, model, manager) {
        checkMethod('ControllerProxy(controllerId, model, manager)');
        checkParam(controllerId, 'controllerId');
        checkParam(model, 'model');
        checkParam(manager, 'manager');

        this.controllerId = controllerId;
        this.model = model;
        this.manager = manager;
        this.destroyed = false;
        this.onDestroyedHandlers = new Set();
      }

      ControllerProxy.prototype.invoke = function (name, params) {
        checkMethod('ControllerProxy.invoke(name, params)');
        checkParam(name, 'name');

        if (this.destroyed) {
          throw new Error('The controller was already destroyed');
        }
        return this.manager.invokeAction(this.controllerId, name, params);
      };

      ControllerProxy.prototype.destroy = function () {
        if (this.destroyed) {
          throw new Error('The controller was already destroyed');
        }
        this.destroyed = true;
        this.onDestroyedHandlers.forEach(function (handler) {
          try {
            handler(this);
          } catch (e) {
            console.warn('An exception occurred while calling an onDestroyed-handler', e);
          }
        }, this);
        return this.manager.destroyController(this);
      };

      ControllerProxy.prototype.onDestroyed = function (handler) {
        checkMethod('ControllerProxy.onDestroyed(handler)');
        checkParam(handler, 'handler');

        var self = this;
        this.onDestroyedHandlers.add(handler);
        return {
          unsubscribe: function unsubscribe() {
            self.onDestroyedHandlers.delete(handler);
          }
        };
      };

      exports.ControllerProxy = ControllerProxy;
    }, { "../bower_components/core.js/library/fn/set": 3, "./utils.js": 412 }], 409: [function (_dereq_, module, exports) {
      /* Copyright 2015 Canoo Engineering AG.
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *     http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      /*jslint browserify: true */
      /* global console */
      "use strict";

      _dereq_('babel-polyfill');
      var OpenDolphin = _dereq_('../opendolphin/build/OpenDolphin.js');

      var utils = _dereq_('./utils.js');
      var exists = utils.exists;
      var checkMethod = utils.checkMethod;
      var checkParam = utils.checkParam;
      var Connector = _dereq_('./connector.js').Connector;
      var BeanManager = _dereq_('./beanmanager.js').BeanManager;
      var ClassRepository = _dereq_('./classrepo.js').ClassRepository;
      var ControllerManager = _dereq_('./controllermanager.js').ControllerManager;
      var ClientContext = _dereq_('./clientcontext.js').ClientContext;
      var HttpTransmitter = _dereq_('./httpTransmitter.es6').default;

      exports.connect = function (url, config) {
        checkMethod('connect(url, config)');
        checkParam(url, 'url');

        var builder = OpenDolphin.makeDolphin().url(url).reset(false).slackMS(4).supportCORS(true).maxBatchSize(Number.MAX_SAFE_INTEGER);
        if (exists(config)) {
          if (exists(config.errorHandler)) {
            builder.errorHandler(config.errorHandler);
          }
          if (exists(config.headersInfo) && Object.keys(config.headersInfo).length > 0) {
            builder.headersInfo(config.headersInfo);
          }
        }

        var dolphin = builder.build();

        var transmitter = new HttpTransmitter(url, exists(config) ? config.headersInfo : null);
        transmitter.on('error', function (error) {
          clientContext.emit('error', error);
        });
        dolphin.clientConnector.transmitter = transmitter;

        var classRepository = new ClassRepository(dolphin);
        var beanManager = new BeanManager(classRepository);
        var connector = new Connector(url, dolphin, classRepository, config);
        var controllerManager = new ControllerManager(dolphin, classRepository, connector);

        var clientContext = new ClientContext(dolphin, beanManager, controllerManager, connector);
        return clientContext;
      };
    }, { "../opendolphin/build/OpenDolphin.js": 398, "./beanmanager.js": 401, "./classrepo.js": 402, "./clientcontext.js": 403, "./connector.js": 405, "./controllermanager.js": 407, "./httpTransmitter.es6": 411, "./utils.js": 412, "babel-polyfill": 80 }], 410: [function (_dereq_, module, exports) {
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }return call && ((typeof call === "undefined" ? "undefined" : _typeof2(call)) === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof2(superClass)));
        }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
      }

      var DolphinRemotingError = exports.DolphinRemotingError = function (_Error) {
        _inherits(DolphinRemotingError, _Error);

        function DolphinRemotingError() {
          var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Network Error';
          var detail = arguments[1];

          _classCallCheck(this, DolphinRemotingError);

          var _this = _possibleConstructorReturn(this, (DolphinRemotingError.__proto__ || Object.getPrototypeOf(DolphinRemotingError)).call(this, message));

          _this.detail = detail || undefined;
          return _this;
        }

        return DolphinRemotingError;
      }(Error);

      var DolphinSessionError = exports.DolphinSessionError = function (_Error2) {
        _inherits(DolphinSessionError, _Error2);

        function DolphinSessionError() {
          var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Session Error';

          _classCallCheck(this, DolphinSessionError);

          return _possibleConstructorReturn(this, (DolphinSessionError.__proto__ || Object.getPrototypeOf(DolphinSessionError)).call(this, message));
        }

        return DolphinSessionError;
      }(Error);

      var HttpResponseError = exports.HttpResponseError = function (_Error3) {
        _inherits(HttpResponseError, _Error3);

        function HttpResponseError() {
          var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Http Response Error';

          _classCallCheck(this, HttpResponseError);

          return _possibleConstructorReturn(this, (HttpResponseError.__proto__ || Object.getPrototypeOf(HttpResponseError)).call(this, message));
        }

        return HttpResponseError;
      }(Error);
    }, {}], 411: [function (_dereq_, module, exports) {
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }(); /* Copyright 2016 Canoo Engineering AG.
            *
            * Licensed under the Apache License, Version 2.0 (the "License");
            * you may not use this file except in compliance with the License.
            * You may obtain a copy of the License at
            *
            *     http://www.apache.org/licenses/LICENSE-2.0
            *
            * Unless required by applicable law or agreed to in writing, software
            * distributed under the License is distributed on an "AS IS" BASIS,
            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
            * See the License for the specific language governing permissions and
            * limitations under the License.
            */

      var _emitterComponent = _dereq_('emitter-component');

      var _emitterComponent2 = _interopRequireDefault(_emitterComponent);

      var _utils = _dereq_('./utils');

      var _errors = _dereq_('./errors.es6');

      var _codec = _dereq_('./codec.es6');

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var FINISHED = 4;
      var SUCCESS = 200;
      var REQUEST_TIMEOUT = 408;

      var DOLPHIN_PLATFORM_PREFIX = 'dolphin_platform_intern_';
      var CLIENT_ID_HTTP_HEADER_NAME = DOLPHIN_PLATFORM_PREFIX + 'dolphinClientId';

      var HttpTransmitter = function () {
        function HttpTransmitter(url, headersInfo) {
          _classCallCheck(this, HttpTransmitter);

          this.url = url;
          this.headersInfo = headersInfo;
        }

        _createClass(HttpTransmitter, [{
          key: 'send',
          value: function send(commands) {
            var _this = this;

            return new Promise(function (resolve, reject) {
              var http = new XMLHttpRequest();
              http.withCredentials = true;
              http.onerror = function (error) {
                return reject(new _errors.DolphinRemotingError('HttpTransmitter: Network error', error));
              };
              http.onreadystatechange = function () {
                if (http.readyState === FINISHED) {
                  switch (http.status) {
                    case SUCCESS:
                      {
                        var currentClientId = http.getResponseHeader(CLIENT_ID_HTTP_HEADER_NAME);
                        if ((0, _utils.exists)(currentClientId)) {
                          if ((0, _utils.exists)(_this.clientId) && _this.clientId !== currentClientId) {
                            reject(new _errors.DolphinSessionError('HttpTransmitter: ClientId of the response did not match'));
                          }
                          _this.clientId = currentClientId;
                        } else {
                          reject(new _errors.DolphinSessionError('HttpTransmitter: Server did not send a clientId'));
                        }
                        resolve(http.responseText);
                        break;
                      }

                    case REQUEST_TIMEOUT:
                      reject(new _errors.DolphinSessionError('HttpTransmitter: Session Timeout'));
                      break;

                    default:
                      reject(new _errors.HttpResponseError('HttpTransmitter: HTTP Status != 200 (' + http.status + ')'));
                      break;
                  }
                }
              };

              http.open('POST', _this.url);
              if ((0, _utils.exists)(_this.clientId)) {
                http.setRequestHeader(CLIENT_ID_HTTP_HEADER_NAME, _this.clientId);
              }

              if ((0, _utils.exists)(_this.headersInfo)) {
                for (var i in _this.headersInfo) {
                  if (_this.headersInfo.hasOwnProperty(i)) {
                    http.setRequestHeader(i, _this.headersInfo[i]);
                  }
                }
              }
              http.send((0, _codec.encode)(commands));
            });
          }
        }, {
          key: 'transmit',
          value: function transmit(commands, onDone) {
            var _this2 = this;

            this.send(commands).then(function (responseText) {
              if (responseText.trim().length > 0) {
                try {
                  var responseCommands = (0, _codec.decode)(responseText);
                  onDone(responseCommands);
                } catch (err) {
                  _this2.emit('error', new _errors.HttpResponseError('HttpTransmitter: Parse error: (Incorrect response = ' + responseText + ')'));
                  onDone([]);
                }
              } else {
                _this2.emit('error', new _errors.HttpResponseError('HttpTransmitter: Empty response'));
                onDone([]);
              }
            }).catch(function (error) {
              _this2.emit('error', error);
              onDone([]);
            });
          }
        }, {
          key: 'signal',
          value: function signal(command) {
            var _this3 = this;

            this.send([command]).catch(function (error) {
              return _this3.emit('error', error);
            });
          }
        }], [{
          key: 'reset',
          value: function reset() {
            throw new Error('HttpTransmitter.reset() has been deprecated');
          }
        }]);

        return HttpTransmitter;
      }();

      exports.default = HttpTransmitter;

      (0, _emitterComponent2.default)(HttpTransmitter.prototype);
    }, { "./codec.es6": 404, "./errors.es6": 410, "./utils": 412, "emitter-component": 375 }], 412: [function (_dereq_, module, exports) {
      /* Copyright 2015 Canoo Engineering AG.
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *     http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      /*jslint browserify: true */
      "use strict";

      var checkMethodName;

      var exists = function exists(object) {
        return typeof object !== 'undefined' && object !== null;
      };

      module.exports.exists = exists;

      module.exports.checkMethod = function (name) {
        checkMethodName = name;
      };

      module.exports.checkParam = function (param, parameterName) {
        if (!exists(param)) {
          throw new Error('The parameter ' + parameterName + ' is mandatory in ' + checkMethodName);
        }
      };
    }, {}] }, {}, [409])(409);
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],2:[function(_dereq_,module,exports){
/* Copyright 2015 Canoo Engineering AG.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var dolphinClient = _dereq_('../bower_components/dolphin-platform-js/dist/dolphin-platform.js');
angular.module('DolphinPlatform', []);

angular.module('DolphinPlatform').provider('$dolphinConfig', [function () {

    var $cfg = {};
    this.configure = function (cfg) {
        $cfg = cfg;
    };

    this.$get = function () {
        return $cfg;
    };
}]);

angular.module('DolphinPlatform').factory('dolphin', function () {
    return dolphinClient;
});

angular.module('DolphinPlatform').factory('vanillaClientContext', ['dolphin', '$dolphinConfig', '$window', '$log', function (dolphin, $dolphinConfig, $window, $log) {
    var vanillaClientContext = dolphin.connect($dolphinConfig.DOLPHIN_URL, $dolphinConfig);
    $log.debug('Basic Dolphin Platform context created');
    return vanillaClientContext;
}]);

angular.module('DolphinPlatform').factory('dolphinBinding', ['$rootScope', '$timeout', 'vanillaClientContext', '$log', function ($rootScope, $timeout, vanillaClientContext, $log) {

    $rootScope.waitingForGlobalDolphinApply = false;

    $rootScope.applyInAngular = function () {
        if (!$rootScope.waitingForGlobalDolphinApply) {
            $rootScope.waitingForGlobalDolphinApply = true;
            $timeout(function () {
                $rootScope.waitingForGlobalDolphinApply = false;
                $log.debug('Angular apply is called by Dolphin Platform');
                $rootScope.$apply();
            }, 100);
        }
    };

    var dolphinBinding = {

        injectArray: function injectArray(baseArray, startIndex, insertArray) {
            baseArray.splice.apply(baseArray, [startIndex, 0].concat(insertArray));
        },
        exists: function exists(object) {
            return typeof object !== 'undefined' && object !== null;
        },
        deepEqual: function deepEqual(array1, array2) {
            if (array1 === array2 || !this.exists(array1) && !this.exists(array2)) {
                return true;
            }
            if (this.exists(array1) !== this.exists(array2)) {
                return false;
            }
            var n = array1.length;
            if (array2.length !== n) {
                return false;
            }
            for (var i = 0; i < n; i++) {
                if (array1[i] !== array2[i]) {
                    return false;
                }
            }
            return true;
        },
        init: function init(beanManager) {
            beanManager.onAdded(dolphinBinding.onBeanAddedHandler);
            beanManager.onRemoved(dolphinBinding.onBeanRemovedHandler);
            beanManager.onBeanUpdate(dolphinBinding.onBeanUpdateHandler);
            beanManager.onArrayUpdate(dolphinBinding.onArrayUpdateHandler);

            $log.debug('Dolphin Platform binding listeners for Angular registered');
        },
        watchAttribute: function watchAttribute(bean, attribute) {
            $log.debug('Added Angular listener for property ' + attribute + ' of bean ' + JSON.stringify(bean));
            $rootScope.$watch(function () {
                return bean[attribute];
            }, function (newValue, oldValue) {
                $log.debug('Value ' + attribute + ' of bean ' + JSON.stringify(bean) + ' changed from ' + oldValue + ' to ' + newValue);
                vanillaClientContext.beanManager.classRepository.notifyBeanChange(bean, attribute, newValue);
            });
        },
        onBeanAddedHandler: function onBeanAddedHandler(bean) {
            $log.debug('Bean ' + JSON.stringify(bean) + ' added');

            for (var attr in bean) {
                dolphinBinding.watchAttribute(bean, attr);
            }

            $rootScope.applyInAngular();
        },
        onBeanRemovedHandler: function onBeanRemovedHandler(bean) {
            $log.debug('Bean ' + JSON.stringify(bean) + ' removed');
            $rootScope.applyInAngular();
        },
        onBeanUpdateHandler: function onBeanUpdateHandler(bean, propertyName, newValue, oldValue) {
            var newProperty = true;
            for (var attr in bean) {
                if (attr === propertyName) {
                    newProperty = false;
                }
            }

            if (newProperty) {
                $log.debug('Value ' + propertyName + ' was added to bean ' + JSON.stringify(bean));
                dolphinBinding.watchAttribute(bean, propertyName);
            }

            if (oldValue === newValue) {
                $log.debug('Received bean update for property ' + propertyName + ' without any change');
                return;
            }

            $log.debug('Bean update for property ' + propertyName + ' with new value "' + newValue + '"');

            bean[propertyName] = newValue;
            $rootScope.applyInAngular();
        },
        onArrayUpdateHandler: function onArrayUpdateHandler(bean, propertyName, index, count, newElements) {
            var array = bean[propertyName];
            var oldElements = array.slice(index, index + count);
            if (dolphinBinding.deepEqual(newElements, oldElements)) {
                return;
            }

            $log.debug('Array update for property ' + propertyName + ' starting at index ' + index + ' with ' + JSON.stringify(newElements));

            if (typeof newElements === 'undefined' || newElements && newElements.length === 0) {
                array.splice(index, count);
                $rootScope.applyInAngular();
            } else {
                dolphinBinding.injectArray(array, index, newElements);

                for (bean in newElements) {
                    for (var attr in bean) {
                        dolphinBinding.watchAttribute(bean, attr);
                    }
                }

                $rootScope.applyInAngular();
            }
        }
    };

    $log.debug('Dolphin Platform binding created');

    return dolphinBinding;
}]);

angular.module('DolphinPlatform').factory('clientContext', ['vanillaClientContext', 'dolphinBinding', '$window', '$log', function (vanillaClientContext, dolphinBinding, $window, $log) {
    var clientContext = {
        createController: function createController(scope, controllerName) {
            return vanillaClientContext.createController(controllerName).then(function (controllerProxy) {
                $log.debug('Creating Dolphin Platform controller ' + controllerName);
                scope.$on('$destroy', function () {
                    $log.debug('Destroying Dolphin Platform controller ' + controllerName);
                    controllerProxy.destroy();
                });
                scope.model = controllerProxy.model;
                return controllerProxy;
            });
        },
        disconnect: function disconnect() {
            vanillaClientContext.disconnect();
            $log.debug('Dolphin Platform context disconnected');
        }
    };

    dolphinBinding.init(vanillaClientContext.beanManager);

    $window.onbeforeunload = clientContext.disconnect;

    $log.debug('Dolphin Platform context created');

    return clientContext;
}]);

},{"../bower_components/dolphin-platform-js/dist/dolphin-platform.js":1}]},{},[2])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvYnJvd3Nlci1wYWNrL19wcmVsdWRlLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9jb3JlLmpzL2xpYnJhcnkvZm4vbWFwLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9jb3JlLmpzL2xpYnJhcnkvZm4vcHJvbWlzZS5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvY29yZS5qcy9saWJyYXJ5L2ZuL3NldC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvY29yZS5qcy9saWJyYXJ5L21vZHVsZXMvX2EtZnVuY3Rpb24uanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2NvcmUuanMvbGlicmFyeS9tb2R1bGVzL19hZGQtdG8tdW5zY29wYWJsZXMuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2NvcmUuanMvbGlicmFyeS9tb2R1bGVzL19hbi1pbnN0YW5jZS5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvY29yZS5qcy9saWJyYXJ5L21vZHVsZXMvX2FuLW9iamVjdC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvY29yZS5qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LWZyb20taXRlcmFibGUuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2NvcmUuanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvY29yZS5qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LW1ldGhvZHMuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2NvcmUuanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9jb3JlLmpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jcmVhdGUuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2NvcmUuanMvbGlicmFyeS9tb2R1bGVzL19jbGFzc29mLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9jb3JlLmpzL2xpYnJhcnkvbW9kdWxlcy9fY29mLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9jb3JlLmpzL2xpYnJhcnkvbW9kdWxlcy9fY29sbGVjdGlvbi1zdHJvbmcuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2NvcmUuanMvbGlicmFyeS9tb2R1bGVzL19jb2xsZWN0aW9uLXRvLWpzb24uanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2NvcmUuanMvbGlicmFyeS9tb2R1bGVzL19jb2xsZWN0aW9uLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9jb3JlLmpzL2xpYnJhcnkvbW9kdWxlcy9fY29yZS5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvY29yZS5qcy9saWJyYXJ5L21vZHVsZXMvX2N0eC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvY29yZS5qcy9saWJyYXJ5L21vZHVsZXMvX2RlZmluZWQuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2NvcmUuanMvbGlicmFyeS9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvY29yZS5qcy9saWJyYXJ5L21vZHVsZXMvX2RvbS1jcmVhdGUuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2NvcmUuanMvbGlicmFyeS9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9jb3JlLmpzL2xpYnJhcnkvbW9kdWxlcy9fZXhwb3J0LmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9jb3JlLmpzL2xpYnJhcnkvbW9kdWxlcy9fZmFpbHMuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2NvcmUuanMvbGlicmFyeS9tb2R1bGVzL19mb3Itb2YuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2NvcmUuanMvbGlicmFyeS9tb2R1bGVzL19nbG9iYWwuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2NvcmUuanMvbGlicmFyeS9tb2R1bGVzL19oYXMuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2NvcmUuanMvbGlicmFyeS9tb2R1bGVzL19oaWRlLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9jb3JlLmpzL2xpYnJhcnkvbW9kdWxlcy9faHRtbC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvY29yZS5qcy9saWJyYXJ5L21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9jb3JlLmpzL2xpYnJhcnkvbW9kdWxlcy9faW52b2tlLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9jb3JlLmpzL2xpYnJhcnkvbW9kdWxlcy9faW9iamVjdC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvY29yZS5qcy9saWJyYXJ5L21vZHVsZXMvX2lzLWFycmF5LWl0ZXIuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2NvcmUuanMvbGlicmFyeS9tb2R1bGVzL19pcy1hcnJheS5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvY29yZS5qcy9saWJyYXJ5L21vZHVsZXMvX2lzLW9iamVjdC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvY29yZS5qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY2FsbC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvY29yZS5qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9jb3JlLmpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1kZWZpbmUuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2NvcmUuanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWRldGVjdC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvY29yZS5qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItc3RlcC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvY29yZS5qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXJhdG9ycy5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvY29yZS5qcy9saWJyYXJ5L21vZHVsZXMvX2xpYnJhcnkuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2NvcmUuanMvbGlicmFyeS9tb2R1bGVzL19tZXRhLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9jb3JlLmpzL2xpYnJhcnkvbW9kdWxlcy9fbWljcm90YXNrLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9jb3JlLmpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvY29yZS5qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvY29yZS5qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcHMuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2NvcmUuanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ3BvLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9jb3JlLmpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2NvcmUuanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvY29yZS5qcy9saWJyYXJ5L21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2NvcmUuanMvbGlicmFyeS9tb2R1bGVzL19yZWRlZmluZS1hbGwuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2NvcmUuanMvbGlicmFyeS9tb2R1bGVzL19yZWRlZmluZS5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvY29yZS5qcy9saWJyYXJ5L21vZHVsZXMvX3NldC1zcGVjaWVzLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9jb3JlLmpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2NvcmUuanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQta2V5LmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9jb3JlLmpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9jb3JlLmpzL2xpYnJhcnkvbW9kdWxlcy9fc3BlY2llcy1jb25zdHJ1Y3Rvci5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvY29yZS5qcy9saWJyYXJ5L21vZHVsZXMvX3N0cmluZy1hdC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvY29yZS5qcy9saWJyYXJ5L21vZHVsZXMvX3Rhc2suanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2NvcmUuanMvbGlicmFyeS9tb2R1bGVzL190by1pbmRleC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvY29yZS5qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWludGVnZXIuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2NvcmUuanMvbGlicmFyeS9tb2R1bGVzL190by1pb2JqZWN0LmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9jb3JlLmpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9jb3JlLmpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tb2JqZWN0LmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9jb3JlLmpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9jb3JlLmpzL2xpYnJhcnkvbW9kdWxlcy9fdWlkLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9jb3JlLmpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9jb3JlLmpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2NvcmUuanMvbGlicmFyeS9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvY29yZS5qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm1hcC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvY29yZS5qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2NvcmUuanMvbGlicmFyeS9tb2R1bGVzL2VzNi5wcm9taXNlLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9jb3JlLmpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc2V0LmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9jb3JlLmpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9jb3JlLmpzL2xpYnJhcnkvbW9kdWxlcy9lczcubWFwLnRvLWpzb24uanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2NvcmUuanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zZXQudG8tanNvbi5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvY29yZS5qcy9saWJyYXJ5L21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9iYWJlbC1wb2x5ZmlsbC9saWIvaW5kZXguanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9mbi9yZWdleHAvZXNjYXBlLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYS1mdW5jdGlvbi5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2EtbnVtYmVyLXZhbHVlLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYW4taW5zdGFuY2UuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hbi1vYmplY3QuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1jb3B5LXdpdGhpbi5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWZpbGwuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1mcm9tLWl0ZXJhYmxlLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktaW5jbHVkZXMuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1tZXRob2RzLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktcmVkdWNlLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jb25zdHJ1Y3Rvci5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LXNwZWNpZXMtY3JlYXRlLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYmluZC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NsYXNzb2YuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2YuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLXN0cm9uZy5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24tdG8tanNvbi5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24td2Vhay5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24uanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb3JlLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY3JlYXRlLXByb3BlcnR5LmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY3R4LmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGF0ZS10by1wcmltaXRpdmUuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kZWZpbmVkLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kb20tY3JlYXRlLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2VudW0ta2V5cy5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2V4cG9ydC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLWlzLXJlZ2V4cC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZml4LXJlLXdrcy5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZsYWdzLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZm9yLW9mLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZ2xvYmFsLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGFzLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGlkZS5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2h0bWwuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2luaGVyaXQtaWYtcmVxdWlyZWQuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pbnZva2UuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pb2JqZWN0LmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtYXJyYXktaXRlci5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLWFycmF5LmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtaW50ZWdlci5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLW9iamVjdC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLXJlZ2V4cC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItY2FsbC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1kZWZpbmUuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWRldGVjdC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItc3RlcC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXJhdG9ycy5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2tleW9mLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbGlicmFyeS5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21hdGgtZXhwbTEuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tYXRoLWxvZzFwLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWF0aC1zaWduLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWV0YS5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21ldGFkYXRhLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWljcm90YXNrLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWFzc2lnbi5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1jcmVhdGUuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHAuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHBzLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWZvcmNlZC1wYW0uanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wZC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BuLWV4dC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BuLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ3BvLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1waWUuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qtc2FwLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXRvLWFycmF5LmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb3duLWtleXMuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wYXJzZS1mbG9hdC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3BhcnNlLWludC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3BhcnRpYWwuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wYXRoLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLWFsbC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcmVwbGFjZXIuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zYW1lLXZhbHVlLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LXByb3RvLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LXNwZWNpZXMuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC1rZXkuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zaGFyZWQuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaWN0LW1ldGhvZC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1hdC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1jb250ZXh0LmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWh0bWwuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctcGFkLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXJlcGVhdC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy10cmltLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXdzLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdGFzay5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWluZGV4LmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8taW50ZWdlci5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWlvYmplY3QuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1sZW5ndGguanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1vYmplY3QuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1wcmltaXRpdmUuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190eXBlZC1hcnJheS5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3R5cGVkLWJ1ZmZlci5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3R5cGVkLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdWlkLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fd2tzLWRlZmluZS5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy1leHQuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvY29yZS5yZWdleHAuZXNjYXBlLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuY29weS13aXRoaW4uanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5ldmVyeS5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbGwuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maWx0ZXIuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maW5kLWluZGV4LmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmluZC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZvci1lYWNoLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZnJvbS5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmluZGV4LW9mLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaXMtYXJyYXkuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmpvaW4uanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5sYXN0LWluZGV4LW9mLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkubWFwLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkub2YuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5yZWR1Y2UtcmlnaHQuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5yZWR1Y2UuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zbGljZS5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNvbWUuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zb3J0LmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc3BlY2llcy5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUubm93LmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS50by1pc28tc3RyaW5nLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS50by1qc29uLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS50by1wcmltaXRpdmUuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLXN0cmluZy5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmJpbmQuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5mdW5jdGlvbi5oYXMtaW5zdGFuY2UuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5mdW5jdGlvbi5uYW1lLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWFwLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hY29zaC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguYXNpbmguanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmF0YW5oLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5jYnJ0LmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5jbHozMi5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguY29zaC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguZXhwbTEuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmZyb3VuZC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguaHlwb3QuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmltdWwuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmxvZzEwLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5sb2cxcC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgubG9nMi5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguc2lnbi5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguc2luaC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgudGFuaC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgudHJ1bmMuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuY29uc3RydWN0b3IuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuZXBzaWxvbi5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1maW5pdGUuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtaW50ZWdlci5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1uYW4uanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtc2FmZS1pbnRlZ2VyLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLm1heC1zYWZlLWludGVnZXIuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIubWluLXNhZmUtaW50ZWdlci5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5wYXJzZS1mbG9hdC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5wYXJzZS1pbnQuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIudG8tZml4ZWQuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIudG8tcHJlY2lzaW9uLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbi5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnRpZXMuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5LmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmZyZWV6ZS5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtcHJvdG90eXBlLW9mLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLWV4dGVuc2libGUuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZnJvemVuLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLXNlYWxlZC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnByZXZlbnQtZXh0ZW5zaW9ucy5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5zZWFsLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucGFyc2UtZmxvYXQuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5wYXJzZS1pbnQuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5wcm9taXNlLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5hcHBseS5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuY29uc3RydWN0LmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5kZWZpbmUtcHJvcGVydHkuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmRlbGV0ZS1wcm9wZXJ0eS5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZW51bWVyYXRlLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC1wcm90b3R5cGUtb2YuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuaGFzLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5pcy1leHRlbnNpYmxlLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5vd24ta2V5cy5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QucHJldmVudC1leHRlbnNpb25zLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5zZXQtcHJvdG90eXBlLW9mLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5zZXQuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuY29uc3RydWN0b3IuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuZmxhZ3MuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAubWF0Y2guanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAucmVwbGFjZS5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5zZWFyY2guanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuc3BsaXQuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAudG8tc3RyaW5nLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc2V0LmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmFuY2hvci5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5iaWcuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuYmxpbmsuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuYm9sZC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5jb2RlLXBvaW50LWF0LmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmVuZHMtd2l0aC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5maXhlZC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5mb250Y29sb3IuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZm9udHNpemUuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZnJvbS1jb2RlLXBvaW50LmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmluY2x1ZGVzLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLml0YWxpY3MuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcubGluay5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5yYXcuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcucmVwZWF0LmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnNtYWxsLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN0YXJ0cy13aXRoLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN0cmlrZS5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdWIuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3VwLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnRyaW0uanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zeW1ib2wuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5hcnJheS1idWZmZXIuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5kYXRhLXZpZXcuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDMyLWFycmF5LmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuZmxvYXQ2NC1hcnJheS5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmludDE2LWFycmF5LmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50MzItYXJyYXkuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5pbnQ4LWFycmF5LmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDE2LWFycmF5LmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDMyLWFycmF5LmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDgtYXJyYXkuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1jbGFtcGVkLWFycmF5LmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYud2Vhay1tYXAuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi53ZWFrLXNldC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LmFycmF5LmluY2x1ZGVzLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuYXNhcC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LmVycm9yLmlzLWVycm9yLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWFwLnRvLWpzb24uanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmlhZGRoLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5pbXVsaC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguaXN1YmguanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLnVtdWxoLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmRlZmluZS1nZXR0ZXIuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZGVmaW5lLXNldHRlci5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5lbnRyaWVzLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcnMuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QubG9va3VwLWdldHRlci5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5sb29rdXAtc2V0dGVyLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LnZhbHVlcy5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9ic2VydmFibGUuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmRlZmluZS1tZXRhZGF0YS5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZGVsZXRlLW1ldGFkYXRhLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtbWV0YWRhdGEta2V5cy5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW1ldGFkYXRhLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtb3duLW1ldGFkYXRhLWtleXMuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1vd24tbWV0YWRhdGEuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0Lmhhcy1tZXRhZGF0YS5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuaGFzLW93bi1tZXRhZGF0YS5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QubWV0YWRhdGEuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zZXQudG8tanNvbi5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy5hdC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy5tYXRjaC1hbGwuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcucGFkLWVuZC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy5wYWQtc3RhcnQuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcudHJpbS1sZWZ0LmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnRyaW0tcmlnaHQuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3IuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZS5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN5c3RlbS5nbG9iYWwuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5pbW1lZGlhdGUuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi50aW1lcnMuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ub2RlX21vZHVsZXMvY29yZS1qcy9zaGltLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL2VtaXR0ZXItY29tcG9uZW50L2luZGV4LmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9vcGVuZG9scGhpbi9idWlsZC9BdHRyaWJ1dGUuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9vcGVuZG9scGhpbi9idWlsZC9BdHRyaWJ1dGVDcmVhdGVkTm90aWZpY2F0aW9uLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvb3BlbmRvbHBoaW4vYnVpbGQvQ2hhbmdlQXR0cmlidXRlTWV0YWRhdGFDb21tYW5kLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvb3BlbmRvbHBoaW4vYnVpbGQvQ2xpZW50QXR0cmlidXRlLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvb3BlbmRvbHBoaW4vYnVpbGQvQ2xpZW50Q29ubmVjdG9yLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvb3BlbmRvbHBoaW4vYnVpbGQvQ2xpZW50RG9scGhpbi5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L29wZW5kb2xwaGluL2J1aWxkL0NsaWVudE1vZGVsU3RvcmUuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9vcGVuZG9scGhpbi9idWlsZC9DbGllbnRQcmVzZW50YXRpb25Nb2RlbC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L29wZW5kb2xwaGluL2J1aWxkL0NvZGVjLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvb3BlbmRvbHBoaW4vYnVpbGQvQ29tbWFuZC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L29wZW5kb2xwaGluL2J1aWxkL0NvbW1hbmRCYXRjaGVyLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvb3BlbmRvbHBoaW4vYnVpbGQvQ3JlYXRlUHJlc2VudGF0aW9uTW9kZWxDb21tYW5kLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvb3BlbmRvbHBoaW4vYnVpbGQvRGVsZXRlZEFsbFByZXNlbnRhdGlvbk1vZGVsc09mVHlwZU5vdGlmaWNhdGlvbi5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L29wZW5kb2xwaGluL2J1aWxkL0RlbGV0ZWRQcmVzZW50YXRpb25Nb2RlbE5vdGlmaWNhdGlvbi5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L29wZW5kb2xwaGluL2J1aWxkL0RvbHBoaW5CdWlsZGVyLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvb3BlbmRvbHBoaW4vYnVpbGQvRW1wdHlOb3RpZmljYXRpb24uanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9vcGVuZG9scGhpbi9idWlsZC9FdmVudEJ1cy5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L29wZW5kb2xwaGluL2J1aWxkL0h0dHBUcmFuc21pdHRlci5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L29wZW5kb2xwaGluL2J1aWxkL05hbWVkQ29tbWFuZC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L29wZW5kb2xwaGluL2J1aWxkL05vVHJhbnNtaXR0ZXIuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9vcGVuZG9scGhpbi9idWlsZC9PcGVuRG9scGhpbi5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L29wZW5kb2xwaGluL2J1aWxkL1NpZ25hbENvbW1hbmQuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9vcGVuZG9scGhpbi9idWlsZC9WYWx1ZUNoYW5nZWRDb21tYW5kLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvc3JjL2JlYW5tYW5hZ2VyLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvc3JjL2NsYXNzcmVwby5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L3NyYy9jbGllbnRjb250ZXh0LmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvc3JjL2NvZGVjLmVzNiIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L3NyYy9jb25uZWN0b3IuanMiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9zcmMvY29uc3RhbnRzLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvc3JjL2NvbnRyb2xsZXJtYW5hZ2VyLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvc3JjL2NvbnRyb2xsZXJwcm94eS5qcyIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L3NyYy9kb2xwaGluLmpzIiwiYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3QvYm93ZXJfY29tcG9uZW50cy9kb2xwaGluLXBsYXRmb3JtLWpzL2Rpc3Qvc3JjL2Vycm9ycy5lczYiLCJib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9zcmMvaHR0cFRyYW5zbWl0dGVyLmVzNiIsImJvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L2Jvd2VyX2NvbXBvbmVudHMvZG9scGhpbi1wbGF0Zm9ybS1qcy9kaXN0L3NyYy91dGlscy5qcyIsInNyYy9kb2xwaGluLXBsYXRmb3JtLWFuZ3VsYXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztBQ0FBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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Q3JCQSw0QkFDQTs7QUFDQTs0QkFFQTs4QkFDQTtBQUZBOztBQ0hBO0FBQ0EsMkJBQ0E7NEJBQ0E7MkJBQ0E7NEJBQ0E7NkJBQ0E7O0FBQ0Esb0NBQ0E7eURBQ0E7cUJBQ0EsT0FDQSxrQ0FDQSw0Q0FDQSxNQUNBO1lBQ0E7O0FBQ0E7Z0NBRUE7aUNBQ0E7QUFGQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QkFBa0IsMEJBQVUsS0FBVixFQUFpQixjQUFqQixFQUFpQztBQUMvQyxtQkFBTyxxQkFBcUIsZ0JBQXJCLENBQXNDLGNBQXRDLEVBQXNELElBQXRELENBQTJELFVBQVUsZUFBVixFQUEyQjtBQUN6RixxQkFBSyxLQUFMLENBQVcsMENBQTBDLGNBQXJEO0FBQ0Esc0JBQU0sR0FBTixDQUFVLFVBQVYsRUFBc0IsWUFBWTtBQUM5Qix5QkFBSyxLQUFMLENBQVcsNENBQTRDLGNBQXZEO0FBQ0Esb0NBQWdCLE9BQWhCO0FBQ0gsaUJBSEQ7QUFJQSxzQkFBTSxLQUFOLEdBQWMsZ0JBQWdCLEtBQTlCO0FBQ0EsdUJBQU8sZUFBUDtBQUNILGFBUk0sQ0FBUDtBQVNILFNBWGU7QUFZaEIsb0JBQVksc0JBQVk7QUFDcEIsaUNBQXFCLFVBQXJCO0FBQ0EsaUJBQUssS0FBTCxDQUFXLHVDQUFYO0FBQ0g7QUFmZSxLQUFwQjs7QUFrQkEsbUJBQWUsSUFBZixDQUFvQixxQkFBcUIsV0FBekM7O0FBRUEsWUFBUSxjQUFSLEdBQXlCLGNBQWMsVUFBdkM7O0FBRUEsU0FBSyxLQUFMLENBQVcsa0NBQVg7O0FBRUEsV0FBTyxhQUFQO0FBQ0gsQ0ExQjBELENBQTNEIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwicmVxdWlyZSgnLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm1hcCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczcubWFwLnRvLWpzb24nKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9fY29yZScpLk1hcDsiLCJyZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYucHJvbWlzZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL19jb3JlJykuUHJvbWlzZTsiLCJyZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc2V0Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNy5zZXQudG8tanNvbicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL19jb3JlJykuU2V0OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZih0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJyl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBDb25zdHJ1Y3RvciwgbmFtZSwgZm9yYmlkZGVuRmllbGQpe1xuICBpZighKGl0IGluc3RhbmNlb2YgQ29uc3RydWN0b3IpIHx8IChmb3JiaWRkZW5GaWVsZCAhPT0gdW5kZWZpbmVkICYmIGZvcmJpZGRlbkZpZWxkIGluIGl0KSl7XG4gICAgdGhyb3cgVHlwZUVycm9yKG5hbWUgKyAnOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEnKTtcbiAgfSByZXR1cm4gaXQ7XG59OyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKCFpc09iamVjdChpdCkpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59OyIsInZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0ZXIsIElURVJBVE9SKXtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3JPZihpdGVyLCBmYWxzZSwgcmVzdWx0LnB1c2gsIHJlc3VsdCwgSVRFUkFUT1IpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9MZW5ndGggID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCB0b0luZGV4ICAgPSByZXF1aXJlKCcuL190by1pbmRleCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihJU19JTkNMVURFUyl7XG4gIHJldHVybiBmdW5jdGlvbigkdGhpcywgZWwsIGZyb21JbmRleCl7XG4gICAgdmFyIE8gICAgICA9IHRvSU9iamVjdCgkdGhpcylcbiAgICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgICAsIGluZGV4ICA9IHRvSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpXG4gICAgICAsIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICBpZihJU19JTkNMVURFUyAmJiBlbCAhPSBlbCl3aGlsZShsZW5ndGggPiBpbmRleCl7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICBpZih2YWx1ZSAhPSB2YWx1ZSlyZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSN0b0luZGV4IGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvcig7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspaWYoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTyl7XG4gICAgICBpZihPW2luZGV4XSA9PT0gZWwpcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTsiLCIvLyAwIC0+IEFycmF5I2ZvckVhY2hcbi8vIDEgLT4gQXJyYXkjbWFwXG4vLyAyIC0+IEFycmF5I2ZpbHRlclxuLy8gMyAtPiBBcnJheSNzb21lXG4vLyA0IC0+IEFycmF5I2V2ZXJ5XG4vLyA1IC0+IEFycmF5I2ZpbmRcbi8vIDYgLT4gQXJyYXkjZmluZEluZGV4XG52YXIgY3R4ICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIElPYmplY3QgID0gcmVxdWlyZSgnLi9faW9iamVjdCcpXG4gICwgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBhc2MgICAgICA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY3JlYXRlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFRZUEUsICRjcmVhdGUpe1xuICB2YXIgSVNfTUFQICAgICAgICA9IFRZUEUgPT0gMVxuICAgICwgSVNfRklMVEVSICAgICA9IFRZUEUgPT0gMlxuICAgICwgSVNfU09NRSAgICAgICA9IFRZUEUgPT0gM1xuICAgICwgSVNfRVZFUlkgICAgICA9IFRZUEUgPT0gNFxuICAgICwgSVNfRklORF9JTkRFWCA9IFRZUEUgPT0gNlxuICAgICwgTk9fSE9MRVMgICAgICA9IFRZUEUgPT0gNSB8fCBJU19GSU5EX0lOREVYXG4gICAgLCBjcmVhdGUgICAgICAgID0gJGNyZWF0ZSB8fCBhc2M7XG4gIHJldHVybiBmdW5jdGlvbigkdGhpcywgY2FsbGJhY2tmbiwgdGhhdCl7XG4gICAgdmFyIE8gICAgICA9IHRvT2JqZWN0KCR0aGlzKVxuICAgICAgLCBzZWxmICAgPSBJT2JqZWN0KE8pXG4gICAgICAsIGYgICAgICA9IGN0eChjYWxsYmFja2ZuLCB0aGF0LCAzKVxuICAgICAgLCBsZW5ndGggPSB0b0xlbmd0aChzZWxmLmxlbmd0aClcbiAgICAgICwgaW5kZXggID0gMFxuICAgICAgLCByZXN1bHQgPSBJU19NQVAgPyBjcmVhdGUoJHRoaXMsIGxlbmd0aCkgOiBJU19GSUxURVIgPyBjcmVhdGUoJHRoaXMsIDApIDogdW5kZWZpbmVkXG4gICAgICAsIHZhbCwgcmVzO1xuICAgIGZvcig7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspaWYoTk9fSE9MRVMgfHwgaW5kZXggaW4gc2VsZil7XG4gICAgICB2YWwgPSBzZWxmW2luZGV4XTtcbiAgICAgIHJlcyA9IGYodmFsLCBpbmRleCwgTyk7XG4gICAgICBpZihUWVBFKXtcbiAgICAgICAgaWYoSVNfTUFQKXJlc3VsdFtpbmRleF0gPSByZXM7ICAgICAgICAgICAgLy8gbWFwXG4gICAgICAgIGVsc2UgaWYocmVzKXN3aXRjaChUWVBFKXtcbiAgICAgICAgICBjYXNlIDM6IHJldHVybiB0cnVlOyAgICAgICAgICAgICAgICAgICAgLy8gc29tZVxuICAgICAgICAgIGNhc2UgNTogcmV0dXJuIHZhbDsgICAgICAgICAgICAgICAgICAgICAvLyBmaW5kXG4gICAgICAgICAgY2FzZSA2OiByZXR1cm4gaW5kZXg7ICAgICAgICAgICAgICAgICAgIC8vIGZpbmRJbmRleFxuICAgICAgICAgIGNhc2UgMjogcmVzdWx0LnB1c2godmFsKTsgICAgICAgICAgICAgICAvLyBmaWx0ZXJcbiAgICAgICAgfSBlbHNlIGlmKElTX0VWRVJZKXJldHVybiBmYWxzZTsgICAgICAgICAgLy8gZXZlcnlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIElTX0ZJTkRfSU5ERVggPyAtMSA6IElTX1NPTUUgfHwgSVNfRVZFUlkgPyBJU19FVkVSWSA6IHJlc3VsdDtcbiAgfTtcbn07IiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBpc0FycmF5ICA9IHJlcXVpcmUoJy4vX2lzLWFycmF5JylcbiAgLCBTUEVDSUVTICA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3JpZ2luYWwpe1xuICB2YXIgQztcbiAgaWYoaXNBcnJheShvcmlnaW5hbCkpe1xuICAgIEMgPSBvcmlnaW5hbC5jb25zdHJ1Y3RvcjtcbiAgICAvLyBjcm9zcy1yZWFsbSBmYWxsYmFja1xuICAgIGlmKHR5cGVvZiBDID09ICdmdW5jdGlvbicgJiYgKEMgPT09IEFycmF5IHx8IGlzQXJyYXkoQy5wcm90b3R5cGUpKSlDID0gdW5kZWZpbmVkO1xuICAgIGlmKGlzT2JqZWN0KEMpKXtcbiAgICAgIEMgPSBDW1NQRUNJRVNdO1xuICAgICAgaWYoQyA9PT0gbnVsbClDID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSByZXR1cm4gQyA9PT0gdW5kZWZpbmVkID8gQXJyYXkgOiBDO1xufTsiLCIvLyA5LjQuMi4zIEFycmF5U3BlY2llc0NyZWF0ZShvcmlnaW5hbEFycmF5LCBsZW5ndGgpXG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9yaWdpbmFsLCBsZW5ndGgpe1xuICByZXR1cm4gbmV3IChzcGVjaWVzQ29uc3RydWN0b3Iob3JpZ2luYWwpKShsZW5ndGgpO1xufTsiLCIvLyBnZXR0aW5nIHRhZyBmcm9tIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpXG4gICwgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJylcbiAgLy8gRVMzIHdyb25nIGhlcmVcbiAgLCBBUkcgPSBjb2YoZnVuY3Rpb24oKXsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbihpdCwga2V5KXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBPLCBULCBCO1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAoVCA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVEFHKSkgPT0gJ3N0cmluZycgPyBUXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBBUkcgPyBjb2YoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAoQiA9IGNvZihPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IEI7XG59OyIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGRQICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGNyZWF0ZSAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpXG4gICwgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKVxuICAsIGN0eCAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBhbkluc3RhbmNlICA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJylcbiAgLCBkZWZpbmVkICAgICA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKVxuICAsIGZvck9mICAgICAgID0gcmVxdWlyZSgnLi9fZm9yLW9mJylcbiAgLCAkaXRlckRlZmluZSA9IHJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJylcbiAgLCBzdGVwICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpXG4gICwgc2V0U3BlY2llcyAgPSByZXF1aXJlKCcuL19zZXQtc3BlY2llcycpXG4gICwgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpXG4gICwgZmFzdEtleSAgICAgPSByZXF1aXJlKCcuL19tZXRhJykuZmFzdEtleVxuICAsIFNJWkUgICAgICAgID0gREVTQ1JJUFRPUlMgPyAnX3MnIDogJ3NpemUnO1xuXG52YXIgZ2V0RW50cnkgPSBmdW5jdGlvbih0aGF0LCBrZXkpe1xuICAvLyBmYXN0IGNhc2VcbiAgdmFyIGluZGV4ID0gZmFzdEtleShrZXkpLCBlbnRyeTtcbiAgaWYoaW5kZXggIT09ICdGJylyZXR1cm4gdGhhdC5faVtpbmRleF07XG4gIC8vIGZyb3plbiBvYmplY3QgY2FzZVxuICBmb3IoZW50cnkgPSB0aGF0Ll9mOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKXtcbiAgICBpZihlbnRyeS5rID09IGtleSlyZXR1cm4gZW50cnk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24od3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUil7XG4gICAgdmFyIEMgPSB3cmFwcGVyKGZ1bmN0aW9uKHRoYXQsIGl0ZXJhYmxlKXtcbiAgICAgIGFuSW5zdGFuY2UodGhhdCwgQywgTkFNRSwgJ19pJyk7XG4gICAgICB0aGF0Ll9pID0gY3JlYXRlKG51bGwpOyAvLyBpbmRleFxuICAgICAgdGhhdC5fZiA9IHVuZGVmaW5lZDsgICAgLy8gZmlyc3QgZW50cnlcbiAgICAgIHRoYXQuX2wgPSB1bmRlZmluZWQ7ICAgIC8vIGxhc3QgZW50cnlcbiAgICAgIHRoYXRbU0laRV0gPSAwOyAgICAgICAgIC8vIHNpemVcbiAgICAgIGlmKGl0ZXJhYmxlICE9IHVuZGVmaW5lZClmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgfSk7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIHtcbiAgICAgIC8vIDIzLjEuMy4xIE1hcC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgLy8gMjMuMi4zLjIgU2V0LnByb3RvdHlwZS5jbGVhcigpXG4gICAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKXtcbiAgICAgICAgZm9yKHZhciB0aGF0ID0gdGhpcywgZGF0YSA9IHRoYXQuX2ksIGVudHJ5ID0gdGhhdC5fZjsgZW50cnk7IGVudHJ5ID0gZW50cnkubil7XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYoZW50cnkucCllbnRyeS5wID0gZW50cnkucC5uID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGRlbGV0ZSBkYXRhW2VudHJ5LmldO1xuICAgICAgICB9XG4gICAgICAgIHRoYXQuX2YgPSB0aGF0Ll9sID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGF0W1NJWkVdID0gMDtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuMyBNYXAucHJvdG90eXBlLmRlbGV0ZShrZXkpXG4gICAgICAvLyAyMy4yLjMuNCBTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbihrZXkpe1xuICAgICAgICB2YXIgdGhhdCAgPSB0aGlzXG4gICAgICAgICAgLCBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XG4gICAgICAgIGlmKGVudHJ5KXtcbiAgICAgICAgICB2YXIgbmV4dCA9IGVudHJ5Lm5cbiAgICAgICAgICAgICwgcHJldiA9IGVudHJ5LnA7XG4gICAgICAgICAgZGVsZXRlIHRoYXQuX2lbZW50cnkuaV07XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYocHJldilwcmV2Lm4gPSBuZXh0O1xuICAgICAgICAgIGlmKG5leHQpbmV4dC5wID0gcHJldjtcbiAgICAgICAgICBpZih0aGF0Ll9mID09IGVudHJ5KXRoYXQuX2YgPSBuZXh0O1xuICAgICAgICAgIGlmKHRoYXQuX2wgPT0gZW50cnkpdGhhdC5fbCA9IHByZXY7XG4gICAgICAgICAgdGhhdFtTSVpFXS0tO1xuICAgICAgICB9IHJldHVybiAhIWVudHJ5O1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjIuMy42IFNldC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgLy8gMjMuMS4zLjUgTWFwLnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyosIHRoYXQgPSB1bmRlZmluZWQgKi8pe1xuICAgICAgICBhbkluc3RhbmNlKHRoaXMsIEMsICdmb3JFYWNoJyk7XG4gICAgICAgIHZhciBmID0gY3R4KGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCAzKVxuICAgICAgICAgICwgZW50cnk7XG4gICAgICAgIHdoaWxlKGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhpcy5fZil7XG4gICAgICAgICAgZihlbnRyeS52LCBlbnRyeS5rLCB0aGlzKTtcbiAgICAgICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgICAgICB3aGlsZShlbnRyeSAmJiBlbnRyeS5yKWVudHJ5ID0gZW50cnkucDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIDIzLjEuMy43IE1hcC5wcm90b3R5cGUuaGFzKGtleSlcbiAgICAgIC8vIDIzLjIuMy43IFNldC5wcm90b3R5cGUuaGFzKHZhbHVlKVxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KXtcbiAgICAgICAgcmV0dXJuICEhZ2V0RW50cnkodGhpcywga2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZihERVNDUklQVE9SUylkUChDLnByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBkZWZpbmVkKHRoaXNbU0laRV0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBDO1xuICB9LFxuICBkZWY6IGZ1bmN0aW9uKHRoYXQsIGtleSwgdmFsdWUpe1xuICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSlcbiAgICAgICwgcHJldiwgaW5kZXg7XG4gICAgLy8gY2hhbmdlIGV4aXN0aW5nIGVudHJ5XG4gICAgaWYoZW50cnkpe1xuICAgICAgZW50cnkudiA9IHZhbHVlO1xuICAgIC8vIGNyZWF0ZSBuZXcgZW50cnlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhhdC5fbCA9IGVudHJ5ID0ge1xuICAgICAgICBpOiBpbmRleCA9IGZhc3RLZXkoa2V5LCB0cnVlKSwgLy8gPC0gaW5kZXhcbiAgICAgICAgazoga2V5LCAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIGtleVxuICAgICAgICB2OiB2YWx1ZSwgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gdmFsdWVcbiAgICAgICAgcDogcHJldiA9IHRoYXQuX2wsICAgICAgICAgICAgIC8vIDwtIHByZXZpb3VzIGVudHJ5XG4gICAgICAgIG46IHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAvLyA8LSBuZXh0IGVudHJ5XG4gICAgICAgIHI6IGZhbHNlICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSByZW1vdmVkXG4gICAgICB9O1xuICAgICAgaWYoIXRoYXQuX2YpdGhhdC5fZiA9IGVudHJ5O1xuICAgICAgaWYocHJldilwcmV2Lm4gPSBlbnRyeTtcbiAgICAgIHRoYXRbU0laRV0rKztcbiAgICAgIC8vIGFkZCB0byBpbmRleFxuICAgICAgaWYoaW5kZXggIT09ICdGJyl0aGF0Ll9pW2luZGV4XSA9IGVudHJ5O1xuICAgIH0gcmV0dXJuIHRoYXQ7XG4gIH0sXG4gIGdldEVudHJ5OiBnZXRFbnRyeSxcbiAgc2V0U3Ryb25nOiBmdW5jdGlvbihDLCBOQU1FLCBJU19NQVApe1xuICAgIC8vIGFkZCAua2V5cywgLnZhbHVlcywgLmVudHJpZXMsIFtAQGl0ZXJhdG9yXVxuICAgIC8vIDIzLjEuMy40LCAyMy4xLjMuOCwgMjMuMS4zLjExLCAyMy4xLjMuMTIsIDIzLjIuMy41LCAyMy4yLjMuOCwgMjMuMi4zLjEwLCAyMy4yLjMuMTFcbiAgICAkaXRlckRlZmluZShDLCBOQU1FLCBmdW5jdGlvbihpdGVyYXRlZCwga2luZCl7XG4gICAgICB0aGlzLl90ID0gaXRlcmF0ZWQ7ICAvLyB0YXJnZXRcbiAgICAgIHRoaXMuX2sgPSBraW5kOyAgICAgIC8vIGtpbmRcbiAgICAgIHRoaXMuX2wgPSB1bmRlZmluZWQ7IC8vIHByZXZpb3VzXG4gICAgfSwgZnVuY3Rpb24oKXtcbiAgICAgIHZhciB0aGF0ICA9IHRoaXNcbiAgICAgICAgLCBraW5kICA9IHRoYXQuX2tcbiAgICAgICAgLCBlbnRyeSA9IHRoYXQuX2w7XG4gICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgIHdoaWxlKGVudHJ5ICYmIGVudHJ5LnIpZW50cnkgPSBlbnRyeS5wO1xuICAgICAgLy8gZ2V0IG5leHQgZW50cnlcbiAgICAgIGlmKCF0aGF0Ll90IHx8ICEodGhhdC5fbCA9IGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhhdC5fdC5fZikpe1xuICAgICAgICAvLyBvciBmaW5pc2ggdGhlIGl0ZXJhdGlvblxuICAgICAgICB0aGF0Ll90ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gc3RlcCgxKTtcbiAgICAgIH1cbiAgICAgIC8vIHJldHVybiBzdGVwIGJ5IGtpbmRcbiAgICAgIGlmKGtpbmQgPT0gJ2tleXMnICApcmV0dXJuIHN0ZXAoMCwgZW50cnkuayk7XG4gICAgICBpZihraW5kID09ICd2YWx1ZXMnKXJldHVybiBzdGVwKDAsIGVudHJ5LnYpO1xuICAgICAgcmV0dXJuIHN0ZXAoMCwgW2VudHJ5LmssIGVudHJ5LnZdKTtcbiAgICB9LCBJU19NQVAgPyAnZW50cmllcycgOiAndmFsdWVzJyAsICFJU19NQVAsIHRydWUpO1xuXG4gICAgLy8gYWRkIFtAQHNwZWNpZXNdLCAyMy4xLjIuMiwgMjMuMi4yLjJcbiAgICBzZXRTcGVjaWVzKE5BTUUpO1xuICB9XG59OyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpXG4gICwgZnJvbSAgICA9IHJlcXVpcmUoJy4vX2FycmF5LWZyb20taXRlcmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTkFNRSl7XG4gIHJldHVybiBmdW5jdGlvbiB0b0pTT04oKXtcbiAgICBpZihjbGFzc29mKHRoaXMpICE9IE5BTUUpdGhyb3cgVHlwZUVycm9yKE5BTUUgKyBcIiN0b0pTT04gaXNuJ3QgZ2VuZXJpY1wiKTtcbiAgICByZXR1cm4gZnJvbSh0aGlzKTtcbiAgfTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgbWV0YSAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhJylcbiAgLCBmYWlscyAgICAgICAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCBoaWRlICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIHJlZGVmaW5lQWxsICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJylcbiAgLCBmb3JPZiAgICAgICAgICA9IHJlcXVpcmUoJy4vX2Zvci1vZicpXG4gICwgYW5JbnN0YW5jZSAgICAgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpXG4gICwgaXNPYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIGRQICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGVhY2ggICAgICAgICAgID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDApXG4gICwgREVTQ1JJUFRPUlMgICAgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKE5BTUUsIHdyYXBwZXIsIG1ldGhvZHMsIGNvbW1vbiwgSVNfTUFQLCBJU19XRUFLKXtcbiAgdmFyIEJhc2UgID0gZ2xvYmFsW05BTUVdXG4gICAgLCBDICAgICA9IEJhc2VcbiAgICAsIEFEREVSID0gSVNfTUFQID8gJ3NldCcgOiAnYWRkJ1xuICAgICwgcHJvdG8gPSBDICYmIEMucHJvdG90eXBlXG4gICAgLCBPICAgICA9IHt9O1xuICBpZighREVTQ1JJUFRPUlMgfHwgdHlwZW9mIEMgIT0gJ2Z1bmN0aW9uJyB8fCAhKElTX1dFQUsgfHwgcHJvdG8uZm9yRWFjaCAmJiAhZmFpbHMoZnVuY3Rpb24oKXtcbiAgICBuZXcgQygpLmVudHJpZXMoKS5uZXh0KCk7XG4gIH0pKSl7XG4gICAgLy8gY3JlYXRlIGNvbGxlY3Rpb24gY29uc3RydWN0b3JcbiAgICBDID0gY29tbW9uLmdldENvbnN0cnVjdG9yKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCBtZXRob2RzKTtcbiAgICBtZXRhLk5FRUQgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIEMgPSB3cmFwcGVyKGZ1bmN0aW9uKHRhcmdldCwgaXRlcmFibGUpe1xuICAgICAgYW5JbnN0YW5jZSh0YXJnZXQsIEMsIE5BTUUsICdfYycpO1xuICAgICAgdGFyZ2V0Ll9jID0gbmV3IEJhc2U7XG4gICAgICBpZihpdGVyYWJsZSAhPSB1bmRlZmluZWQpZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGFyZ2V0W0FEREVSXSwgdGFyZ2V0KTtcbiAgICB9KTtcbiAgICBlYWNoKCdhZGQsY2xlYXIsZGVsZXRlLGZvckVhY2gsZ2V0LGhhcyxzZXQsa2V5cyx2YWx1ZXMsZW50cmllcyx0b0pTT04nLnNwbGl0KCcsJyksZnVuY3Rpb24oS0VZKXtcbiAgICAgIHZhciBJU19BRERFUiA9IEtFWSA9PSAnYWRkJyB8fCBLRVkgPT0gJ3NldCc7XG4gICAgICBpZihLRVkgaW4gcHJvdG8gJiYgIShJU19XRUFLICYmIEtFWSA9PSAnY2xlYXInKSloaWRlKEMucHJvdG90eXBlLCBLRVksIGZ1bmN0aW9uKGEsIGIpe1xuICAgICAgICBhbkluc3RhbmNlKHRoaXMsIEMsIEtFWSk7XG4gICAgICAgIGlmKCFJU19BRERFUiAmJiBJU19XRUFLICYmICFpc09iamVjdChhKSlyZXR1cm4gS0VZID09ICdnZXQnID8gdW5kZWZpbmVkIDogZmFsc2U7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9jW0tFWV0oYSA9PT0gMCA/IDAgOiBhLCBiKTtcbiAgICAgICAgcmV0dXJuIElTX0FEREVSID8gdGhpcyA6IHJlc3VsdDtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmKCdzaXplJyBpbiBwcm90bylkUChDLnByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiB0aGlzLl9jLnNpemU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBzZXRUb1N0cmluZ1RhZyhDLCBOQU1FKTtcblxuICBPW05BTUVdID0gQztcbiAgJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYsIE8pO1xuXG4gIGlmKCFJU19XRUFLKWNvbW1vbi5zZXRTdHJvbmcoQywgTkFNRSwgSVNfTUFQKTtcblxuICByZXR1cm4gQztcbn07IiwidmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHt2ZXJzaW9uOiAnMi40LjAnfTtcbmlmKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZiIsIi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZm4sIHRoYXQsIGxlbmd0aCl7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmKHRoYXQgPT09IHVuZGVmaW5lZClyZXR1cm4gZm47XG4gIHN3aXRjaChsZW5ndGgpe1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKGEpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbihhLCBiKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24oYSwgYiwgYyl7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbigvKiAuLi5hcmdzICovKXtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07IiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZihpdCA9PSB1bmRlZmluZWQpdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59OyIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gNzsgfX0pLmEgIT0gNztcbn0pOyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudFxuICAvLyBpbiBvbGQgSUUgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCdcbiAgLCBpcyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTsiLCIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTsiLCJ2YXIgZ2xvYmFsICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBjb3JlICAgICAgPSByZXF1aXJlKCcuL19jb3JlJylcbiAgLCBjdHggICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIGhpZGUgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG52YXIgJGV4cG9ydCA9IGZ1bmN0aW9uKHR5cGUsIG5hbWUsIHNvdXJjZSl7XG4gIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GXG4gICAgLCBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HXG4gICAgLCBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TXG4gICAgLCBJU19QUk9UTyAgPSB0eXBlICYgJGV4cG9ydC5QXG4gICAgLCBJU19CSU5EICAgPSB0eXBlICYgJGV4cG9ydC5CXG4gICAgLCBJU19XUkFQICAgPSB0eXBlICYgJGV4cG9ydC5XXG4gICAgLCBleHBvcnRzICAgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KVxuICAgICwgZXhwUHJvdG8gID0gZXhwb3J0c1tQUk9UT1RZUEVdXG4gICAgLCB0YXJnZXQgICAgPSBJU19HTE9CQUwgPyBnbG9iYWwgOiBJU19TVEFUSUMgPyBnbG9iYWxbbmFtZV0gOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdXG4gICAgLCBrZXksIG93biwgb3V0O1xuICBpZihJU19HTE9CQUwpc291cmNlID0gbmFtZTtcbiAgZm9yKGtleSBpbiBzb3VyY2Upe1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgaWYob3duICYmIGtleSBpbiBleHBvcnRzKWNvbnRpbnVlO1xuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG4gICAgb3V0ID0gb3duID8gdGFyZ2V0W2tleV0gOiBzb3VyY2Vba2V5XTtcbiAgICAvLyBwcmV2ZW50IGdsb2JhbCBwb2xsdXRpb24gZm9yIG5hbWVzcGFjZXNcbiAgICBleHBvcnRzW2tleV0gPSBJU19HTE9CQUwgJiYgdHlwZW9mIHRhcmdldFtrZXldICE9ICdmdW5jdGlvbicgPyBzb3VyY2Vba2V5XVxuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgOiBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbClcbiAgICAvLyB3cmFwIGdsb2JhbCBjb25zdHJ1Y3RvcnMgZm9yIHByZXZlbnQgY2hhbmdlIHRoZW0gaW4gbGlicmFyeVxuICAgIDogSVNfV1JBUCAmJiB0YXJnZXRba2V5XSA9PSBvdXQgPyAoZnVuY3Rpb24oQyl7XG4gICAgICB2YXIgRiA9IGZ1bmN0aW9uKGEsIGIsIGMpe1xuICAgICAgICBpZih0aGlzIGluc3RhbmNlb2YgQyl7XG4gICAgICAgICAgc3dpdGNoKGFyZ3VtZW50cy5sZW5ndGgpe1xuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IEM7XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgQyhhKTtcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBDKGEsIGIpO1xuICAgICAgICAgIH0gcmV0dXJuIG5ldyBDKGEsIGIsIGMpO1xuICAgICAgICB9IHJldHVybiBDLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgICAgRltQUk9UT1RZUEVdID0gQ1tQUk9UT1RZUEVdO1xuICAgICAgcmV0dXJuIEY7XG4gICAgLy8gbWFrZSBzdGF0aWMgdmVyc2lvbnMgZm9yIHByb3RvdHlwZSBtZXRob2RzXG4gICAgfSkob3V0KSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5tZXRob2RzLiVOQU1FJVxuICAgIGlmKElTX1BST1RPKXtcbiAgICAgIChleHBvcnRzLnZpcnR1YWwgfHwgKGV4cG9ydHMudmlydHVhbCA9IHt9KSlba2V5XSA9IG91dDtcbiAgICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5wcm90b3R5cGUuJU5BTUUlXG4gICAgICBpZih0eXBlICYgJGV4cG9ydC5SICYmIGV4cFByb3RvICYmICFleHBQcm90b1trZXldKWhpZGUoZXhwUHJvdG8sIGtleSwgb3V0KTtcbiAgICB9XG4gIH1cbn07XG4vLyB0eXBlIGJpdG1hcFxuJGV4cG9ydC5GID0gMTsgICAvLyBmb3JjZWRcbiRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsXG4kZXhwb3J0LlMgPSA0OyAgIC8vIHN0YXRpY1xuJGV4cG9ydC5QID0gODsgICAvLyBwcm90b1xuJGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kXG4kZXhwb3J0LlcgPSAzMjsgIC8vIHdyYXBcbiRleHBvcnQuVSA9IDY0OyAgLy8gc2FmZVxuJGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgIFxubW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZXhlYyl7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59OyIsInZhciBjdHggICAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgY2FsbCAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyLWNhbGwnKVxuICAsIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpXG4gICwgYW5PYmplY3QgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIHRvTGVuZ3RoICAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBnZXRJdGVyRm4gICA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJylcbiAgLCBCUkVBSyAgICAgICA9IHt9XG4gICwgUkVUVVJOICAgICAgPSB7fTtcbnZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdGVyYWJsZSwgZW50cmllcywgZm4sIHRoYXQsIElURVJBVE9SKXtcbiAgdmFyIGl0ZXJGbiA9IElURVJBVE9SID8gZnVuY3Rpb24oKXsgcmV0dXJuIGl0ZXJhYmxlOyB9IDogZ2V0SXRlckZuKGl0ZXJhYmxlKVxuICAgICwgZiAgICAgID0gY3R4KGZuLCB0aGF0LCBlbnRyaWVzID8gMiA6IDEpXG4gICAgLCBpbmRleCAgPSAwXG4gICAgLCBsZW5ndGgsIHN0ZXAsIGl0ZXJhdG9yLCByZXN1bHQ7XG4gIGlmKHR5cGVvZiBpdGVyRm4gIT0gJ2Z1bmN0aW9uJyl0aHJvdyBUeXBlRXJyb3IoaXRlcmFibGUgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgLy8gZmFzdCBjYXNlIGZvciBhcnJheXMgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yXG4gIGlmKGlzQXJyYXlJdGVyKGl0ZXJGbikpZm9yKGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKXtcbiAgICByZXN1bHQgPSBlbnRyaWVzID8gZihhbk9iamVjdChzdGVwID0gaXRlcmFibGVbaW5kZXhdKVswXSwgc3RlcFsxXSkgOiBmKGl0ZXJhYmxlW2luZGV4XSk7XG4gICAgaWYocmVzdWx0ID09PSBCUkVBSyB8fCByZXN1bHQgPT09IFJFVFVSTilyZXR1cm4gcmVzdWx0O1xuICB9IGVsc2UgZm9yKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoaXRlcmFibGUpOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7ICl7XG4gICAgcmVzdWx0ID0gY2FsbChpdGVyYXRvciwgZiwgc3RlcC52YWx1ZSwgZW50cmllcyk7XG4gICAgaWYocmVzdWx0ID09PSBCUkVBSyB8fCByZXN1bHQgPT09IFJFVFVSTilyZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuZXhwb3J0cy5CUkVBSyAgPSBCUkVBSztcbmV4cG9ydHMuUkVUVVJOID0gUkVUVVJOOyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcbiAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGYgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuaWYodHlwZW9mIF9fZyA9PSAnbnVtYmVyJylfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWYiLCJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIGtleSl7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTsiLCJ2YXIgZFAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7IiwibW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnZGl2JyksICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH19KS5hICE9IDc7XG59KTsiLCIvLyBmYXN0IGFwcGx5LCBodHRwOi8vanNwZXJmLmxua2l0LmNvbS9mYXN0LWFwcGx5LzVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZm4sIGFyZ3MsIHRoYXQpe1xuICB2YXIgdW4gPSB0aGF0ID09PSB1bmRlZmluZWQ7XG4gIHN3aXRjaChhcmdzLmxlbmd0aCl7XG4gICAgY2FzZSAwOiByZXR1cm4gdW4gPyBmbigpXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQpO1xuICAgIGNhc2UgMTogcmV0dXJuIHVuID8gZm4oYXJnc1swXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIGNhc2UgNDogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gIH0gcmV0dXJuICAgICAgICAgICAgICBmbi5hcHBseSh0aGF0LCBhcmdzKTtcbn07IiwiLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07IiwiLy8gY2hlY2sgb24gZGVmYXVsdCBBcnJheSBpdGVyYXRvclxudmFyIEl0ZXJhdG9ycyAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAsIElURVJBVE9SICAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvW0lURVJBVE9SXSA9PT0gaXQpO1xufTsiLCIvLyA3LjIuMiBJc0FycmF5KGFyZ3VtZW50KVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXkoYXJnKXtcbiAgcmV0dXJuIGNvZihhcmcpID09ICdBcnJheSc7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTsiLCIvLyBjYWxsIHNvbWV0aGluZyBvbiBpdGVyYXRvciBzdGVwIHdpdGggc2FmZSBjbG9zaW5nIG9uIGVycm9yXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXRlcmF0b3IsIGZuLCB2YWx1ZSwgZW50cmllcyl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVudHJpZXMgPyBmbihhbk9iamVjdCh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcbiAgLy8gNy40LjYgSXRlcmF0b3JDbG9zZShpdGVyYXRvciwgY29tcGxldGlvbilcbiAgfSBjYXRjaChlKXtcbiAgICB2YXIgcmV0ID0gaXRlcmF0b3JbJ3JldHVybiddO1xuICAgIGlmKHJldCAhPT0gdW5kZWZpbmVkKWFuT2JqZWN0KHJldC5jYWxsKGl0ZXJhdG9yKSk7XG4gICAgdGhyb3cgZTtcbiAgfVxufTsiLCIndXNlIHN0cmljdCc7XG52YXIgY3JlYXRlICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJylcbiAgLCBkZXNjcmlwdG9yICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19oaWRlJykoSXRlcmF0b3JQcm90b3R5cGUsIHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpLCBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpe1xuICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHtuZXh0OiBkZXNjcmlwdG9yKDEsIG5leHQpfSk7XG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xufTsiLCIndXNlIHN0cmljdCc7XG52YXIgTElCUkFSWSAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgcmVkZWZpbmUgICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgaGlkZSAgICAgICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgSXRlcmF0b3JzICAgICAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAsICRpdGVyQ3JlYXRlICAgID0gcmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgSVRFUkFUT1IgICAgICAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIEJVR0dZICAgICAgICAgID0gIShbXS5rZXlzICYmICduZXh0JyBpbiBbXS5rZXlzKCkpIC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbiAgLCBGRl9JVEVSQVRPUiAgICA9ICdAQGl0ZXJhdG9yJ1xuICAsIEtFWVMgICAgICAgICAgID0gJ2tleXMnXG4gICwgVkFMVUVTICAgICAgICAgPSAndmFsdWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihCYXNlLCBOQU1FLCBDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpe1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbihraW5kKXtcbiAgICBpZighQlVHR1kgJiYga2luZCBpbiBwcm90bylyZXR1cm4gcHJvdG9ba2luZF07XG4gICAgc3dpdGNoKGtpbmQpe1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICB9IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgICAgICAgID0gTkFNRSArICcgSXRlcmF0b3InXG4gICAgLCBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVNcbiAgICAsIFZBTFVFU19CVUcgPSBmYWxzZVxuICAgICwgcHJvdG8gICAgICA9IEJhc2UucHJvdG90eXBlXG4gICAgLCAkbmF0aXZlICAgID0gcHJvdG9bSVRFUkFUT1JdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdXG4gICAgLCAkZGVmYXVsdCAgID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVClcbiAgICAsICRlbnRyaWVzICAgPSBERUZBVUxUID8gIURFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZCgnZW50cmllcycpIDogdW5kZWZpbmVkXG4gICAgLCAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZVxuICAgICwgbWV0aG9kcywga2V5LCBJdGVyYXRvclByb3RvdHlwZTtcbiAgLy8gRml4IG5hdGl2ZVxuICBpZigkYW55TmF0aXZlKXtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSkpO1xuICAgIGlmKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlKXtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZighTElCUkFSWSAmJiAhaGFzKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUikpaGlkZShJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xuICAgIH1cbiAgfVxuICAvLyBmaXggQXJyYXkje3ZhbHVlcywgQEBpdGVyYXRvcn0ubmFtZSBpbiBWOCAvIEZGXG4gIGlmKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUyl7XG4gICAgVkFMVUVTX0JVRyA9IHRydWU7XG4gICAgJGRlZmF1bHQgPSBmdW5jdGlvbiB2YWx1ZXMoKXsgcmV0dXJuICRuYXRpdmUuY2FsbCh0aGlzKTsgfTtcbiAgfVxuICAvLyBEZWZpbmUgaXRlcmF0b3JcbiAgaWYoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpe1xuICAgIGhpZGUocHJvdG8sIElURVJBVE9SLCAkZGVmYXVsdCk7XG4gIH1cbiAgLy8gUGx1ZyBmb3IgbGlicmFyeVxuICBJdGVyYXRvcnNbTkFNRV0gPSAkZGVmYXVsdDtcbiAgSXRlcmF0b3JzW1RBR10gID0gcmV0dXJuVGhpcztcbiAgaWYoREVGQVVMVCl7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIHZhbHVlczogIERFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogICAgSVNfU0VUICAgICA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmKEZPUkNFRClmb3Ioa2V5IGluIG1ldGhvZHMpe1xuICAgICAgaWYoIShrZXkgaW4gcHJvdG8pKXJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07IiwidmFyIElURVJBVE9SICAgICA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpXG4gICwgU0FGRV9DTE9TSU5HID0gZmFsc2U7XG5cbnRyeSB7XG4gIHZhciByaXRlciA9IFs3XVtJVEVSQVRPUl0oKTtcbiAgcml0ZXJbJ3JldHVybiddID0gZnVuY3Rpb24oKXsgU0FGRV9DTE9TSU5HID0gdHJ1ZTsgfTtcbiAgQXJyYXkuZnJvbShyaXRlciwgZnVuY3Rpb24oKXsgdGhyb3cgMjsgfSk7XG59IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZXhlYywgc2tpcENsb3Npbmcpe1xuICBpZighc2tpcENsb3NpbmcgJiYgIVNBRkVfQ0xPU0lORylyZXR1cm4gZmFsc2U7XG4gIHZhciBzYWZlID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIGFyciAgPSBbN11cbiAgICAgICwgaXRlciA9IGFycltJVEVSQVRPUl0oKTtcbiAgICBpdGVyLm5leHQgPSBmdW5jdGlvbigpeyByZXR1cm4ge2RvbmU6IHNhZmUgPSB0cnVlfTsgfTtcbiAgICBhcnJbSVRFUkFUT1JdID0gZnVuY3Rpb24oKXsgcmV0dXJuIGl0ZXI7IH07XG4gICAgZXhlYyhhcnIpO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBzYWZlO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRvbmUsIHZhbHVlKXtcbiAgcmV0dXJuIHt2YWx1ZTogdmFsdWUsIGRvbmU6ICEhZG9uZX07XG59OyIsIm1vZHVsZS5leHBvcnRzID0ge307IiwibW9kdWxlLmV4cG9ydHMgPSB0cnVlOyIsInZhciBNRVRBICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpKCdtZXRhJylcbiAgLCBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgaGFzICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIHNldERlc2MgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGlkICAgICAgID0gMDtcbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGZ1bmN0aW9uKCl7XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBGUkVFWkUgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpO1xufSk7XG52YXIgc2V0TWV0YSA9IGZ1bmN0aW9uKGl0KXtcbiAgc2V0RGVzYyhpdCwgTUVUQSwge3ZhbHVlOiB7XG4gICAgaTogJ08nICsgKytpZCwgLy8gb2JqZWN0IElEXG4gICAgdzoge30gICAgICAgICAgLy8gd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfX0pO1xufTtcbnZhciBmYXN0S2V5ID0gZnVuY3Rpb24oaXQsIGNyZWF0ZSl7XG4gIC8vIHJldHVybiBwcmltaXRpdmUgd2l0aCBwcmVmaXhcbiAgaWYoIWlzT2JqZWN0KGl0KSlyZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xuICBpZighaGFzKGl0LCBNRVRBKSl7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZighaXNFeHRlbnNpYmxlKGl0KSlyZXR1cm4gJ0YnO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYoIWNyZWF0ZSlyZXR1cm4gJ0UnO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBvYmplY3QgSURcbiAgfSByZXR1cm4gaXRbTUVUQV0uaTtcbn07XG52YXIgZ2V0V2VhayA9IGZ1bmN0aW9uKGl0LCBjcmVhdGUpe1xuICBpZighaGFzKGl0LCBNRVRBKSl7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZighaXNFeHRlbnNpYmxlKGl0KSlyZXR1cm4gdHJ1ZTtcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmKCFjcmVhdGUpcmV0dXJuIGZhbHNlO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBoYXNoIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gcmV0dXJuIGl0W01FVEFdLnc7XG59O1xuLy8gYWRkIG1ldGFkYXRhIG9uIGZyZWV6ZS1mYW1pbHkgbWV0aG9kcyBjYWxsaW5nXG52YXIgb25GcmVlemUgPSBmdW5jdGlvbihpdCl7XG4gIGlmKEZSRUVaRSAmJiBtZXRhLk5FRUQgJiYgaXNFeHRlbnNpYmxlKGl0KSAmJiAhaGFzKGl0LCBNRVRBKSlzZXRNZXRhKGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciBtZXRhID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIEtFWTogICAgICBNRVRBLFxuICBORUVEOiAgICAgZmFsc2UsXG4gIGZhc3RLZXk6ICBmYXN0S2V5LFxuICBnZXRXZWFrOiAgZ2V0V2VhayxcbiAgb25GcmVlemU6IG9uRnJlZXplXG59OyIsInZhciBnbG9iYWwgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIG1hY3JvdGFzayA9IHJlcXVpcmUoJy4vX3Rhc2snKS5zZXRcbiAgLCBPYnNlcnZlciAgPSBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlclxuICAsIHByb2Nlc3MgICA9IGdsb2JhbC5wcm9jZXNzXG4gICwgUHJvbWlzZSAgID0gZ2xvYmFsLlByb21pc2VcbiAgLCBpc05vZGUgICAgPSByZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKXtcbiAgdmFyIGhlYWQsIGxhc3QsIG5vdGlmeTtcblxuICB2YXIgZmx1c2ggPSBmdW5jdGlvbigpe1xuICAgIHZhciBwYXJlbnQsIGZuO1xuICAgIGlmKGlzTm9kZSAmJiAocGFyZW50ID0gcHJvY2Vzcy5kb21haW4pKXBhcmVudC5leGl0KCk7XG4gICAgd2hpbGUoaGVhZCl7XG4gICAgICBmbiAgID0gaGVhZC5mbjtcbiAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgICB0cnkge1xuICAgICAgICBmbigpO1xuICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgaWYoaGVhZClub3RpZnkoKTtcbiAgICAgICAgZWxzZSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0gbGFzdCA9IHVuZGVmaW5lZDtcbiAgICBpZihwYXJlbnQpcGFyZW50LmVudGVyKCk7XG4gIH07XG5cbiAgLy8gTm9kZS5qc1xuICBpZihpc05vZGUpe1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgICB9O1xuICAvLyBicm93c2VycyB3aXRoIE11dGF0aW9uT2JzZXJ2ZXJcbiAgfSBlbHNlIGlmKE9ic2VydmVyKXtcbiAgICB2YXIgdG9nZ2xlID0gdHJ1ZVxuICAgICAgLCBub2RlICAgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgbmV3IE9ic2VydmVyKGZsdXNoKS5vYnNlcnZlKG5vZGUsIHtjaGFyYWN0ZXJEYXRhOiB0cnVlfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24oKXtcbiAgICAgIG5vZGUuZGF0YSA9IHRvZ2dsZSA9ICF0b2dnbGU7XG4gICAgfTtcbiAgLy8gZW52aXJvbm1lbnRzIHdpdGggbWF5YmUgbm9uLWNvbXBsZXRlbHkgY29ycmVjdCwgYnV0IGV4aXN0ZW50IFByb21pc2VcbiAgfSBlbHNlIGlmKFByb21pc2UgJiYgUHJvbWlzZS5yZXNvbHZlKXtcbiAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgICBwcm9taXNlLnRoZW4oZmx1c2gpO1xuICAgIH07XG4gIC8vIGZvciBvdGhlciBlbnZpcm9ubWVudHMgLSBtYWNyb3Rhc2sgYmFzZWQgb246XG4gIC8vIC0gc2V0SW1tZWRpYXRlXG4gIC8vIC0gTWVzc2FnZUNoYW5uZWxcbiAgLy8gLSB3aW5kb3cucG9zdE1lc3NhZ1xuICAvLyAtIG9ucmVhZHlzdGF0ZWNoYW5nZVxuICAvLyAtIHNldFRpbWVvdXRcbiAgfSBlbHNlIHtcbiAgICBub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgICAgLy8gc3RyYW5nZSBJRSArIHdlYnBhY2sgZGV2IHNlcnZlciBidWcgLSB1c2UgLmNhbGwoZ2xvYmFsKVxuICAgICAgbWFjcm90YXNrLmNhbGwoZ2xvYmFsLCBmbHVzaCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbihmbil7XG4gICAgdmFyIHRhc2sgPSB7Zm46IGZuLCBuZXh0OiB1bmRlZmluZWR9O1xuICAgIGlmKGxhc3QpbGFzdC5uZXh0ID0gdGFzaztcbiAgICBpZighaGVhZCl7XG4gICAgICBoZWFkID0gdGFzaztcbiAgICAgIG5vdGlmeSgpO1xuICAgIH0gbGFzdCA9IHRhc2s7XG4gIH07XG59OyIsIi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxudmFyIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBkUHMgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKVxuICAsIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpXG4gICwgSUVfUFJPVE8gICAgPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJylcbiAgLCBFbXB0eSAgICAgICA9IGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovIH1cbiAgLCBQUk9UT1RZUEUgICA9ICdwcm90b3R5cGUnO1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgY3JlYXRlRGljdCA9IGZ1bmN0aW9uKCl7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2lmcmFtZScpXG4gICAgLCBpICAgICAgPSBlbnVtQnVnS2V5cy5sZW5ndGhcbiAgICAsIGx0ICAgICA9ICc8J1xuICAgICwgZ3QgICAgID0gJz4nXG4gICAgLCBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIHJlcXVpcmUoJy4vX2h0bWwnKS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShsdCArICdzY3JpcHQnICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnL3NjcmlwdCcgKyBndCk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xuICB3aGlsZShpLS0pZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tpXV07XG4gIHJldHVybiBjcmVhdGVEaWN0KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpe1xuICB2YXIgcmVzdWx0O1xuICBpZihPICE9PSBudWxsKXtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5O1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBudWxsO1xuICAgIC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcbiAgICByZXN1bHRbSUVfUFJPVE9dID0gTztcbiAgfSBlbHNlIHJlc3VsdCA9IGNyZWF0ZURpY3QoKTtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRQcyhyZXN1bHQsIFByb3BlcnRpZXMpO1xufTtcbiIsInZhciBhbk9iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGRQICAgICAgICAgICAgID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyl7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZihJRThfRE9NX0RFRklORSl0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICBpZignZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKU9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07IiwidmFyIGRQICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgZ2V0S2V5cyAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcyl7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5cyAgID0gZ2V0S2V5cyhQcm9wZXJ0aWVzKVxuICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAsIGkgPSAwXG4gICAgLCBQO1xuICB3aGlsZShsZW5ndGggPiBpKWRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XG4gIHJldHVybiBPO1xufTsiLCIvLyAxOS4xLjIuOSAvIDE1LjIuMy4yIE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIGhhcyAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCB0b09iamVjdCAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgSUVfUFJPVE8gICAgPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJylcbiAgLCBPYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uKE8pe1xuICBPID0gdG9PYmplY3QoTyk7XG4gIGlmKGhhcyhPLCBJRV9QUk9UTykpcmV0dXJuIE9bSUVfUFJPVE9dO1xuICBpZih0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKXtcbiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90byA6IG51bGw7XG59OyIsInZhciBoYXMgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIHRvSU9iamVjdCAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIGFycmF5SW5kZXhPZiA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpXG4gICwgSUVfUFJPVE8gICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iamVjdCwgbmFtZXMpe1xuICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KG9iamVjdClcbiAgICAsIGkgICAgICA9IDBcbiAgICAsIHJlc3VsdCA9IFtdXG4gICAgLCBrZXk7XG4gIGZvcihrZXkgaW4gTylpZihrZXkgIT0gSUVfUFJPVE8paGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKWlmKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSl7XG4gICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTsiLCIvLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTylcbnZhciAka2V5cyAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJylcbiAgLCBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pe1xuICByZXR1cm4gJGtleXMoTywgZW51bUJ1Z0tleXMpO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGJpdG1hcCwgdmFsdWUpe1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGUgIDogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGUgICAgOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlICAgICAgIDogdmFsdWVcbiAgfTtcbn07IiwidmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRhcmdldCwgc3JjLCBzYWZlKXtcbiAgZm9yKHZhciBrZXkgaW4gc3JjKXtcbiAgICBpZihzYWZlICYmIHRhcmdldFtrZXldKXRhcmdldFtrZXldID0gc3JjW2tleV07XG4gICAgZWxzZSBoaWRlKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XG4gIH0gcmV0dXJuIHRhcmdldDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19oaWRlJyk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBjb3JlICAgICAgICA9IHJlcXVpcmUoJy4vX2NvcmUnKVxuICAsIGRQICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJylcbiAgLCBTUEVDSUVTICAgICA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oS0VZKXtcbiAgdmFyIEMgPSB0eXBlb2YgY29yZVtLRVldID09ICdmdW5jdGlvbicgPyBjb3JlW0tFWV0gOiBnbG9iYWxbS0VZXTtcbiAgaWYoREVTQ1JJUFRPUlMgJiYgQyAmJiAhQ1tTUEVDSUVTXSlkUC5mKEMsIFNQRUNJRVMsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfVxuICB9KTtcbn07IiwidmFyIGRlZiA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBoYXMgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCB0YWcsIHN0YXQpe1xuICBpZihpdCAmJiAhaGFzKGl0ID0gc3RhdCA/IGl0IDogaXQucHJvdG90eXBlLCBUQUcpKWRlZihpdCwgVEFHLCB7Y29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogdGFnfSk7XG59OyIsInZhciBzaGFyZWQgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgna2V5cycpXG4gICwgdWlkICAgID0gcmVxdWlyZSgnLi9fdWlkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiBzaGFyZWRba2V5XSB8fCAoc2hhcmVkW2tleV0gPSB1aWQoa2V5KSk7XG59OyIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nXG4gICwgc3RvcmUgID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHt9KTtcbn07IiwiLy8gNy4zLjIwIFNwZWNpZXNDb25zdHJ1Y3RvcihPLCBkZWZhdWx0Q29uc3RydWN0b3IpXG52YXIgYW5PYmplY3QgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCBTUEVDSUVTICAgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihPLCBEKXtcbiAgdmFyIEMgPSBhbk9iamVjdChPKS5jb25zdHJ1Y3RvciwgUztcbiAgcmV0dXJuIEMgPT09IHVuZGVmaW5lZCB8fCAoUyA9IGFuT2JqZWN0KEMpW1NQRUNJRVNdKSA9PSB1bmRlZmluZWQgPyBEIDogYUZ1bmN0aW9uKFMpO1xufTsiLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgZGVmaW5lZCAgID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuLy8gdHJ1ZSAgLT4gU3RyaW5nI2F0XG4vLyBmYWxzZSAtPiBTdHJpbmcjY29kZVBvaW50QXRcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oVE9fU1RSSU5HKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKHRoYXQsIHBvcyl7XG4gICAgdmFyIHMgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSlcbiAgICAgICwgaSA9IHRvSW50ZWdlcihwb3MpXG4gICAgICAsIGwgPSBzLmxlbmd0aFxuICAgICAgLCBhLCBiO1xuICAgIGlmKGkgPCAwIHx8IGkgPj0gbClyZXR1cm4gVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgYSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gYSA8IDB4ZDgwMCB8fCBhID4gMHhkYmZmIHx8IGkgKyAxID09PSBsIHx8IChiID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgYiA+IDB4ZGZmZlxuICAgICAgPyBUT19TVFJJTkcgPyBzLmNoYXJBdChpKSA6IGFcbiAgICAgIDogVE9fU1RSSU5HID8gcy5zbGljZShpLCBpICsgMikgOiAoYSAtIDB4ZDgwMCA8PCAxMCkgKyAoYiAtIDB4ZGMwMCkgKyAweDEwMDAwO1xuICB9O1xufTsiLCJ2YXIgY3R4ICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBpbnZva2UgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19pbnZva2UnKVxuICAsIGh0bWwgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2h0bWwnKVxuICAsIGNlbCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKVxuICAsIGdsb2JhbCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgcHJvY2VzcyAgICAgICAgICAgID0gZ2xvYmFsLnByb2Nlc3NcbiAgLCBzZXRUYXNrICAgICAgICAgICAgPSBnbG9iYWwuc2V0SW1tZWRpYXRlXG4gICwgY2xlYXJUYXNrICAgICAgICAgID0gZ2xvYmFsLmNsZWFySW1tZWRpYXRlXG4gICwgTWVzc2FnZUNoYW5uZWwgICAgID0gZ2xvYmFsLk1lc3NhZ2VDaGFubmVsXG4gICwgY291bnRlciAgICAgICAgICAgID0gMFxuICAsIHF1ZXVlICAgICAgICAgICAgICA9IHt9XG4gICwgT05SRUFEWVNUQVRFQ0hBTkdFID0gJ29ucmVhZHlzdGF0ZWNoYW5nZSdcbiAgLCBkZWZlciwgY2hhbm5lbCwgcG9ydDtcbnZhciBydW4gPSBmdW5jdGlvbigpe1xuICB2YXIgaWQgPSArdGhpcztcbiAgaWYocXVldWUuaGFzT3duUHJvcGVydHkoaWQpKXtcbiAgICB2YXIgZm4gPSBxdWV1ZVtpZF07XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgICBmbigpO1xuICB9XG59O1xudmFyIGxpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQpe1xuICBydW4uY2FsbChldmVudC5kYXRhKTtcbn07XG4vLyBOb2RlLmpzIDAuOSsgJiBJRTEwKyBoYXMgc2V0SW1tZWRpYXRlLCBvdGhlcndpc2U6XG5pZighc2V0VGFzayB8fCAhY2xlYXJUYXNrKXtcbiAgc2V0VGFzayA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZShmbil7XG4gICAgdmFyIGFyZ3MgPSBbXSwgaSA9IDE7XG4gICAgd2hpbGUoYXJndW1lbnRzLmxlbmd0aCA+IGkpYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICBxdWV1ZVsrK2NvdW50ZXJdID0gZnVuY3Rpb24oKXtcbiAgICAgIGludm9rZSh0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJyA/IGZuIDogRnVuY3Rpb24oZm4pLCBhcmdzKTtcbiAgICB9O1xuICAgIGRlZmVyKGNvdW50ZXIpO1xuICAgIHJldHVybiBjb3VudGVyO1xuICB9O1xuICBjbGVhclRhc2sgPSBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShpZCl7XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgfTtcbiAgLy8gTm9kZS5qcyAwLjgtXG4gIGlmKHJlcXVpcmUoJy4vX2NvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJyl7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGN0eChydW4sIGlkLCAxKSk7XG4gICAgfTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBNZXNzYWdlQ2hhbm5lbCwgaW5jbHVkZXMgV2ViV29ya2Vyc1xuICB9IGVsc2UgaWYoTWVzc2FnZUNoYW5uZWwpe1xuICAgIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWw7XG4gICAgcG9ydCAgICA9IGNoYW5uZWwucG9ydDI7XG4gICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBsaXN0ZW5lcjtcbiAgICBkZWZlciA9IGN0eChwb3J0LnBvc3RNZXNzYWdlLCBwb3J0LCAxKTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBwb3N0TWVzc2FnZSwgc2tpcCBXZWJXb3JrZXJzXG4gIC8vIElFOCBoYXMgcG9zdE1lc3NhZ2UsIGJ1dCBpdCdzIHN5bmMgJiB0eXBlb2YgaXRzIHBvc3RNZXNzYWdlIGlzICdvYmplY3QnXG4gIH0gZWxzZSBpZihnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lciAmJiB0eXBlb2YgcG9zdE1lc3NhZ2UgPT0gJ2Z1bmN0aW9uJyAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpe1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKGlkICsgJycsICcqJyk7XG4gICAgfTtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RlbmVyLCBmYWxzZSk7XG4gIC8vIElFOC1cbiAgfSBlbHNlIGlmKE9OUkVBRFlTVEFURUNIQU5HRSBpbiBjZWwoJ3NjcmlwdCcpKXtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoY2VsKCdzY3JpcHQnKSlbT05SRUFEWVNUQVRFQ0hBTkdFXSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIHJ1bi5jYWxsKGlkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgLy8gUmVzdCBvbGQgYnJvd3NlcnNcbiAgfSBlbHNlIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIHNldFRpbWVvdXQoY3R4KHJ1biwgaWQsIDEpLCAwKTtcbiAgICB9O1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiAgIHNldFRhc2ssXG4gIGNsZWFyOiBjbGVhclRhc2tcbn07IiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIG1heCAgICAgICA9IE1hdGgubWF4XG4gICwgbWluICAgICAgID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGluZGV4LCBsZW5ndGgpe1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTsiLCIvLyA3LjEuNCBUb0ludGVnZXJcbnZhciBjZWlsICA9IE1hdGguY2VpbFxuICAsIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07IiwiLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKVxuICAsIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTsiLCIvLyA3LjEuMTUgVG9MZW5ndGhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBtaW4gICAgICAgPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTsiLCIvLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07IiwiLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgUyl7XG4gIGlmKCFpc09iamVjdChpdCkpcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICBpZih0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIGlmKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07IiwidmFyIGlkID0gMFxuICAsIHB4ID0gTWF0aC5yYW5kb20oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcbn07IiwidmFyIHN0b3JlICAgICAgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgnd2tzJylcbiAgLCB1aWQgICAgICAgID0gcmVxdWlyZSgnLi9fdWlkJylcbiAgLCBTeW1ib2wgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuU3ltYm9sXG4gICwgVVNFX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcblxudmFyICRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihuYW1lKXtcbiAgcmV0dXJuIHN0b3JlW25hbWVdIHx8IChzdG9yZVtuYW1lXSA9XG4gICAgVVNFX1NZTUJPTCAmJiBTeW1ib2xbbmFtZV0gfHwgKFVTRV9TWU1CT0wgPyBTeW1ib2wgOiB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTtcbn07XG5cbiRleHBvcnRzLnN0b3JlID0gc3RvcmU7IiwidmFyIGNsYXNzb2YgICA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKVxuICAsIElURVJBVE9SICA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpXG4gICwgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5nZXRJdGVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoaXQgIT0gdW5kZWZpbmVkKXJldHVybiBpdFtJVEVSQVRPUl1cbiAgICB8fCBpdFsnQEBpdGVyYXRvciddXG4gICAgfHwgSXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSByZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKVxuICAsIHN0ZXAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKVxuICAsIEl0ZXJhdG9ycyAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAsIHRvSU9iamVjdCAgICAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5cbi8vIDIyLjEuMy40IEFycmF5LnByb3RvdHlwZS5lbnRyaWVzKClcbi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUua2V5cygpXG4vLyAyMi4xLjMuMjkgQXJyYXkucHJvdG90eXBlLnZhbHVlcygpXG4vLyAyMi4xLjMuMzAgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24oaXRlcmF0ZWQsIGtpbmQpe1xuICB0aGlzLl90ID0gdG9JT2JqZWN0KGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gIHRoaXMuX2sgPSBraW5kOyAgICAgICAgICAgICAgICAvLyBraW5kXG4vLyAyMi4xLjUuMi4xICVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uKCl7XG4gIHZhciBPICAgICA9IHRoaXMuX3RcbiAgICAsIGtpbmQgID0gdGhpcy5fa1xuICAgICwgaW5kZXggPSB0aGlzLl9pKys7XG4gIGlmKCFPIHx8IGluZGV4ID49IE8ubGVuZ3RoKXtcbiAgICB0aGlzLl90ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBzdGVwKDEpO1xuICB9XG4gIGlmKGtpbmQgPT0gJ2tleXMnICApcmV0dXJuIHN0ZXAoMCwgaW5kZXgpO1xuICBpZihraW5kID09ICd2YWx1ZXMnKXJldHVybiBzdGVwKDAsIE9baW5kZXhdKTtcbiAgcmV0dXJuIHN0ZXAoMCwgW2luZGV4LCBPW2luZGV4XV0pO1xufSwgJ3ZhbHVlcycpO1xuXG4vLyBhcmd1bWVudHNMaXN0W0BAaXRlcmF0b3JdIGlzICVBcnJheVByb3RvX3ZhbHVlcyUgKDkuNC40LjYsIDkuNC40LjcpXG5JdGVyYXRvcnMuQXJndW1lbnRzID0gSXRlcmF0b3JzLkFycmF5O1xuXG5hZGRUb1Vuc2NvcGFibGVzKCdrZXlzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCd2YWx1ZXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ2VudHJpZXMnKTsiLCIndXNlIHN0cmljdCc7XG52YXIgc3Ryb25nID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi1zdHJvbmcnKTtcblxuLy8gMjMuMSBNYXAgT2JqZWN0c1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoJ01hcCcsIGZ1bmN0aW9uKGdldCl7XG4gIHJldHVybiBmdW5jdGlvbiBNYXAoKXsgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7IH07XG59LCB7XG4gIC8vIDIzLjEuMy42IE1hcC5wcm90b3R5cGUuZ2V0KGtleSlcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KXtcbiAgICB2YXIgZW50cnkgPSBzdHJvbmcuZ2V0RW50cnkodGhpcywga2V5KTtcbiAgICByZXR1cm4gZW50cnkgJiYgZW50cnkudjtcbiAgfSxcbiAgLy8gMjMuMS4zLjkgTWFwLnByb3RvdHlwZS5zZXQoa2V5LCB2YWx1ZSlcbiAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSl7XG4gICAgcmV0dXJuIHN0cm9uZy5kZWYodGhpcywga2V5ID09PSAwID8gMCA6IGtleSwgdmFsdWUpO1xuICB9XG59LCBzdHJvbmcsIHRydWUpOyIsIlwidXNlIHN0cmljdFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJaUlzSW1acGJHVWlPaUpsY3pZdWIySnFaV04wTG5SdkxYTjBjbWx1Wnk1cWN5SXNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJYWDA9IiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKVxuICAsIGdsb2JhbCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgY3R4ICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBjbGFzc29mICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jbGFzc29mJylcbiAgLCAkZXhwb3J0ICAgICAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGlzT2JqZWN0ICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgYUZ1bmN0aW9uICAgICAgICAgID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgYW5JbnN0YW5jZSAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKVxuICAsIGZvck9mICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2Zvci1vZicpXG4gICwgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpXG4gICwgdGFzayAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdGFzaycpLnNldFxuICAsIG1pY3JvdGFzayAgICAgICAgICA9IHJlcXVpcmUoJy4vX21pY3JvdGFzaycpKClcbiAgLCBQUk9NSVNFICAgICAgICAgICAgPSAnUHJvbWlzZSdcbiAgLCBUeXBlRXJyb3IgICAgICAgICAgPSBnbG9iYWwuVHlwZUVycm9yXG4gICwgcHJvY2VzcyAgICAgICAgICAgID0gZ2xvYmFsLnByb2Nlc3NcbiAgLCAkUHJvbWlzZSAgICAgICAgICAgPSBnbG9iYWxbUFJPTUlTRV1cbiAgLCBwcm9jZXNzICAgICAgICAgICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIGlzTm9kZSAgICAgICAgICAgICA9IGNsYXNzb2YocHJvY2VzcykgPT0gJ3Byb2Nlc3MnXG4gICwgZW1wdHkgICAgICAgICAgICAgID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfVxuICAsIEludGVybmFsLCBHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHksIFdyYXBwZXI7XG5cbnZhciBVU0VfTkFUSVZFID0gISFmdW5jdGlvbigpe1xuICB0cnkge1xuICAgIC8vIGNvcnJlY3Qgc3ViY2xhc3Npbmcgd2l0aCBAQHNwZWNpZXMgc3VwcG9ydFxuICAgIHZhciBwcm9taXNlICAgICA9ICRQcm9taXNlLnJlc29sdmUoMSlcbiAgICAgICwgRmFrZVByb21pc2UgPSAocHJvbWlzZS5jb25zdHJ1Y3RvciA9IHt9KVtyZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpXSA9IGZ1bmN0aW9uKGV4ZWMpeyBleGVjKGVtcHR5LCBlbXB0eSk7IH07XG4gICAgLy8gdW5oYW5kbGVkIHJlamVjdGlvbnMgdHJhY2tpbmcgc3VwcG9ydCwgTm9kZUpTIFByb21pc2Ugd2l0aG91dCBpdCBmYWlscyBAQHNwZWNpZXMgdGVzdFxuICAgIHJldHVybiAoaXNOb2RlIHx8IHR5cGVvZiBQcm9taXNlUmVqZWN0aW9uRXZlbnQgPT0gJ2Z1bmN0aW9uJykgJiYgcHJvbWlzZS50aGVuKGVtcHR5KSBpbnN0YW5jZW9mIEZha2VQcm9taXNlO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG59KCk7XG5cbi8vIGhlbHBlcnNcbnZhciBzYW1lQ29uc3RydWN0b3IgPSBmdW5jdGlvbihhLCBiKXtcbiAgLy8gd2l0aCBsaWJyYXJ5IHdyYXBwZXIgc3BlY2lhbCBjYXNlXG4gIHJldHVybiBhID09PSBiIHx8IGEgPT09ICRQcm9taXNlICYmIGIgPT09IFdyYXBwZXI7XG59O1xudmFyIGlzVGhlbmFibGUgPSBmdW5jdGlvbihpdCl7XG4gIHZhciB0aGVuO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmIHR5cGVvZiAodGhlbiA9IGl0LnRoZW4pID09ICdmdW5jdGlvbicgPyB0aGVuIDogZmFsc2U7XG59O1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24oQyl7XG4gIHJldHVybiBzYW1lQ29uc3RydWN0b3IoJFByb21pc2UsIEMpXG4gICAgPyBuZXcgUHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICA6IG5ldyBHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG59O1xudmFyIFByb21pc2VDYXBhYmlsaXR5ID0gR2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24oQyl7XG4gIHZhciByZXNvbHZlLCByZWplY3Q7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBDKGZ1bmN0aW9uKCQkcmVzb2x2ZSwgJCRyZWplY3Qpe1xuICAgIGlmKHJlc29sdmUgIT09IHVuZGVmaW5lZCB8fCByZWplY3QgIT09IHVuZGVmaW5lZCl0aHJvdyBUeXBlRXJyb3IoJ0JhZCBQcm9taXNlIGNvbnN0cnVjdG9yJyk7XG4gICAgcmVzb2x2ZSA9ICQkcmVzb2x2ZTtcbiAgICByZWplY3QgID0gJCRyZWplY3Q7XG4gIH0pO1xuICB0aGlzLnJlc29sdmUgPSBhRnVuY3Rpb24ocmVzb2x2ZSk7XG4gIHRoaXMucmVqZWN0ICA9IGFGdW5jdGlvbihyZWplY3QpO1xufTtcbnZhciBwZXJmb3JtID0gZnVuY3Rpb24oZXhlYyl7XG4gIHRyeSB7XG4gICAgZXhlYygpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB7ZXJyb3I6IGV9O1xuICB9XG59O1xudmFyIG5vdGlmeSA9IGZ1bmN0aW9uKHByb21pc2UsIGlzUmVqZWN0KXtcbiAgaWYocHJvbWlzZS5fbilyZXR1cm47XG4gIHByb21pc2UuX24gPSB0cnVlO1xuICB2YXIgY2hhaW4gPSBwcm9taXNlLl9jO1xuICBtaWNyb3Rhc2soZnVuY3Rpb24oKXtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92XG4gICAgICAsIG9rICAgID0gcHJvbWlzZS5fcyA9PSAxXG4gICAgICAsIGkgICAgID0gMDtcbiAgICB2YXIgcnVuID0gZnVuY3Rpb24ocmVhY3Rpb24pe1xuICAgICAgdmFyIGhhbmRsZXIgPSBvayA/IHJlYWN0aW9uLm9rIDogcmVhY3Rpb24uZmFpbFxuICAgICAgICAsIHJlc29sdmUgPSByZWFjdGlvbi5yZXNvbHZlXG4gICAgICAgICwgcmVqZWN0ICA9IHJlYWN0aW9uLnJlamVjdFxuICAgICAgICAsIGRvbWFpbiAgPSByZWFjdGlvbi5kb21haW5cbiAgICAgICAgLCByZXN1bHQsIHRoZW47XG4gICAgICB0cnkge1xuICAgICAgICBpZihoYW5kbGVyKXtcbiAgICAgICAgICBpZighb2spe1xuICAgICAgICAgICAgaWYocHJvbWlzZS5faCA9PSAyKW9uSGFuZGxlVW5oYW5kbGVkKHByb21pc2UpO1xuICAgICAgICAgICAgcHJvbWlzZS5faCA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKGhhbmRsZXIgPT09IHRydWUpcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZihkb21haW4pZG9tYWluLmVudGVyKCk7XG4gICAgICAgICAgICByZXN1bHQgPSBoYW5kbGVyKHZhbHVlKTtcbiAgICAgICAgICAgIGlmKGRvbWFpbilkb21haW4uZXhpdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZihyZXN1bHQgPT09IHJlYWN0aW9uLnByb21pc2Upe1xuICAgICAgICAgICAgcmVqZWN0KFR5cGVFcnJvcignUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgICAgICB9IGVsc2UgaWYodGhlbiA9IGlzVGhlbmFibGUocmVzdWx0KSl7XG4gICAgICAgICAgICB0aGVuLmNhbGwocmVzdWx0LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSByZWplY3QodmFsdWUpO1xuICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgd2hpbGUoY2hhaW4ubGVuZ3RoID4gaSlydW4oY2hhaW5baSsrXSk7IC8vIHZhcmlhYmxlIGxlbmd0aCAtIGNhbid0IHVzZSBmb3JFYWNoXG4gICAgcHJvbWlzZS5fYyA9IFtdO1xuICAgIHByb21pc2UuX24gPSBmYWxzZTtcbiAgICBpZihpc1JlamVjdCAmJiAhcHJvbWlzZS5faClvblVuaGFuZGxlZChwcm9taXNlKTtcbiAgfSk7XG59O1xudmFyIG9uVW5oYW5kbGVkID0gZnVuY3Rpb24ocHJvbWlzZSl7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIHZhbHVlID0gcHJvbWlzZS5fdlxuICAgICAgLCBhYnJ1cHQsIGhhbmRsZXIsIGNvbnNvbGU7XG4gICAgaWYoaXNVbmhhbmRsZWQocHJvbWlzZSkpe1xuICAgICAgYWJydXB0ID0gcGVyZm9ybShmdW5jdGlvbigpe1xuICAgICAgICBpZihpc05vZGUpe1xuICAgICAgICAgIHByb2Nlc3MuZW1pdCgndW5oYW5kbGVkUmVqZWN0aW9uJywgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9IGVsc2UgaWYoaGFuZGxlciA9IGdsb2JhbC5vbnVuaGFuZGxlZHJlamVjdGlvbil7XG4gICAgICAgICAgaGFuZGxlcih7cHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiB2YWx1ZX0pO1xuICAgICAgICB9IGVsc2UgaWYoKGNvbnNvbGUgPSBnbG9iYWwuY29uc29sZSkgJiYgY29uc29sZS5lcnJvcil7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uJywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIEJyb3dzZXJzIHNob3VsZCBub3QgdHJpZ2dlciBgcmVqZWN0aW9uSGFuZGxlZGAgZXZlbnQgaWYgaXQgd2FzIGhhbmRsZWQgaGVyZSwgTm9kZUpTIC0gc2hvdWxkXG4gICAgICBwcm9taXNlLl9oID0gaXNOb2RlIHx8IGlzVW5oYW5kbGVkKHByb21pc2UpID8gMiA6IDE7XG4gICAgfSBwcm9taXNlLl9hID0gdW5kZWZpbmVkO1xuICAgIGlmKGFicnVwdCl0aHJvdyBhYnJ1cHQuZXJyb3I7XG4gIH0pO1xufTtcbnZhciBpc1VuaGFuZGxlZCA9IGZ1bmN0aW9uKHByb21pc2Upe1xuICBpZihwcm9taXNlLl9oID09IDEpcmV0dXJuIGZhbHNlO1xuICB2YXIgY2hhaW4gPSBwcm9taXNlLl9hIHx8IHByb21pc2UuX2NcbiAgICAsIGkgICAgID0gMFxuICAgICwgcmVhY3Rpb247XG4gIHdoaWxlKGNoYWluLmxlbmd0aCA+IGkpe1xuICAgIHJlYWN0aW9uID0gY2hhaW5baSsrXTtcbiAgICBpZihyZWFjdGlvbi5mYWlsIHx8ICFpc1VuaGFuZGxlZChyZWFjdGlvbi5wcm9taXNlKSlyZXR1cm4gZmFsc2U7XG4gIH0gcmV0dXJuIHRydWU7XG59O1xudmFyIG9uSGFuZGxlVW5oYW5kbGVkID0gZnVuY3Rpb24ocHJvbWlzZSl7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIGhhbmRsZXI7XG4gICAgaWYoaXNOb2RlKXtcbiAgICAgIHByb2Nlc3MuZW1pdCgncmVqZWN0aW9uSGFuZGxlZCcsIHByb21pc2UpO1xuICAgIH0gZWxzZSBpZihoYW5kbGVyID0gZ2xvYmFsLm9ucmVqZWN0aW9uaGFuZGxlZCl7XG4gICAgICBoYW5kbGVyKHtwcm9taXNlOiBwcm9taXNlLCByZWFzb246IHByb21pc2UuX3Z9KTtcbiAgICB9XG4gIH0pO1xufTtcbnZhciAkcmVqZWN0ID0gZnVuY3Rpb24odmFsdWUpe1xuICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gIGlmKHByb21pc2UuX2QpcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgcHJvbWlzZS5fcyA9IDI7XG4gIGlmKCFwcm9taXNlLl9hKXByb21pc2UuX2EgPSBwcm9taXNlLl9jLnNsaWNlKCk7XG4gIG5vdGlmeShwcm9taXNlLCB0cnVlKTtcbn07XG52YXIgJHJlc29sdmUgPSBmdW5jdGlvbih2YWx1ZSl7XG4gIHZhciBwcm9taXNlID0gdGhpc1xuICAgICwgdGhlbjtcbiAgaWYocHJvbWlzZS5fZClyZXR1cm47XG4gIHByb21pc2UuX2QgPSB0cnVlO1xuICBwcm9taXNlID0gcHJvbWlzZS5fdyB8fCBwcm9taXNlOyAvLyB1bndyYXBcbiAgdHJ5IHtcbiAgICBpZihwcm9taXNlID09PSB2YWx1ZSl0aHJvdyBUeXBlRXJyb3IoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZlwiKTtcbiAgICBpZih0aGVuID0gaXNUaGVuYWJsZSh2YWx1ZSkpe1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciB3cmFwcGVyID0ge193OiBwcm9taXNlLCBfZDogZmFsc2V9OyAvLyB3cmFwXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhlbi5jYWxsKHZhbHVlLCBjdHgoJHJlc29sdmUsIHdyYXBwZXIsIDEpLCBjdHgoJHJlamVjdCwgd3JhcHBlciwgMSkpO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICRyZWplY3QuY2FsbCh3cmFwcGVyLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgICAgIHByb21pc2UuX3MgPSAxO1xuICAgICAgbm90aWZ5KHByb21pc2UsIGZhbHNlKTtcbiAgICB9XG4gIH0gY2F0Y2goZSl7XG4gICAgJHJlamVjdC5jYWxsKHtfdzogcHJvbWlzZSwgX2Q6IGZhbHNlfSwgZSk7IC8vIHdyYXBcbiAgfVxufTtcblxuLy8gY29uc3RydWN0b3IgcG9seWZpbGxcbmlmKCFVU0VfTkFUSVZFKXtcbiAgLy8gMjUuNC4zLjEgUHJvbWlzZShleGVjdXRvcilcbiAgJFByb21pc2UgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKXtcbiAgICBhbkluc3RhbmNlKHRoaXMsICRQcm9taXNlLCBQUk9NSVNFLCAnX2gnKTtcbiAgICBhRnVuY3Rpb24oZXhlY3V0b3IpO1xuICAgIEludGVybmFsLmNhbGwodGhpcyk7XG4gICAgdHJ5IHtcbiAgICAgIGV4ZWN1dG9yKGN0eCgkcmVzb2x2ZSwgdGhpcywgMSksIGN0eCgkcmVqZWN0LCB0aGlzLCAxKSk7XG4gICAgfSBjYXRjaChlcnIpe1xuICAgICAgJHJlamVjdC5jYWxsKHRoaXMsIGVycik7XG4gICAgfVxuICB9O1xuICBJbnRlcm5hbCA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3Ipe1xuICAgIHRoaXMuX2MgPSBbXTsgICAgICAgICAgICAgLy8gPC0gYXdhaXRpbmcgcmVhY3Rpb25zXG4gICAgdGhpcy5fYSA9IHVuZGVmaW5lZDsgICAgICAvLyA8LSBjaGVja2VkIGluIGlzVW5oYW5kbGVkIHJlYWN0aW9uc1xuICAgIHRoaXMuX3MgPSAwOyAgICAgICAgICAgICAgLy8gPC0gc3RhdGVcbiAgICB0aGlzLl9kID0gZmFsc2U7ICAgICAgICAgIC8vIDwtIGRvbmVcbiAgICB0aGlzLl92ID0gdW5kZWZpbmVkOyAgICAgIC8vIDwtIHZhbHVlXG4gICAgdGhpcy5faCA9IDA7ICAgICAgICAgICAgICAvLyA8LSByZWplY3Rpb24gc3RhdGUsIDAgLSBkZWZhdWx0LCAxIC0gaGFuZGxlZCwgMiAtIHVuaGFuZGxlZFxuICAgIHRoaXMuX24gPSBmYWxzZTsgICAgICAgICAgLy8gPC0gbm90aWZ5XG4gIH07XG4gIEludGVybmFsLnByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpKCRQcm9taXNlLnByb3RvdHlwZSwge1xuICAgIC8vIDI1LjQuNS4zIFByb21pc2UucHJvdG90eXBlLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpXG4gICAgdGhlbjogZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCl7XG4gICAgICB2YXIgcmVhY3Rpb24gICAgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgJFByb21pc2UpKTtcbiAgICAgIHJlYWN0aW9uLm9rICAgICA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiB0cnVlO1xuICAgICAgcmVhY3Rpb24uZmFpbCAgID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT0gJ2Z1bmN0aW9uJyAmJiBvblJlamVjdGVkO1xuICAgICAgcmVhY3Rpb24uZG9tYWluID0gaXNOb2RlID8gcHJvY2Vzcy5kb21haW4gOiB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9jLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYodGhpcy5fYSl0aGlzLl9hLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYodGhpcy5fcylub3RpZnkodGhpcywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHJlYWN0aW9uLnByb21pc2U7XG4gICAgfSxcbiAgICAvLyAyNS40LjUuMSBQcm9taXNlLnByb3RvdHlwZS5jYXRjaChvblJlamVjdGVkKVxuICAgICdjYXRjaCc6IGZ1bmN0aW9uKG9uUmVqZWN0ZWQpe1xuICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH1cbiAgfSk7XG4gIFByb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgcHJvbWlzZSAgPSBuZXcgSW50ZXJuYWw7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICB0aGlzLnJlc29sdmUgPSBjdHgoJHJlc29sdmUsIHByb21pc2UsIDEpO1xuICAgIHRoaXMucmVqZWN0ICA9IGN0eCgkcmVqZWN0LCBwcm9taXNlLCAxKTtcbiAgfTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwge1Byb21pc2U6ICRQcm9taXNlfSk7XG5yZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpKCRQcm9taXNlLCBQUk9NSVNFKTtcbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoUFJPTUlTRSk7XG5XcmFwcGVyID0gcmVxdWlyZSgnLi9fY29yZScpW1BST01JU0VdO1xuXG4vLyBzdGF0aWNzXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC41IFByb21pc2UucmVqZWN0KHIpXG4gIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHIpe1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkodGhpcylcbiAgICAgICwgJCRyZWplY3QgICA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgICQkcmVqZWN0KHIpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTElCUkFSWSB8fCAhVVNFX05BVElWRSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjYgUHJvbWlzZS5yZXNvbHZlKHgpXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoeCl7XG4gICAgLy8gaW5zdGFuY2VvZiBpbnN0ZWFkIG9mIGludGVybmFsIHNsb3QgY2hlY2sgYmVjYXVzZSB3ZSBzaG91bGQgZml4IGl0IHdpdGhvdXQgcmVwbGFjZW1lbnQgbmF0aXZlIFByb21pc2UgY29yZVxuICAgIGlmKHggaW5zdGFuY2VvZiAkUHJvbWlzZSAmJiBzYW1lQ29uc3RydWN0b3IoeC5jb25zdHJ1Y3RvciwgdGhpcykpcmV0dXJuIHg7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSh0aGlzKVxuICAgICAgLCAkJHJlc29sdmUgID0gY2FwYWJpbGl0eS5yZXNvbHZlO1xuICAgICQkcmVzb2x2ZSh4KTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIShVU0VfTkFUSVZFICYmIHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JykoZnVuY3Rpb24oaXRlcil7XG4gICRQcm9taXNlLmFsbChpdGVyKVsnY2F0Y2gnXShlbXB0eSk7XG59KSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjEgUHJvbWlzZS5hbGwoaXRlcmFibGUpXG4gIGFsbDogZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKXtcbiAgICB2YXIgQyAgICAgICAgICA9IHRoaXNcbiAgICAgICwgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICAsIHJlc29sdmUgICAgPSBjYXBhYmlsaXR5LnJlc29sdmVcbiAgICAgICwgcmVqZWN0ICAgICA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciBhYnJ1cHQgPSBwZXJmb3JtKGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgdmFsdWVzICAgID0gW11cbiAgICAgICAgLCBpbmRleCAgICAgPSAwXG4gICAgICAgICwgcmVtYWluaW5nID0gMTtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24ocHJvbWlzZSl7XG4gICAgICAgIHZhciAkaW5kZXggICAgICAgID0gaW5kZXgrK1xuICAgICAgICAgICwgYWxyZWFkeUNhbGxlZCA9IGZhbHNlO1xuICAgICAgICB2YWx1ZXMucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICByZW1haW5pbmcrKztcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgICAgICAgIGlmKGFscmVhZHlDYWxsZWQpcmV0dXJuO1xuICAgICAgICAgIGFscmVhZHlDYWxsZWQgID0gdHJ1ZTtcbiAgICAgICAgICB2YWx1ZXNbJGluZGV4XSA9IHZhbHVlO1xuICAgICAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgIH0pO1xuICAgIGlmKGFicnVwdClyZWplY3QoYWJydXB0LmVycm9yKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9LFxuICAvLyAyNS40LjQuNCBQcm9taXNlLnJhY2UoaXRlcmFibGUpXG4gIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpe1xuICAgIHZhciBDICAgICAgICAgID0gdGhpc1xuICAgICAgLCBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICAgICwgcmVqZWN0ICAgICA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciBhYnJ1cHQgPSBwZXJmb3JtKGZ1bmN0aW9uKCl7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uKHByb21pc2Upe1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihjYXBhYmlsaXR5LnJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZihhYnJ1cHQpcmVqZWN0KGFicnVwdC5lcnJvcik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyIHN0cm9uZyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tc3Ryb25nJyk7XG5cbi8vIDIzLjIgU2V0IE9iamVjdHNcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKCdTZXQnLCBmdW5jdGlvbihnZXQpe1xuICByZXR1cm4gZnVuY3Rpb24gU2V0KCl7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwge1xuICAvLyAyMy4yLjMuMSBTZXQucHJvdG90eXBlLmFkZCh2YWx1ZSlcbiAgYWRkOiBmdW5jdGlvbiBhZGQodmFsdWUpe1xuICAgIHJldHVybiBzdHJvbmcuZGVmKHRoaXMsIHZhbHVlID0gdmFsdWUgPT09IDAgPyAwIDogdmFsdWUsIHZhbHVlKTtcbiAgfVxufSwgc3Ryb25nKTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGF0ICA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKHRydWUpO1xuXG4vLyAyMS4xLjMuMjcgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKFN0cmluZywgJ1N0cmluZycsIGZ1bmN0aW9uKGl0ZXJhdGVkKXtcbiAgdGhpcy5fdCA9IFN0cmluZyhpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuLy8gMjEuMS41LjIuMSAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24oKXtcbiAgdmFyIE8gICAgID0gdGhpcy5fdFxuICAgICwgaW5kZXggPSB0aGlzLl9pXG4gICAgLCBwb2ludDtcbiAgaWYoaW5kZXggPj0gTy5sZW5ndGgpcmV0dXJuIHt2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlfTtcbiAgcG9pbnQgPSAkYXQoTywgaW5kZXgpO1xuICB0aGlzLl9pICs9IHBvaW50Lmxlbmd0aDtcbiAgcmV0dXJuIHt2YWx1ZTogcG9pbnQsIGRvbmU6IGZhbHNlfTtcbn0pOyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuUiwgJ01hcCcsIHt0b0pTT046IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tdG8tanNvbicpKCdNYXAnKX0pOyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuUiwgJ1NldCcsIHt0b0pTT046IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tdG8tanNvbicpKCdTZXQnKX0pOyIsInJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG52YXIgZ2xvYmFsICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgaGlkZSAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIEl0ZXJhdG9ycyAgICAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAsIFRPX1NUUklOR19UQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcblxuZm9yKHZhciBjb2xsZWN0aW9ucyA9IFsnTm9kZUxpc3QnLCAnRE9NVG9rZW5MaXN0JywgJ01lZGlhTGlzdCcsICdTdHlsZVNoZWV0TGlzdCcsICdDU1NSdWxlTGlzdCddLCBpID0gMDsgaSA8IDU7IGkrKyl7XG4gIHZhciBOQU1FICAgICAgID0gY29sbGVjdGlvbnNbaV1cbiAgICAsIENvbGxlY3Rpb24gPSBnbG9iYWxbTkFNRV1cbiAgICAsIHByb3RvICAgICAgPSBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlO1xuICBpZihwcm90byAmJiAhcHJvdG9bVE9fU1RSSU5HX1RBR10paGlkZShwcm90bywgVE9fU1RSSU5HX1RBRywgTkFNRSk7XG4gIEl0ZXJhdG9yc1tOQU1FXSA9IEl0ZXJhdG9ycy5BcnJheTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxucmVxdWlyZShcImNvcmUtanMvc2hpbVwiKTtcblxucmVxdWlyZShcInJlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZVwiKTtcblxucmVxdWlyZShcImNvcmUtanMvZm4vcmVnZXhwL2VzY2FwZVwiKTtcblxuaWYgKGdsb2JhbC5fYmFiZWxQb2x5ZmlsbCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJvbmx5IG9uZSBpbnN0YW5jZSBvZiBiYWJlbC1wb2x5ZmlsbCBpcyBhbGxvd2VkXCIpO1xufVxuZ2xvYmFsLl9iYWJlbFBvbHlmaWxsID0gdHJ1ZTtcblxudmFyIERFRklORV9QUk9QRVJUWSA9IFwiZGVmaW5lUHJvcGVydHlcIjtcbmZ1bmN0aW9uIGRlZmluZShPLCBrZXksIHZhbHVlKSB7XG4gIE9ba2V5XSB8fCBPYmplY3RbREVGSU5FX1BST1BFUlRZXShPLCBrZXksIHtcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgdmFsdWU6IHZhbHVlXG4gIH0pO1xufVxuXG5kZWZpbmUoU3RyaW5nLnByb3RvdHlwZSwgXCJwYWRMZWZ0XCIsIFwiXCIucGFkU3RhcnQpO1xuZGVmaW5lKFN0cmluZy5wcm90b3R5cGUsIFwicGFkUmlnaHRcIiwgXCJcIi5wYWRFbmQpO1xuXG5cInBvcCxyZXZlcnNlLHNoaWZ0LGtleXMsdmFsdWVzLGVudHJpZXMsaW5kZXhPZixldmVyeSxzb21lLGZvckVhY2gsbWFwLGZpbHRlcixmaW5kLGZpbmRJbmRleCxpbmNsdWRlcyxqb2luLHNsaWNlLGNvbmNhdCxwdXNoLHNwbGljZSx1bnNoaWZ0LHNvcnQsbGFzdEluZGV4T2YscmVkdWNlLHJlZHVjZVJpZ2h0LGNvcHlXaXRoaW4sZmlsbFwiLnNwbGl0KFwiLFwiKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgW11ba2V5XSAmJiBkZWZpbmUoQXJyYXksIGtleSwgRnVuY3Rpb24uY2FsbC5iaW5kKFtdW2tleV0pKTtcbn0pOyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvY29yZS5yZWdleHAuZXNjYXBlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5SZWdFeHAuZXNjYXBlOyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZih0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJyl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59OyIsInZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIG1zZyl7XG4gIGlmKHR5cGVvZiBpdCAhPSAnbnVtYmVyJyAmJiBjb2YoaXQpICE9ICdOdW1iZXInKXRocm93IFR5cGVFcnJvcihtc2cpO1xuICByZXR1cm4gK2l0O1xufTsiLCIvLyAyMi4xLjMuMzEgQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXG52YXIgVU5TQ09QQUJMRVMgPSByZXF1aXJlKCcuL193a3MnKSgndW5zY29wYWJsZXMnKVxuICAsIEFycmF5UHJvdG8gID0gQXJyYXkucHJvdG90eXBlO1xuaWYoQXJyYXlQcm90b1tVTlNDT1BBQkxFU10gPT0gdW5kZWZpbmVkKXJlcXVpcmUoJy4vX2hpZGUnKShBcnJheVByb3RvLCBVTlNDT1BBQkxFUywge30pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICBBcnJheVByb3RvW1VOU0NPUEFCTEVTXVtrZXldID0gdHJ1ZTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgQ29uc3RydWN0b3IsIG5hbWUsIGZvcmJpZGRlbkZpZWxkKXtcbiAgaWYoIShpdCBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSB8fCAoZm9yYmlkZGVuRmllbGQgIT09IHVuZGVmaW5lZCAmJiBmb3JiaWRkZW5GaWVsZCBpbiBpdCkpe1xuICAgIHRocm93IFR5cGVFcnJvcihuYW1lICsgJzogaW5jb3JyZWN0IGludm9jYXRpb24hJyk7XG4gIH0gcmV0dXJuIGl0O1xufTsiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZighaXNPYmplY3QoaXQpKXRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTsiLCIvLyAyMi4xLjMuMyBBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbih0YXJnZXQsIHN0YXJ0LCBlbmQgPSB0aGlzLmxlbmd0aClcbid1c2Ugc3RyaWN0JztcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgdG9JbmRleCAgPSByZXF1aXJlKCcuL190by1pbmRleCcpXG4gICwgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBbXS5jb3B5V2l0aGluIHx8IGZ1bmN0aW9uIGNvcHlXaXRoaW4odGFyZ2V0Lyo9IDAqLywgc3RhcnQvKj0gMCwgZW5kID0gQGxlbmd0aCovKXtcbiAgdmFyIE8gICAgID0gdG9PYmplY3QodGhpcylcbiAgICAsIGxlbiAgID0gdG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgLCB0byAgICA9IHRvSW5kZXgodGFyZ2V0LCBsZW4pXG4gICAgLCBmcm9tICA9IHRvSW5kZXgoc3RhcnQsIGxlbilcbiAgICAsIGVuZCAgID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWRcbiAgICAsIGNvdW50ID0gTWF0aC5taW4oKGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogdG9JbmRleChlbmQsIGxlbikpIC0gZnJvbSwgbGVuIC0gdG8pXG4gICAgLCBpbmMgICA9IDE7XG4gIGlmKGZyb20gPCB0byAmJiB0byA8IGZyb20gKyBjb3VudCl7XG4gICAgaW5jICA9IC0xO1xuICAgIGZyb20gKz0gY291bnQgLSAxO1xuICAgIHRvICAgKz0gY291bnQgLSAxO1xuICB9XG4gIHdoaWxlKGNvdW50LS0gPiAwKXtcbiAgICBpZihmcm9tIGluIE8pT1t0b10gPSBPW2Zyb21dO1xuICAgIGVsc2UgZGVsZXRlIE9bdG9dO1xuICAgIHRvICAgKz0gaW5jO1xuICAgIGZyb20gKz0gaW5jO1xuICB9IHJldHVybiBPO1xufTsiLCIvLyAyMi4xLjMuNiBBcnJheS5wcm90b3R5cGUuZmlsbCh2YWx1ZSwgc3RhcnQgPSAwLCBlbmQgPSB0aGlzLmxlbmd0aClcbid1c2Ugc3RyaWN0JztcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgdG9JbmRleCAgPSByZXF1aXJlKCcuL190by1pbmRleCcpXG4gICwgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZmlsbCh2YWx1ZSAvKiwgc3RhcnQgPSAwLCBlbmQgPSBAbGVuZ3RoICovKXtcbiAgdmFyIE8gICAgICA9IHRvT2JqZWN0KHRoaXMpXG4gICAgLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aClcbiAgICAsIGFMZW4gICA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIGluZGV4ICA9IHRvSW5kZXgoYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIGxlbmd0aClcbiAgICAsIGVuZCAgICA9IGFMZW4gPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkXG4gICAgLCBlbmRQb3MgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHRvSW5kZXgoZW5kLCBsZW5ndGgpO1xuICB3aGlsZShlbmRQb3MgPiBpbmRleClPW2luZGV4KytdID0gdmFsdWU7XG4gIHJldHVybiBPO1xufTsiLCJ2YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdGVyLCBJVEVSQVRPUil7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yT2YoaXRlciwgZmFsc2UsIHJlc3VsdC5wdXNoLCByZXN1bHQsIElURVJBVE9SKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvLyBmYWxzZSAtPiBBcnJheSNpbmRleE9mXG4vLyB0cnVlICAtPiBBcnJheSNpbmNsdWRlc1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIHRvTGVuZ3RoICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgdG9JbmRleCAgID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oSVNfSU5DTFVERVMpe1xuICByZXR1cm4gZnVuY3Rpb24oJHRoaXMsIGVsLCBmcm9tSW5kZXgpe1xuICAgIHZhciBPICAgICAgPSB0b0lPYmplY3QoJHRoaXMpXG4gICAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKVxuICAgICAgLCBpbmRleCAgPSB0b0luZGV4KGZyb21JbmRleCwgbGVuZ3RoKVxuICAgICAgLCB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgaWYoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpd2hpbGUobGVuZ3RoID4gaW5kZXgpe1xuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xuICAgICAgaWYodmFsdWUgIT0gdmFsdWUpcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjdG9JbmRleCBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKWlmKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pe1xuICAgICAgaWYoT1tpbmRleF0gPT09IGVsKXJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07IiwiLy8gMCAtPiBBcnJheSNmb3JFYWNoXG4vLyAxIC0+IEFycmF5I21hcFxuLy8gMiAtPiBBcnJheSNmaWx0ZXJcbi8vIDMgLT4gQXJyYXkjc29tZVxuLy8gNCAtPiBBcnJheSNldmVyeVxuLy8gNSAtPiBBcnJheSNmaW5kXG4vLyA2IC0+IEFycmF5I2ZpbmRJbmRleFxudmFyIGN0eCAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBJT2JqZWN0ICA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKVxuICAsIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgYXNjICAgICAgPSByZXF1aXJlKCcuL19hcnJheS1zcGVjaWVzLWNyZWF0ZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihUWVBFLCAkY3JlYXRlKXtcbiAgdmFyIElTX01BUCAgICAgICAgPSBUWVBFID09IDFcbiAgICAsIElTX0ZJTFRFUiAgICAgPSBUWVBFID09IDJcbiAgICAsIElTX1NPTUUgICAgICAgPSBUWVBFID09IDNcbiAgICAsIElTX0VWRVJZICAgICAgPSBUWVBFID09IDRcbiAgICAsIElTX0ZJTkRfSU5ERVggPSBUWVBFID09IDZcbiAgICAsIE5PX0hPTEVTICAgICAgPSBUWVBFID09IDUgfHwgSVNfRklORF9JTkRFWFxuICAgICwgY3JlYXRlICAgICAgICA9ICRjcmVhdGUgfHwgYXNjO1xuICByZXR1cm4gZnVuY3Rpb24oJHRoaXMsIGNhbGxiYWNrZm4sIHRoYXQpe1xuICAgIHZhciBPICAgICAgPSB0b09iamVjdCgkdGhpcylcbiAgICAgICwgc2VsZiAgID0gSU9iamVjdChPKVxuICAgICAgLCBmICAgICAgPSBjdHgoY2FsbGJhY2tmbiwgdGhhdCwgMylcbiAgICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoc2VsZi5sZW5ndGgpXG4gICAgICAsIGluZGV4ICA9IDBcbiAgICAgICwgcmVzdWx0ID0gSVNfTUFQID8gY3JlYXRlKCR0aGlzLCBsZW5ndGgpIDogSVNfRklMVEVSID8gY3JlYXRlKCR0aGlzLCAwKSA6IHVuZGVmaW5lZFxuICAgICAgLCB2YWwsIHJlcztcbiAgICBmb3IoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKWlmKE5PX0hPTEVTIHx8IGluZGV4IGluIHNlbGYpe1xuICAgICAgdmFsID0gc2VsZltpbmRleF07XG4gICAgICByZXMgPSBmKHZhbCwgaW5kZXgsIE8pO1xuICAgICAgaWYoVFlQRSl7XG4gICAgICAgIGlmKElTX01BUClyZXN1bHRbaW5kZXhdID0gcmVzOyAgICAgICAgICAgIC8vIG1hcFxuICAgICAgICBlbHNlIGlmKHJlcylzd2l0Y2goVFlQRSl7XG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gdHJ1ZTsgICAgICAgICAgICAgICAgICAgIC8vIHNvbWVcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiB2YWw7ICAgICAgICAgICAgICAgICAgICAgLy8gZmluZFxuICAgICAgICAgIGNhc2UgNjogcmV0dXJuIGluZGV4OyAgICAgICAgICAgICAgICAgICAvLyBmaW5kSW5kZXhcbiAgICAgICAgICBjYXNlIDI6IHJlc3VsdC5wdXNoKHZhbCk7ICAgICAgICAgICAgICAgLy8gZmlsdGVyXG4gICAgICAgIH0gZWxzZSBpZihJU19FVkVSWSlyZXR1cm4gZmFsc2U7ICAgICAgICAgIC8vIGV2ZXJ5XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBJU19GSU5EX0lOREVYID8gLTEgOiBJU19TT01FIHx8IElTX0VWRVJZID8gSVNfRVZFUlkgOiByZXN1bHQ7XG4gIH07XG59OyIsInZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCB0b09iamVjdCAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIElPYmplY3QgICA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKVxuICAsIHRvTGVuZ3RoICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRoYXQsIGNhbGxiYWNrZm4sIGFMZW4sIG1lbW8sIGlzUmlnaHQpe1xuICBhRnVuY3Rpb24oY2FsbGJhY2tmbik7XG4gIHZhciBPICAgICAgPSB0b09iamVjdCh0aGF0KVxuICAgICwgc2VsZiAgID0gSU9iamVjdChPKVxuICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgLCBpbmRleCAgPSBpc1JpZ2h0ID8gbGVuZ3RoIC0gMSA6IDBcbiAgICAsIGkgICAgICA9IGlzUmlnaHQgPyAtMSA6IDE7XG4gIGlmKGFMZW4gPCAyKWZvcig7Oyl7XG4gICAgaWYoaW5kZXggaW4gc2VsZil7XG4gICAgICBtZW1vID0gc2VsZltpbmRleF07XG4gICAgICBpbmRleCArPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGluZGV4ICs9IGk7XG4gICAgaWYoaXNSaWdodCA/IGluZGV4IDwgMCA6IGxlbmd0aCA8PSBpbmRleCl7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ1JlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgICB9XG4gIH1cbiAgZm9yKDtpc1JpZ2h0ID8gaW5kZXggPj0gMCA6IGxlbmd0aCA+IGluZGV4OyBpbmRleCArPSBpKWlmKGluZGV4IGluIHNlbGYpe1xuICAgIG1lbW8gPSBjYWxsYmFja2ZuKG1lbW8sIHNlbGZbaW5kZXhdLCBpbmRleCwgTyk7XG4gIH1cbiAgcmV0dXJuIG1lbW87XG59OyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgaXNBcnJheSAgPSByZXF1aXJlKCcuL19pcy1hcnJheScpXG4gICwgU1BFQ0lFUyAgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9yaWdpbmFsKXtcbiAgdmFyIEM7XG4gIGlmKGlzQXJyYXkob3JpZ2luYWwpKXtcbiAgICBDID0gb3JpZ2luYWwuY29uc3RydWN0b3I7XG4gICAgLy8gY3Jvc3MtcmVhbG0gZmFsbGJhY2tcbiAgICBpZih0eXBlb2YgQyA9PSAnZnVuY3Rpb24nICYmIChDID09PSBBcnJheSB8fCBpc0FycmF5KEMucHJvdG90eXBlKSkpQyA9IHVuZGVmaW5lZDtcbiAgICBpZihpc09iamVjdChDKSl7XG4gICAgICBDID0gQ1tTUEVDSUVTXTtcbiAgICAgIGlmKEMgPT09IG51bGwpQyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gcmV0dXJuIEMgPT09IHVuZGVmaW5lZCA/IEFycmF5IDogQztcbn07IiwiLy8gOS40LjIuMyBBcnJheVNwZWNpZXNDcmVhdGUob3JpZ2luYWxBcnJheSwgbGVuZ3RoKVxudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcmlnaW5hbCwgbGVuZ3RoKXtcbiAgcmV0dXJuIG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yKG9yaWdpbmFsKSkobGVuZ3RoKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFGdW5jdGlvbiAgPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCBpc09iamVjdCAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBpbnZva2UgICAgID0gcmVxdWlyZSgnLi9faW52b2tlJylcbiAgLCBhcnJheVNsaWNlID0gW10uc2xpY2VcbiAgLCBmYWN0b3JpZXMgID0ge307XG5cbnZhciBjb25zdHJ1Y3QgPSBmdW5jdGlvbihGLCBsZW4sIGFyZ3Mpe1xuICBpZighKGxlbiBpbiBmYWN0b3JpZXMpKXtcbiAgICBmb3IodmFyIG4gPSBbXSwgaSA9IDA7IGkgPCBsZW47IGkrKyluW2ldID0gJ2FbJyArIGkgKyAnXSc7XG4gICAgZmFjdG9yaWVzW2xlbl0gPSBGdW5jdGlvbignRixhJywgJ3JldHVybiBuZXcgRignICsgbi5qb2luKCcsJykgKyAnKScpO1xuICB9IHJldHVybiBmYWN0b3JpZXNbbGVuXShGLCBhcmdzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24uYmluZCB8fCBmdW5jdGlvbiBiaW5kKHRoYXQgLyosIGFyZ3MuLi4gKi8pe1xuICB2YXIgZm4gICAgICAgPSBhRnVuY3Rpb24odGhpcylcbiAgICAsIHBhcnRBcmdzID0gYXJyYXlTbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHZhciBib3VuZCA9IGZ1bmN0aW9uKC8qIGFyZ3MuLi4gKi8pe1xuICAgIHZhciBhcmdzID0gcGFydEFyZ3MuY29uY2F0KGFycmF5U2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIGJvdW5kID8gY29uc3RydWN0KGZuLCBhcmdzLmxlbmd0aCwgYXJncykgOiBpbnZva2UoZm4sIGFyZ3MsIHRoYXQpO1xuICB9O1xuICBpZihpc09iamVjdChmbi5wcm90b3R5cGUpKWJvdW5kLnByb3RvdHlwZSA9IGZuLnByb3RvdHlwZTtcbiAgcmV0dXJuIGJvdW5kO1xufTsiLCIvLyBnZXR0aW5nIHRhZyBmcm9tIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpXG4gICwgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJylcbiAgLy8gRVMzIHdyb25nIGhlcmVcbiAgLCBBUkcgPSBjb2YoZnVuY3Rpb24oKXsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbihpdCwga2V5KXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBPLCBULCBCO1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAoVCA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVEFHKSkgPT0gJ3N0cmluZycgPyBUXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBBUkcgPyBjb2YoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAoQiA9IGNvZihPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IEI7XG59OyIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGRQICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGNyZWF0ZSAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpXG4gICwgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKVxuICAsIGN0eCAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBhbkluc3RhbmNlICA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJylcbiAgLCBkZWZpbmVkICAgICA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKVxuICAsIGZvck9mICAgICAgID0gcmVxdWlyZSgnLi9fZm9yLW9mJylcbiAgLCAkaXRlckRlZmluZSA9IHJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJylcbiAgLCBzdGVwICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpXG4gICwgc2V0U3BlY2llcyAgPSByZXF1aXJlKCcuL19zZXQtc3BlY2llcycpXG4gICwgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpXG4gICwgZmFzdEtleSAgICAgPSByZXF1aXJlKCcuL19tZXRhJykuZmFzdEtleVxuICAsIFNJWkUgICAgICAgID0gREVTQ1JJUFRPUlMgPyAnX3MnIDogJ3NpemUnO1xuXG52YXIgZ2V0RW50cnkgPSBmdW5jdGlvbih0aGF0LCBrZXkpe1xuICAvLyBmYXN0IGNhc2VcbiAgdmFyIGluZGV4ID0gZmFzdEtleShrZXkpLCBlbnRyeTtcbiAgaWYoaW5kZXggIT09ICdGJylyZXR1cm4gdGhhdC5faVtpbmRleF07XG4gIC8vIGZyb3plbiBvYmplY3QgY2FzZVxuICBmb3IoZW50cnkgPSB0aGF0Ll9mOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKXtcbiAgICBpZihlbnRyeS5rID09IGtleSlyZXR1cm4gZW50cnk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24od3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUil7XG4gICAgdmFyIEMgPSB3cmFwcGVyKGZ1bmN0aW9uKHRoYXQsIGl0ZXJhYmxlKXtcbiAgICAgIGFuSW5zdGFuY2UodGhhdCwgQywgTkFNRSwgJ19pJyk7XG4gICAgICB0aGF0Ll9pID0gY3JlYXRlKG51bGwpOyAvLyBpbmRleFxuICAgICAgdGhhdC5fZiA9IHVuZGVmaW5lZDsgICAgLy8gZmlyc3QgZW50cnlcbiAgICAgIHRoYXQuX2wgPSB1bmRlZmluZWQ7ICAgIC8vIGxhc3QgZW50cnlcbiAgICAgIHRoYXRbU0laRV0gPSAwOyAgICAgICAgIC8vIHNpemVcbiAgICAgIGlmKGl0ZXJhYmxlICE9IHVuZGVmaW5lZClmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgfSk7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIHtcbiAgICAgIC8vIDIzLjEuMy4xIE1hcC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgLy8gMjMuMi4zLjIgU2V0LnByb3RvdHlwZS5jbGVhcigpXG4gICAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKXtcbiAgICAgICAgZm9yKHZhciB0aGF0ID0gdGhpcywgZGF0YSA9IHRoYXQuX2ksIGVudHJ5ID0gdGhhdC5fZjsgZW50cnk7IGVudHJ5ID0gZW50cnkubil7XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYoZW50cnkucCllbnRyeS5wID0gZW50cnkucC5uID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGRlbGV0ZSBkYXRhW2VudHJ5LmldO1xuICAgICAgICB9XG4gICAgICAgIHRoYXQuX2YgPSB0aGF0Ll9sID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGF0W1NJWkVdID0gMDtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuMyBNYXAucHJvdG90eXBlLmRlbGV0ZShrZXkpXG4gICAgICAvLyAyMy4yLjMuNCBTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbihrZXkpe1xuICAgICAgICB2YXIgdGhhdCAgPSB0aGlzXG4gICAgICAgICAgLCBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XG4gICAgICAgIGlmKGVudHJ5KXtcbiAgICAgICAgICB2YXIgbmV4dCA9IGVudHJ5Lm5cbiAgICAgICAgICAgICwgcHJldiA9IGVudHJ5LnA7XG4gICAgICAgICAgZGVsZXRlIHRoYXQuX2lbZW50cnkuaV07XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYocHJldilwcmV2Lm4gPSBuZXh0O1xuICAgICAgICAgIGlmKG5leHQpbmV4dC5wID0gcHJldjtcbiAgICAgICAgICBpZih0aGF0Ll9mID09IGVudHJ5KXRoYXQuX2YgPSBuZXh0O1xuICAgICAgICAgIGlmKHRoYXQuX2wgPT0gZW50cnkpdGhhdC5fbCA9IHByZXY7XG4gICAgICAgICAgdGhhdFtTSVpFXS0tO1xuICAgICAgICB9IHJldHVybiAhIWVudHJ5O1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjIuMy42IFNldC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgLy8gMjMuMS4zLjUgTWFwLnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyosIHRoYXQgPSB1bmRlZmluZWQgKi8pe1xuICAgICAgICBhbkluc3RhbmNlKHRoaXMsIEMsICdmb3JFYWNoJyk7XG4gICAgICAgIHZhciBmID0gY3R4KGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCAzKVxuICAgICAgICAgICwgZW50cnk7XG4gICAgICAgIHdoaWxlKGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhpcy5fZil7XG4gICAgICAgICAgZihlbnRyeS52LCBlbnRyeS5rLCB0aGlzKTtcbiAgICAgICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgICAgICB3aGlsZShlbnRyeSAmJiBlbnRyeS5yKWVudHJ5ID0gZW50cnkucDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIDIzLjEuMy43IE1hcC5wcm90b3R5cGUuaGFzKGtleSlcbiAgICAgIC8vIDIzLjIuMy43IFNldC5wcm90b3R5cGUuaGFzKHZhbHVlKVxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KXtcbiAgICAgICAgcmV0dXJuICEhZ2V0RW50cnkodGhpcywga2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZihERVNDUklQVE9SUylkUChDLnByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBkZWZpbmVkKHRoaXNbU0laRV0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBDO1xuICB9LFxuICBkZWY6IGZ1bmN0aW9uKHRoYXQsIGtleSwgdmFsdWUpe1xuICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSlcbiAgICAgICwgcHJldiwgaW5kZXg7XG4gICAgLy8gY2hhbmdlIGV4aXN0aW5nIGVudHJ5XG4gICAgaWYoZW50cnkpe1xuICAgICAgZW50cnkudiA9IHZhbHVlO1xuICAgIC8vIGNyZWF0ZSBuZXcgZW50cnlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhhdC5fbCA9IGVudHJ5ID0ge1xuICAgICAgICBpOiBpbmRleCA9IGZhc3RLZXkoa2V5LCB0cnVlKSwgLy8gPC0gaW5kZXhcbiAgICAgICAgazoga2V5LCAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIGtleVxuICAgICAgICB2OiB2YWx1ZSwgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gdmFsdWVcbiAgICAgICAgcDogcHJldiA9IHRoYXQuX2wsICAgICAgICAgICAgIC8vIDwtIHByZXZpb3VzIGVudHJ5XG4gICAgICAgIG46IHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAvLyA8LSBuZXh0IGVudHJ5XG4gICAgICAgIHI6IGZhbHNlICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSByZW1vdmVkXG4gICAgICB9O1xuICAgICAgaWYoIXRoYXQuX2YpdGhhdC5fZiA9IGVudHJ5O1xuICAgICAgaWYocHJldilwcmV2Lm4gPSBlbnRyeTtcbiAgICAgIHRoYXRbU0laRV0rKztcbiAgICAgIC8vIGFkZCB0byBpbmRleFxuICAgICAgaWYoaW5kZXggIT09ICdGJyl0aGF0Ll9pW2luZGV4XSA9IGVudHJ5O1xuICAgIH0gcmV0dXJuIHRoYXQ7XG4gIH0sXG4gIGdldEVudHJ5OiBnZXRFbnRyeSxcbiAgc2V0U3Ryb25nOiBmdW5jdGlvbihDLCBOQU1FLCBJU19NQVApe1xuICAgIC8vIGFkZCAua2V5cywgLnZhbHVlcywgLmVudHJpZXMsIFtAQGl0ZXJhdG9yXVxuICAgIC8vIDIzLjEuMy40LCAyMy4xLjMuOCwgMjMuMS4zLjExLCAyMy4xLjMuMTIsIDIzLjIuMy41LCAyMy4yLjMuOCwgMjMuMi4zLjEwLCAyMy4yLjMuMTFcbiAgICAkaXRlckRlZmluZShDLCBOQU1FLCBmdW5jdGlvbihpdGVyYXRlZCwga2luZCl7XG4gICAgICB0aGlzLl90ID0gaXRlcmF0ZWQ7ICAvLyB0YXJnZXRcbiAgICAgIHRoaXMuX2sgPSBraW5kOyAgICAgIC8vIGtpbmRcbiAgICAgIHRoaXMuX2wgPSB1bmRlZmluZWQ7IC8vIHByZXZpb3VzXG4gICAgfSwgZnVuY3Rpb24oKXtcbiAgICAgIHZhciB0aGF0ICA9IHRoaXNcbiAgICAgICAgLCBraW5kICA9IHRoYXQuX2tcbiAgICAgICAgLCBlbnRyeSA9IHRoYXQuX2w7XG4gICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgIHdoaWxlKGVudHJ5ICYmIGVudHJ5LnIpZW50cnkgPSBlbnRyeS5wO1xuICAgICAgLy8gZ2V0IG5leHQgZW50cnlcbiAgICAgIGlmKCF0aGF0Ll90IHx8ICEodGhhdC5fbCA9IGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhhdC5fdC5fZikpe1xuICAgICAgICAvLyBvciBmaW5pc2ggdGhlIGl0ZXJhdGlvblxuICAgICAgICB0aGF0Ll90ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gc3RlcCgxKTtcbiAgICAgIH1cbiAgICAgIC8vIHJldHVybiBzdGVwIGJ5IGtpbmRcbiAgICAgIGlmKGtpbmQgPT0gJ2tleXMnICApcmV0dXJuIHN0ZXAoMCwgZW50cnkuayk7XG4gICAgICBpZihraW5kID09ICd2YWx1ZXMnKXJldHVybiBzdGVwKDAsIGVudHJ5LnYpO1xuICAgICAgcmV0dXJuIHN0ZXAoMCwgW2VudHJ5LmssIGVudHJ5LnZdKTtcbiAgICB9LCBJU19NQVAgPyAnZW50cmllcycgOiAndmFsdWVzJyAsICFJU19NQVAsIHRydWUpO1xuXG4gICAgLy8gYWRkIFtAQHNwZWNpZXNdLCAyMy4xLjIuMiwgMjMuMi4yLjJcbiAgICBzZXRTcGVjaWVzKE5BTUUpO1xuICB9XG59OyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpXG4gICwgZnJvbSAgICA9IHJlcXVpcmUoJy4vX2FycmF5LWZyb20taXRlcmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTkFNRSl7XG4gIHJldHVybiBmdW5jdGlvbiB0b0pTT04oKXtcbiAgICBpZihjbGFzc29mKHRoaXMpICE9IE5BTUUpdGhyb3cgVHlwZUVycm9yKE5BTUUgKyBcIiN0b0pTT04gaXNuJ3QgZ2VuZXJpY1wiKTtcbiAgICByZXR1cm4gZnJvbSh0aGlzKTtcbiAgfTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyIHJlZGVmaW5lQWxsICAgICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJylcbiAgLCBnZXRXZWFrICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGEnKS5nZXRXZWFrXG4gICwgYW5PYmplY3QgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGlzT2JqZWN0ICAgICAgICAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBhbkluc3RhbmNlICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJylcbiAgLCBmb3JPZiAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2Zvci1vZicpXG4gICwgY3JlYXRlQXJyYXlNZXRob2QgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJylcbiAgLCAkaGFzICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgYXJyYXlGaW5kICAgICAgICAgPSBjcmVhdGVBcnJheU1ldGhvZCg1KVxuICAsIGFycmF5RmluZEluZGV4ICAgID0gY3JlYXRlQXJyYXlNZXRob2QoNilcbiAgLCBpZCAgICAgICAgICAgICAgICA9IDA7XG5cbi8vIGZhbGxiYWNrIGZvciB1bmNhdWdodCBmcm96ZW4ga2V5c1xudmFyIHVuY2F1Z2h0RnJvemVuU3RvcmUgPSBmdW5jdGlvbih0aGF0KXtcbiAgcmV0dXJuIHRoYXQuX2wgfHwgKHRoYXQuX2wgPSBuZXcgVW5jYXVnaHRGcm96ZW5TdG9yZSk7XG59O1xudmFyIFVuY2F1Z2h0RnJvemVuU3RvcmUgPSBmdW5jdGlvbigpe1xuICB0aGlzLmEgPSBbXTtcbn07XG52YXIgZmluZFVuY2F1Z2h0RnJvemVuID0gZnVuY3Rpb24oc3RvcmUsIGtleSl7XG4gIHJldHVybiBhcnJheUZpbmQoc3RvcmUuYSwgZnVuY3Rpb24oaXQpe1xuICAgIHJldHVybiBpdFswXSA9PT0ga2V5O1xuICB9KTtcbn07XG5VbmNhdWdodEZyb3plblN0b3JlLnByb3RvdHlwZSA9IHtcbiAgZ2V0OiBmdW5jdGlvbihrZXkpe1xuICAgIHZhciBlbnRyeSA9IGZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICAgIGlmKGVudHJ5KXJldHVybiBlbnRyeVsxXTtcbiAgfSxcbiAgaGFzOiBmdW5jdGlvbihrZXkpe1xuICAgIHJldHVybiAhIWZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpe1xuICAgIHZhciBlbnRyeSA9IGZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICAgIGlmKGVudHJ5KWVudHJ5WzFdID0gdmFsdWU7XG4gICAgZWxzZSB0aGlzLmEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9LFxuICAnZGVsZXRlJzogZnVuY3Rpb24oa2V5KXtcbiAgICB2YXIgaW5kZXggPSBhcnJheUZpbmRJbmRleCh0aGlzLmEsIGZ1bmN0aW9uKGl0KXtcbiAgICAgIHJldHVybiBpdFswXSA9PT0ga2V5O1xuICAgIH0pO1xuICAgIGlmKH5pbmRleCl0aGlzLmEuc3BsaWNlKGluZGV4LCAxKTtcbiAgICByZXR1cm4gISF+aW5kZXg7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24od3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUil7XG4gICAgdmFyIEMgPSB3cmFwcGVyKGZ1bmN0aW9uKHRoYXQsIGl0ZXJhYmxlKXtcbiAgICAgIGFuSW5zdGFuY2UodGhhdCwgQywgTkFNRSwgJ19pJyk7XG4gICAgICB0aGF0Ll9pID0gaWQrKzsgICAgICAvLyBjb2xsZWN0aW9uIGlkXG4gICAgICB0aGF0Ll9sID0gdW5kZWZpbmVkOyAvLyBsZWFrIHN0b3JlIGZvciB1bmNhdWdodCBmcm96ZW4gb2JqZWN0c1xuICAgICAgaWYoaXRlcmFibGUgIT0gdW5kZWZpbmVkKWZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICB9KTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwge1xuICAgICAgLy8gMjMuMy4zLjIgV2Vha01hcC5wcm90b3R5cGUuZGVsZXRlKGtleSlcbiAgICAgIC8vIDIzLjQuMy4zIFdlYWtTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbihrZXkpe1xuICAgICAgICBpZighaXNPYmplY3Qoa2V5KSlyZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBkYXRhID0gZ2V0V2VhayhrZXkpO1xuICAgICAgICBpZihkYXRhID09PSB0cnVlKXJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHRoaXMpWydkZWxldGUnXShrZXkpO1xuICAgICAgICByZXR1cm4gZGF0YSAmJiAkaGFzKGRhdGEsIHRoaXMuX2kpICYmIGRlbGV0ZSBkYXRhW3RoaXMuX2ldO1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjMuMy40IFdlYWtNYXAucHJvdG90eXBlLmhhcyhrZXkpXG4gICAgICAvLyAyMy40LjMuNCBXZWFrU2V0LnByb3RvdHlwZS5oYXModmFsdWUpXG4gICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpe1xuICAgICAgICBpZighaXNPYmplY3Qoa2V5KSlyZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBkYXRhID0gZ2V0V2VhayhrZXkpO1xuICAgICAgICBpZihkYXRhID09PSB0cnVlKXJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHRoaXMpLmhhcyhrZXkpO1xuICAgICAgICByZXR1cm4gZGF0YSAmJiAkaGFzKGRhdGEsIHRoaXMuX2kpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBDO1xuICB9LFxuICBkZWY6IGZ1bmN0aW9uKHRoYXQsIGtleSwgdmFsdWUpe1xuICAgIHZhciBkYXRhID0gZ2V0V2Vhayhhbk9iamVjdChrZXkpLCB0cnVlKTtcbiAgICBpZihkYXRhID09PSB0cnVlKXVuY2F1Z2h0RnJvemVuU3RvcmUodGhhdCkuc2V0KGtleSwgdmFsdWUpO1xuICAgIGVsc2UgZGF0YVt0aGF0Ll9pXSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGF0O1xuICB9LFxuICB1ZnN0b3JlOiB1bmNhdWdodEZyb3plblN0b3JlXG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgJGV4cG9ydCAgICAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHJlZGVmaW5lICAgICAgICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKVxuICAsIHJlZGVmaW5lQWxsICAgICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJylcbiAgLCBtZXRhICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGEnKVxuICAsIGZvck9mICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZm9yLW9mJylcbiAgLCBhbkluc3RhbmNlICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJylcbiAgLCBpc09iamVjdCAgICAgICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgZmFpbHMgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgJGl0ZXJEZXRlY3QgICAgICAgPSByZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpXG4gICwgc2V0VG9TdHJpbmdUYWcgICAgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgaW5oZXJpdElmUmVxdWlyZWQgPSByZXF1aXJlKCcuL19pbmhlcml0LWlmLXJlcXVpcmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTkFNRSwgd3JhcHBlciwgbWV0aG9kcywgY29tbW9uLCBJU19NQVAsIElTX1dFQUspe1xuICB2YXIgQmFzZSAgPSBnbG9iYWxbTkFNRV1cbiAgICAsIEMgICAgID0gQmFzZVxuICAgICwgQURERVIgPSBJU19NQVAgPyAnc2V0JyA6ICdhZGQnXG4gICAgLCBwcm90byA9IEMgJiYgQy5wcm90b3R5cGVcbiAgICAsIE8gICAgID0ge307XG4gIHZhciBmaXhNZXRob2QgPSBmdW5jdGlvbihLRVkpe1xuICAgIHZhciBmbiA9IHByb3RvW0tFWV07XG4gICAgcmVkZWZpbmUocHJvdG8sIEtFWSxcbiAgICAgIEtFWSA9PSAnZGVsZXRlJyA/IGZ1bmN0aW9uKGEpe1xuICAgICAgICByZXR1cm4gSVNfV0VBSyAmJiAhaXNPYmplY3QoYSkgPyBmYWxzZSA6IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTtcbiAgICAgIH0gOiBLRVkgPT0gJ2hhcycgPyBmdW5jdGlvbiBoYXMoYSl7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IGZhbHNlIDogZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpO1xuICAgICAgfSA6IEtFWSA9PSAnZ2V0JyA/IGZ1bmN0aW9uIGdldChhKXtcbiAgICAgICAgcmV0dXJuIElTX1dFQUsgJiYgIWlzT2JqZWN0KGEpID8gdW5kZWZpbmVkIDogZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpO1xuICAgICAgfSA6IEtFWSA9PSAnYWRkJyA/IGZ1bmN0aW9uIGFkZChhKXsgZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpOyByZXR1cm4gdGhpczsgfVxuICAgICAgICA6IGZ1bmN0aW9uIHNldChhLCBiKXsgZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEsIGIpOyByZXR1cm4gdGhpczsgfVxuICAgICk7XG4gIH07XG4gIGlmKHR5cGVvZiBDICE9ICdmdW5jdGlvbicgfHwgIShJU19XRUFLIHx8IHByb3RvLmZvckVhY2ggJiYgIWZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgbmV3IEMoKS5lbnRyaWVzKCkubmV4dCgpO1xuICB9KSkpe1xuICAgIC8vIGNyZWF0ZSBjb2xsZWN0aW9uIGNvbnN0cnVjdG9yXG4gICAgQyA9IGNvbW1vbi5nZXRDb25zdHJ1Y3Rvcih3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwgbWV0aG9kcyk7XG4gICAgbWV0YS5ORUVEID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaW5zdGFuY2UgICAgICAgICAgICAgPSBuZXcgQ1xuICAgICAgLy8gZWFybHkgaW1wbGVtZW50YXRpb25zIG5vdCBzdXBwb3J0cyBjaGFpbmluZ1xuICAgICAgLCBIQVNOVF9DSEFJTklORyAgICAgICA9IGluc3RhbmNlW0FEREVSXShJU19XRUFLID8ge30gOiAtMCwgMSkgIT0gaW5zdGFuY2VcbiAgICAgIC8vIFY4IH4gIENocm9taXVtIDQwLSB3ZWFrLWNvbGxlY3Rpb25zIHRocm93cyBvbiBwcmltaXRpdmVzLCBidXQgc2hvdWxkIHJldHVybiBmYWxzZVxuICAgICAgLCBUSFJPV1NfT05fUFJJTUlUSVZFUyA9IGZhaWxzKGZ1bmN0aW9uKCl7IGluc3RhbmNlLmhhcygxKTsgfSlcbiAgICAgIC8vIG1vc3QgZWFybHkgaW1wbGVtZW50YXRpb25zIGRvZXNuJ3Qgc3VwcG9ydHMgaXRlcmFibGVzLCBtb3N0IG1vZGVybiAtIG5vdCBjbG9zZSBpdCBjb3JyZWN0bHlcbiAgICAgICwgQUNDRVBUX0lURVJBQkxFUyAgICAgPSAkaXRlckRldGVjdChmdW5jdGlvbihpdGVyKXsgbmV3IEMoaXRlcik7IH0pIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgICAvLyBmb3IgZWFybHkgaW1wbGVtZW50YXRpb25zIC0wIGFuZCArMCBub3QgdGhlIHNhbWVcbiAgICAgICwgQlVHR1lfWkVSTyA9ICFJU19XRUFLICYmIGZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgICAgIC8vIFY4IH4gQ2hyb21pdW0gNDItIGZhaWxzIG9ubHkgd2l0aCA1KyBlbGVtZW50c1xuICAgICAgICB2YXIgJGluc3RhbmNlID0gbmV3IEMoKVxuICAgICAgICAgICwgaW5kZXggICAgID0gNTtcbiAgICAgICAgd2hpbGUoaW5kZXgtLSkkaW5zdGFuY2VbQURERVJdKGluZGV4LCBpbmRleCk7XG4gICAgICAgIHJldHVybiAhJGluc3RhbmNlLmhhcygtMCk7XG4gICAgICB9KTtcbiAgICBpZighQUNDRVBUX0lURVJBQkxFUyl7IFxuICAgICAgQyA9IHdyYXBwZXIoZnVuY3Rpb24odGFyZ2V0LCBpdGVyYWJsZSl7XG4gICAgICAgIGFuSW5zdGFuY2UodGFyZ2V0LCBDLCBOQU1FKTtcbiAgICAgICAgdmFyIHRoYXQgPSBpbmhlcml0SWZSZXF1aXJlZChuZXcgQmFzZSwgdGFyZ2V0LCBDKTtcbiAgICAgICAgaWYoaXRlcmFibGUgIT0gdW5kZWZpbmVkKWZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgICB9KTtcbiAgICAgIEMucHJvdG90eXBlID0gcHJvdG87XG4gICAgICBwcm90by5jb25zdHJ1Y3RvciA9IEM7XG4gICAgfVxuICAgIGlmKFRIUk9XU19PTl9QUklNSVRJVkVTIHx8IEJVR0dZX1pFUk8pe1xuICAgICAgZml4TWV0aG9kKCdkZWxldGUnKTtcbiAgICAgIGZpeE1ldGhvZCgnaGFzJyk7XG4gICAgICBJU19NQVAgJiYgZml4TWV0aG9kKCdnZXQnKTtcbiAgICB9XG4gICAgaWYoQlVHR1lfWkVSTyB8fCBIQVNOVF9DSEFJTklORylmaXhNZXRob2QoQURERVIpO1xuICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgc2hvdWxkIG5vdCBjb250YWlucyAuY2xlYXIgbWV0aG9kXG4gICAgaWYoSVNfV0VBSyAmJiBwcm90by5jbGVhcilkZWxldGUgcHJvdG8uY2xlYXI7XG4gIH1cblxuICBzZXRUb1N0cmluZ1RhZyhDLCBOQU1FKTtcblxuICBPW05BTUVdID0gQztcbiAgJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAoQyAhPSBCYXNlKSwgTyk7XG5cbiAgaWYoIUlTX1dFQUspY29tbW9uLnNldFN0cm9uZyhDLCBOQU1FLCBJU19NQVApO1xuXG4gIHJldHVybiBDO1xufTsiLCJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0ge3ZlcnNpb246ICcyLjQuMCd9O1xuaWYodHlwZW9mIF9fZSA9PSAnbnVtYmVyJylfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgY3JlYXRlRGVzYyAgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iamVjdCwgaW5kZXgsIHZhbHVlKXtcbiAgaWYoaW5kZXggaW4gb2JqZWN0KSRkZWZpbmVQcm9wZXJ0eS5mKG9iamVjdCwgaW5kZXgsIGNyZWF0ZURlc2MoMCwgdmFsdWUpKTtcbiAgZWxzZSBvYmplY3RbaW5kZXhdID0gdmFsdWU7XG59OyIsIi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZm4sIHRoYXQsIGxlbmd0aCl7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmKHRoYXQgPT09IHVuZGVmaW5lZClyZXR1cm4gZm47XG4gIHN3aXRjaChsZW5ndGgpe1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKGEpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbihhLCBiKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24oYSwgYiwgYyl7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbigvKiAuLi5hcmdzICovKXtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgTlVNQkVSICAgICAgPSAnbnVtYmVyJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihoaW50KXtcbiAgaWYoaGludCAhPT0gJ3N0cmluZycgJiYgaGludCAhPT0gTlVNQkVSICYmIGhpbnQgIT09ICdkZWZhdWx0Jyl0aHJvdyBUeXBlRXJyb3IoJ0luY29ycmVjdCBoaW50Jyk7XG4gIHJldHVybiB0b1ByaW1pdGl2ZShhbk9iamVjdCh0aGlzKSwgaGludCAhPSBOVU1CRVIpO1xufTsiLCIvLyA3LjIuMSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKGl0ID09IHVuZGVmaW5lZCl0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07IiwiLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9fSkuYSAhPSA3O1xufSk7IiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50XG4gIC8vIGluIG9sZCBJRSB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0J1xuICAsIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59OyIsIi8vIElFIDgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gKFxuICAnY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mJ1xuKS5zcGxpdCgnLCcpOyIsIi8vIGFsbCBlbnVtZXJhYmxlIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBzeW1ib2xzXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCBnT1BTICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKVxuICAsIHBJRSAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIHJlc3VsdCAgICAgPSBnZXRLZXlzKGl0KVxuICAgICwgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgaWYoZ2V0U3ltYm9scyl7XG4gICAgdmFyIHN5bWJvbHMgPSBnZXRTeW1ib2xzKGl0KVxuICAgICAgLCBpc0VudW0gID0gcElFLmZcbiAgICAgICwgaSAgICAgICA9IDBcbiAgICAgICwga2V5O1xuICAgIHdoaWxlKHN5bWJvbHMubGVuZ3RoID4gaSlpZihpc0VudW0uY2FsbChpdCwga2V5ID0gc3ltYm9sc1tpKytdKSlyZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59OyIsInZhciBnbG9iYWwgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGNvcmUgICAgICA9IHJlcXVpcmUoJy4vX2NvcmUnKVxuICAsIGhpZGUgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIHJlZGVmaW5lICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCBjdHggICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG52YXIgJGV4cG9ydCA9IGZ1bmN0aW9uKHR5cGUsIG5hbWUsIHNvdXJjZSl7XG4gIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GXG4gICAgLCBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HXG4gICAgLCBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TXG4gICAgLCBJU19QUk9UTyAgPSB0eXBlICYgJGV4cG9ydC5QXG4gICAgLCBJU19CSU5EICAgPSB0eXBlICYgJGV4cG9ydC5CXG4gICAgLCB0YXJnZXQgICAgPSBJU19HTE9CQUwgPyBnbG9iYWwgOiBJU19TVEFUSUMgPyBnbG9iYWxbbmFtZV0gfHwgKGdsb2JhbFtuYW1lXSA9IHt9KSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV1cbiAgICAsIGV4cG9ydHMgICA9IElTX0dMT0JBTCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pXG4gICAgLCBleHBQcm90byAgPSBleHBvcnRzW1BST1RPVFlQRV0gfHwgKGV4cG9ydHNbUFJPVE9UWVBFXSA9IHt9KVxuICAgICwga2V5LCBvd24sIG91dCwgZXhwO1xuICBpZihJU19HTE9CQUwpc291cmNlID0gbmFtZTtcbiAgZm9yKGtleSBpbiBzb3VyY2Upe1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSAob3duID8gdGFyZ2V0IDogc291cmNlKVtrZXldO1xuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgZXhwID0gSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG4gICAgLy8gZXh0ZW5kIGdsb2JhbFxuICAgIGlmKHRhcmdldClyZWRlZmluZSh0YXJnZXQsIGtleSwgb3V0LCB0eXBlICYgJGV4cG9ydC5VKTtcbiAgICAvLyBleHBvcnRcbiAgICBpZihleHBvcnRzW2tleV0gIT0gb3V0KWhpZGUoZXhwb3J0cywga2V5LCBleHApO1xuICAgIGlmKElTX1BST1RPICYmIGV4cFByb3RvW2tleV0gIT0gb3V0KWV4cFByb3RvW2tleV0gPSBvdXQ7XG4gIH1cbn07XG5nbG9iYWwuY29yZSA9IGNvcmU7XG4vLyB0eXBlIGJpdG1hcFxuJGV4cG9ydC5GID0gMTsgICAvLyBmb3JjZWRcbiRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsXG4kZXhwb3J0LlMgPSA0OyAgIC8vIHN0YXRpY1xuJGV4cG9ydC5QID0gODsgICAvLyBwcm90b1xuJGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kXG4kZXhwb3J0LlcgPSAzMjsgIC8vIHdyYXBcbiRleHBvcnQuVSA9IDY0OyAgLy8gc2FmZVxuJGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgIFxubW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0OyIsInZhciBNQVRDSCA9IHJlcXVpcmUoJy4vX3drcycpKCdtYXRjaCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihLRVkpe1xuICB2YXIgcmUgPSAvLi87XG4gIHRyeSB7XG4gICAgJy8uLydbS0VZXShyZSk7XG4gIH0gY2F0Y2goZSl7XG4gICAgdHJ5IHtcbiAgICAgIHJlW01BVENIXSA9IGZhbHNlO1xuICAgICAgcmV0dXJuICEnLy4vJ1tLRVldKHJlKTtcbiAgICB9IGNhdGNoKGYpeyAvKiBlbXB0eSAqLyB9XG4gIH0gcmV0dXJuIHRydWU7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZXhlYyl7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciBoaWRlICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKVxuICAsIGZhaWxzICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIGRlZmluZWQgID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpXG4gICwgd2tzICAgICAgPSByZXF1aXJlKCcuL193a3MnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihLRVksIGxlbmd0aCwgZXhlYyl7XG4gIHZhciBTWU1CT0wgICA9IHdrcyhLRVkpXG4gICAgLCBmbnMgICAgICA9IGV4ZWMoZGVmaW5lZCwgU1lNQk9MLCAnJ1tLRVldKVxuICAgICwgc3RyZm4gICAgPSBmbnNbMF1cbiAgICAsIHJ4Zm4gICAgID0gZm5zWzFdO1xuICBpZihmYWlscyhmdW5jdGlvbigpe1xuICAgIHZhciBPID0ge307XG4gICAgT1tTWU1CT0xdID0gZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH07XG4gICAgcmV0dXJuICcnW0tFWV0oTykgIT0gNztcbiAgfSkpe1xuICAgIHJlZGVmaW5lKFN0cmluZy5wcm90b3R5cGUsIEtFWSwgc3RyZm4pO1xuICAgIGhpZGUoUmVnRXhwLnByb3RvdHlwZSwgU1lNQk9MLCBsZW5ndGggPT0gMlxuICAgICAgLy8gMjEuMi41LjggUmVnRXhwLnByb3RvdHlwZVtAQHJlcGxhY2VdKHN0cmluZywgcmVwbGFjZVZhbHVlKVxuICAgICAgLy8gMjEuMi41LjExIFJlZ0V4cC5wcm90b3R5cGVbQEBzcGxpdF0oc3RyaW5nLCBsaW1pdClcbiAgICAgID8gZnVuY3Rpb24oc3RyaW5nLCBhcmcpeyByZXR1cm4gcnhmbi5jYWxsKHN0cmluZywgdGhpcywgYXJnKTsgfVxuICAgICAgLy8gMjEuMi41LjYgUmVnRXhwLnByb3RvdHlwZVtAQG1hdGNoXShzdHJpbmcpXG4gICAgICAvLyAyMS4yLjUuOSBSZWdFeHAucHJvdG90eXBlW0BAc2VhcmNoXShzdHJpbmcpXG4gICAgICA6IGZ1bmN0aW9uKHN0cmluZyl7IHJldHVybiByeGZuLmNhbGwoc3RyaW5nLCB0aGlzKTsgfVxuICAgICk7XG4gIH1cbn07IiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjEuMi41LjMgZ2V0IFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3NcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpe1xuICB2YXIgdGhhdCAgID0gYW5PYmplY3QodGhpcylcbiAgICAsIHJlc3VsdCA9ICcnO1xuICBpZih0aGF0Lmdsb2JhbCkgICAgIHJlc3VsdCArPSAnZyc7XG4gIGlmKHRoYXQuaWdub3JlQ2FzZSkgcmVzdWx0ICs9ICdpJztcbiAgaWYodGhhdC5tdWx0aWxpbmUpICByZXN1bHQgKz0gJ20nO1xuICBpZih0aGF0LnVuaWNvZGUpICAgIHJlc3VsdCArPSAndSc7XG4gIGlmKHRoYXQuc3RpY2t5KSAgICAgcmVzdWx0ICs9ICd5JztcbiAgcmV0dXJuIHJlc3VsdDtcbn07IiwidmFyIGN0eCAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBjYWxsICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXItY2FsbCcpXG4gICwgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJylcbiAgLCBhbk9iamVjdCAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgdG9MZW5ndGggICAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGdldEl0ZXJGbiAgID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKVxuICAsIEJSRUFLICAgICAgID0ge31cbiAgLCBSRVRVUk4gICAgICA9IHt9O1xudmFyIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0ZXJhYmxlLCBlbnRyaWVzLCBmbiwgdGhhdCwgSVRFUkFUT1Ipe1xuICB2YXIgaXRlckZuID0gSVRFUkFUT1IgPyBmdW5jdGlvbigpeyByZXR1cm4gaXRlcmFibGU7IH0gOiBnZXRJdGVyRm4oaXRlcmFibGUpXG4gICAgLCBmICAgICAgPSBjdHgoZm4sIHRoYXQsIGVudHJpZXMgPyAyIDogMSlcbiAgICAsIGluZGV4ICA9IDBcbiAgICAsIGxlbmd0aCwgc3RlcCwgaXRlcmF0b3IsIHJlc3VsdDtcbiAgaWYodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKXRocm93IFR5cGVFcnJvcihpdGVyYWJsZSArICcgaXMgbm90IGl0ZXJhYmxlIScpO1xuICAvLyBmYXN0IGNhc2UgZm9yIGFycmF5cyB3aXRoIGRlZmF1bHQgaXRlcmF0b3JcbiAgaWYoaXNBcnJheUl0ZXIoaXRlckZuKSlmb3IobGVuZ3RoID0gdG9MZW5ndGgoaXRlcmFibGUubGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4Kyspe1xuICAgIHJlc3VsdCA9IGVudHJpZXMgPyBmKGFuT2JqZWN0KHN0ZXAgPSBpdGVyYWJsZVtpbmRleF0pWzBdLCBzdGVwWzFdKSA6IGYoaXRlcmFibGVbaW5kZXhdKTtcbiAgICBpZihyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKXJldHVybiByZXN1bHQ7XG4gIH0gZWxzZSBmb3IoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChpdGVyYWJsZSk7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgKXtcbiAgICByZXN1bHQgPSBjYWxsKGl0ZXJhdG9yLCBmLCBzdGVwLnZhbHVlLCBlbnRyaWVzKTtcbiAgICBpZihyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKXJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5leHBvcnRzLkJSRUFLICA9IEJSRUFLO1xuZXhwb3J0cy5SRVRVUk4gPSBSRVRVUk47IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZiA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZih0eXBlb2YgX19nID09ICdudW1iZXInKV9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZiIsInZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwga2V5KXtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59OyIsInZhciBkUCAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgcmV0dXJuIGRQLmYob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDsiLCJtb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdkaXYnKSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gNzsgfX0pLmEgIT0gNztcbn0pOyIsInZhciBpc09iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19zZXQtcHJvdG8nKS5zZXQ7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRoYXQsIHRhcmdldCwgQyl7XG4gIHZhciBQLCBTID0gdGFyZ2V0LmNvbnN0cnVjdG9yO1xuICBpZihTICE9PSBDICYmIHR5cGVvZiBTID09ICdmdW5jdGlvbicgJiYgKFAgPSBTLnByb3RvdHlwZSkgIT09IEMucHJvdG90eXBlICYmIGlzT2JqZWN0KFApICYmIHNldFByb3RvdHlwZU9mKXtcbiAgICBzZXRQcm90b3R5cGVPZih0aGF0LCBQKTtcbiAgfSByZXR1cm4gdGhhdDtcbn07IiwiLy8gZmFzdCBhcHBseSwgaHR0cDovL2pzcGVyZi5sbmtpdC5jb20vZmFzdC1hcHBseS81XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCBhcmdzLCB0aGF0KXtcbiAgdmFyIHVuID0gdGhhdCA9PT0gdW5kZWZpbmVkO1xuICBzd2l0Y2goYXJncy5sZW5ndGgpe1xuICAgIGNhc2UgMDogcmV0dXJuIHVuID8gZm4oKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0KTtcbiAgICBjYXNlIDE6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICBjYXNlIDQ6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICB9IHJldHVybiAgICAgICAgICAgICAgZm4uYXBwbHkodGhhdCwgYXJncyk7XG59OyIsIi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApID8gT2JqZWN0IDogZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gY29mKGl0KSA9PSAnU3RyaW5nJyA/IGl0LnNwbGl0KCcnKSA6IE9iamVjdChpdCk7XG59OyIsIi8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3JcbnZhciBJdGVyYXRvcnMgID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJylcbiAgLCBJVEVSQVRPUiAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0ICE9PSB1bmRlZmluZWQgJiYgKEl0ZXJhdG9ycy5BcnJheSA9PT0gaXQgfHwgQXJyYXlQcm90b1tJVEVSQVRPUl0gPT09IGl0KTtcbn07IiwiLy8gNy4yLjIgSXNBcnJheShhcmd1bWVudClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZyl7XG4gIHJldHVybiBjb2YoYXJnKSA9PSAnQXJyYXknO1xufTsiLCIvLyAyMC4xLjIuMyBOdW1iZXIuaXNJbnRlZ2VyKG51bWJlcilcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgZmxvb3IgICAgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0ludGVnZXIoaXQpe1xuICByZXR1cm4gIWlzT2JqZWN0KGl0KSAmJiBpc0Zpbml0ZShpdCkgJiYgZmxvb3IoaXQpID09PSBpdDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59OyIsIi8vIDcuMi44IElzUmVnRXhwKGFyZ3VtZW50KVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBjb2YgICAgICA9IHJlcXVpcmUoJy4vX2NvZicpXG4gICwgTUFUQ0ggICAgPSByZXF1aXJlKCcuL193a3MnKSgnbWF0Y2gnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgaXNSZWdFeHA7XG4gIHJldHVybiBpc09iamVjdChpdCkgJiYgKChpc1JlZ0V4cCA9IGl0W01BVENIXSkgIT09IHVuZGVmaW5lZCA/ICEhaXNSZWdFeHAgOiBjb2YoaXQpID09ICdSZWdFeHAnKTtcbn07IiwiLy8gY2FsbCBzb21ldGhpbmcgb24gaXRlcmF0b3Igc3RlcCB3aXRoIHNhZmUgY2xvc2luZyBvbiBlcnJvclxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0ZXJhdG9yLCBmbiwgdmFsdWUsIGVudHJpZXMpe1xuICB0cnkge1xuICAgIHJldHVybiBlbnRyaWVzID8gZm4oYW5PYmplY3QodmFsdWUpWzBdLCB2YWx1ZVsxXSkgOiBmbih2YWx1ZSk7XG4gIC8vIDcuNC42IEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsIGNvbXBsZXRpb24pXG4gIH0gY2F0Y2goZSl7XG4gICAgdmFyIHJldCA9IGl0ZXJhdG9yWydyZXR1cm4nXTtcbiAgICBpZihyZXQgIT09IHVuZGVmaW5lZClhbk9iamVjdChyZXQuY2FsbChpdGVyYXRvcikpO1xuICAgIHRocm93IGU7XG4gIH1cbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNyZWF0ZSAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpXG4gICwgZGVzY3JpcHRvciAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuXG4vLyAyNS4xLjIuMS4xICVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faGlkZScpKEl0ZXJhdG9yUHJvdG90eXBlLCByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKSwgZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KXtcbiAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7bmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KX0pO1xuICBzZXRUb1N0cmluZ1RhZyhDb25zdHJ1Y3RvciwgTkFNRSArICcgSXRlcmF0b3InKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgICAgICAgID0gcmVxdWlyZSgnLi9fbGlicmFyeScpXG4gICwgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHJlZGVmaW5lICAgICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKVxuICAsIGhpZGUgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIEl0ZXJhdG9ycyAgICAgID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJylcbiAgLCAkaXRlckNyZWF0ZSAgICA9IHJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIElURVJBVE9SICAgICAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBCVUdHWSAgICAgICAgICA9ICEoW10ua2V5cyAmJiAnbmV4dCcgaW4gW10ua2V5cygpKSAvLyBTYWZhcmkgaGFzIGJ1Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgXG4gICwgRkZfSVRFUkFUT1IgICAgPSAnQEBpdGVyYXRvcidcbiAgLCBLRVlTICAgICAgICAgICA9ICdrZXlzJ1xuICAsIFZBTFVFUyAgICAgICAgID0gJ3ZhbHVlcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQmFzZSwgTkFNRSwgQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKXtcbiAgJGl0ZXJDcmVhdGUoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xuICB2YXIgZ2V0TWV0aG9kID0gZnVuY3Rpb24oa2luZCl7XG4gICAgaWYoIUJVR0dZICYmIGtpbmQgaW4gcHJvdG8pcmV0dXJuIHByb3RvW2tpbmRdO1xuICAgIHN3aXRjaChraW5kKXtcbiAgICAgIGNhc2UgS0VZUzogcmV0dXJuIGZ1bmN0aW9uIGtleXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgfSByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICB9O1xuICB2YXIgVEFHICAgICAgICA9IE5BTUUgKyAnIEl0ZXJhdG9yJ1xuICAgICwgREVGX1ZBTFVFUyA9IERFRkFVTFQgPT0gVkFMVUVTXG4gICAgLCBWQUxVRVNfQlVHID0gZmFsc2VcbiAgICAsIHByb3RvICAgICAgPSBCYXNlLnByb3RvdHlwZVxuICAgICwgJG5hdGl2ZSAgICA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXVxuICAgICwgJGRlZmF1bHQgICA9ICRuYXRpdmUgfHwgZ2V0TWV0aG9kKERFRkFVTFQpXG4gICAgLCAkZW50cmllcyAgID0gREVGQVVMVCA/ICFERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoJ2VudHJpZXMnKSA6IHVuZGVmaW5lZFxuICAgICwgJGFueU5hdGl2ZSA9IE5BTUUgPT0gJ0FycmF5JyA/IHByb3RvLmVudHJpZXMgfHwgJG5hdGl2ZSA6ICRuYXRpdmVcbiAgICAsIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYoJGFueU5hdGl2ZSl7XG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZigkYW55TmF0aXZlLmNhbGwobmV3IEJhc2UpKTtcbiAgICBpZihJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSl7XG4gICAgICAvLyBTZXQgQEB0b1N0cmluZ1RhZyB0byBuYXRpdmUgaXRlcmF0b3JzXG4gICAgICBzZXRUb1N0cmluZ1RhZyhJdGVyYXRvclByb3RvdHlwZSwgVEFHLCB0cnVlKTtcbiAgICAgIC8vIGZpeCBmb3Igc29tZSBvbGQgZW5naW5lc1xuICAgICAgaWYoIUxJQlJBUlkgJiYgIWhhcyhJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IpKWhpZGUoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbiAgICB9XG4gIH1cbiAgLy8gZml4IEFycmF5I3t2YWx1ZXMsIEBAaXRlcmF0b3J9Lm5hbWUgaW4gVjggLyBGRlxuICBpZihERUZfVkFMVUVTICYmICRuYXRpdmUgJiYgJG5hdGl2ZS5uYW1lICE9PSBWQUxVRVMpe1xuICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCl7IHJldHVybiAkbmF0aXZlLmNhbGwodGhpcyk7IH07XG4gIH1cbiAgLy8gRGVmaW5lIGl0ZXJhdG9yXG4gIGlmKCghTElCUkFSWSB8fCBGT1JDRUQpICYmIChCVUdHWSB8fCBWQUxVRVNfQlVHIHx8ICFwcm90b1tJVEVSQVRPUl0pKXtcbiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddICA9IHJldHVyblRoaXM7XG4gIGlmKERFRkFVTFQpe1xuICAgIG1ldGhvZHMgPSB7XG4gICAgICB2YWx1ZXM6ICBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6ICAgIElTX1NFVCAgICAgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChLRVlTKSxcbiAgICAgIGVudHJpZXM6ICRlbnRyaWVzXG4gICAgfTtcbiAgICBpZihGT1JDRUQpZm9yKGtleSBpbiBtZXRob2RzKXtcbiAgICAgIGlmKCEoa2V5IGluIHByb3RvKSlyZWRlZmluZShwcm90bywga2V5LCBtZXRob2RzW2tleV0pO1xuICAgIH0gZWxzZSAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChCVUdHWSB8fCBWQUxVRVNfQlVHKSwgTkFNRSwgbWV0aG9kcyk7XG4gIH1cbiAgcmV0dXJuIG1ldGhvZHM7XG59OyIsInZhciBJVEVSQVRPUiAgICAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIFNBRkVfQ0xPU0lORyA9IGZhbHNlO1xuXG50cnkge1xuICB2YXIgcml0ZXIgPSBbN11bSVRFUkFUT1JdKCk7XG4gIHJpdGVyWydyZXR1cm4nXSA9IGZ1bmN0aW9uKCl7IFNBRkVfQ0xPU0lORyA9IHRydWU7IH07XG4gIEFycmF5LmZyb20ocml0ZXIsIGZ1bmN0aW9uKCl7IHRocm93IDI7IH0pO1xufSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV4ZWMsIHNraXBDbG9zaW5nKXtcbiAgaWYoIXNraXBDbG9zaW5nICYmICFTQUZFX0NMT1NJTkcpcmV0dXJuIGZhbHNlO1xuICB2YXIgc2FmZSA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBhcnIgID0gWzddXG4gICAgICAsIGl0ZXIgPSBhcnJbSVRFUkFUT1JdKCk7XG4gICAgaXRlci5uZXh0ID0gZnVuY3Rpb24oKXsgcmV0dXJuIHtkb25lOiBzYWZlID0gdHJ1ZX07IH07XG4gICAgYXJyW0lURVJBVE9SXSA9IGZ1bmN0aW9uKCl7IHJldHVybiBpdGVyOyB9O1xuICAgIGV4ZWMoYXJyKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gc2FmZTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkb25lLCB2YWx1ZSl7XG4gIHJldHVybiB7dmFsdWU6IHZhbHVlLCBkb25lOiAhIWRvbmV9O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHt9OyIsInZhciBnZXRLZXlzICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpXG4gICwgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QsIGVsKXtcbiAgdmFyIE8gICAgICA9IHRvSU9iamVjdChvYmplY3QpXG4gICAgLCBrZXlzICAgPSBnZXRLZXlzKE8pXG4gICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICwgaW5kZXggID0gMFxuICAgICwga2V5O1xuICB3aGlsZShsZW5ndGggPiBpbmRleClpZihPW2tleSA9IGtleXNbaW5kZXgrK11dID09PSBlbClyZXR1cm4ga2V5O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZhbHNlOyIsIi8vIDIwLjIuMi4xNCBNYXRoLmV4cG0xKHgpXG52YXIgJGV4cG0xID0gTWF0aC5leHBtMTtcbm1vZHVsZS5leHBvcnRzID0gKCEkZXhwbTFcbiAgLy8gT2xkIEZGIGJ1Z1xuICB8fCAkZXhwbTEoMTApID4gMjIwMjUuNDY1Nzk0ODA2NzE5IHx8ICRleHBtMSgxMCkgPCAyMjAyNS40NjU3OTQ4MDY3MTY1MTY4XG4gIC8vIFRvciBCcm93c2VyIGJ1Z1xuICB8fCAkZXhwbTEoLTJlLTE3KSAhPSAtMmUtMTdcbikgPyBmdW5jdGlvbiBleHBtMSh4KXtcbiAgcmV0dXJuICh4ID0gK3gpID09IDAgPyB4IDogeCA+IC0xZS02ICYmIHggPCAxZS02ID8geCArIHggKiB4IC8gMiA6IE1hdGguZXhwKHgpIC0gMTtcbn0gOiAkZXhwbTE7IiwiLy8gMjAuMi4yLjIwIE1hdGgubG9nMXAoeClcbm1vZHVsZS5leHBvcnRzID0gTWF0aC5sb2cxcCB8fCBmdW5jdGlvbiBsb2cxcCh4KXtcbiAgcmV0dXJuICh4ID0gK3gpID4gLTFlLTggJiYgeCA8IDFlLTggPyB4IC0geCAqIHggLyAyIDogTWF0aC5sb2coMSArIHgpO1xufTsiLCIvLyAyMC4yLjIuMjggTWF0aC5zaWduKHgpXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGguc2lnbiB8fCBmdW5jdGlvbiBzaWduKHgpe1xuICByZXR1cm4gKHggPSAreCkgPT0gMCB8fCB4ICE9IHggPyB4IDogeCA8IDAgPyAtMSA6IDE7XG59OyIsInZhciBNRVRBICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpKCdtZXRhJylcbiAgLCBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgaGFzICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIHNldERlc2MgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGlkICAgICAgID0gMDtcbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGZ1bmN0aW9uKCl7XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBGUkVFWkUgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpO1xufSk7XG52YXIgc2V0TWV0YSA9IGZ1bmN0aW9uKGl0KXtcbiAgc2V0RGVzYyhpdCwgTUVUQSwge3ZhbHVlOiB7XG4gICAgaTogJ08nICsgKytpZCwgLy8gb2JqZWN0IElEXG4gICAgdzoge30gICAgICAgICAgLy8gd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfX0pO1xufTtcbnZhciBmYXN0S2V5ID0gZnVuY3Rpb24oaXQsIGNyZWF0ZSl7XG4gIC8vIHJldHVybiBwcmltaXRpdmUgd2l0aCBwcmVmaXhcbiAgaWYoIWlzT2JqZWN0KGl0KSlyZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xuICBpZighaGFzKGl0LCBNRVRBKSl7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZighaXNFeHRlbnNpYmxlKGl0KSlyZXR1cm4gJ0YnO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYoIWNyZWF0ZSlyZXR1cm4gJ0UnO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBvYmplY3QgSURcbiAgfSByZXR1cm4gaXRbTUVUQV0uaTtcbn07XG52YXIgZ2V0V2VhayA9IGZ1bmN0aW9uKGl0LCBjcmVhdGUpe1xuICBpZighaGFzKGl0LCBNRVRBKSl7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZighaXNFeHRlbnNpYmxlKGl0KSlyZXR1cm4gdHJ1ZTtcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmKCFjcmVhdGUpcmV0dXJuIGZhbHNlO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBoYXNoIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gcmV0dXJuIGl0W01FVEFdLnc7XG59O1xuLy8gYWRkIG1ldGFkYXRhIG9uIGZyZWV6ZS1mYW1pbHkgbWV0aG9kcyBjYWxsaW5nXG52YXIgb25GcmVlemUgPSBmdW5jdGlvbihpdCl7XG4gIGlmKEZSRUVaRSAmJiBtZXRhLk5FRUQgJiYgaXNFeHRlbnNpYmxlKGl0KSAmJiAhaGFzKGl0LCBNRVRBKSlzZXRNZXRhKGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciBtZXRhID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIEtFWTogICAgICBNRVRBLFxuICBORUVEOiAgICAgZmFsc2UsXG4gIGZhc3RLZXk6ICBmYXN0S2V5LFxuICBnZXRXZWFrOiAgZ2V0V2VhayxcbiAgb25GcmVlemU6IG9uRnJlZXplXG59OyIsInZhciBNYXAgICAgID0gcmVxdWlyZSgnLi9lczYubWFwJylcbiAgLCAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBzaGFyZWQgID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ21ldGFkYXRhJylcbiAgLCBzdG9yZSAgID0gc2hhcmVkLnN0b3JlIHx8IChzaGFyZWQuc3RvcmUgPSBuZXcgKHJlcXVpcmUoJy4vZXM2LndlYWstbWFwJykpKTtcblxudmFyIGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAgPSBmdW5jdGlvbih0YXJnZXQsIHRhcmdldEtleSwgY3JlYXRlKXtcbiAgdmFyIHRhcmdldE1ldGFkYXRhID0gc3RvcmUuZ2V0KHRhcmdldCk7XG4gIGlmKCF0YXJnZXRNZXRhZGF0YSl7XG4gICAgaWYoIWNyZWF0ZSlyZXR1cm4gdW5kZWZpbmVkO1xuICAgIHN0b3JlLnNldCh0YXJnZXQsIHRhcmdldE1ldGFkYXRhID0gbmV3IE1hcCk7XG4gIH1cbiAgdmFyIGtleU1ldGFkYXRhID0gdGFyZ2V0TWV0YWRhdGEuZ2V0KHRhcmdldEtleSk7XG4gIGlmKCFrZXlNZXRhZGF0YSl7XG4gICAgaWYoIWNyZWF0ZSlyZXR1cm4gdW5kZWZpbmVkO1xuICAgIHRhcmdldE1ldGFkYXRhLnNldCh0YXJnZXRLZXksIGtleU1ldGFkYXRhID0gbmV3IE1hcCk7XG4gIH0gcmV0dXJuIGtleU1ldGFkYXRhO1xufTtcbnZhciBvcmRpbmFyeUhhc093bk1ldGFkYXRhID0gZnVuY3Rpb24oTWV0YWRhdGFLZXksIE8sIFApe1xuICB2YXIgbWV0YWRhdGFNYXAgPSBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIGZhbHNlKTtcbiAgcmV0dXJuIG1ldGFkYXRhTWFwID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IG1ldGFkYXRhTWFwLmhhcyhNZXRhZGF0YUtleSk7XG59O1xudmFyIG9yZGluYXJ5R2V0T3duTWV0YWRhdGEgPSBmdW5jdGlvbihNZXRhZGF0YUtleSwgTywgUCl7XG4gIHZhciBtZXRhZGF0YU1hcCA9IGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgZmFsc2UpO1xuICByZXR1cm4gbWV0YWRhdGFNYXAgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG1ldGFkYXRhTWFwLmdldChNZXRhZGF0YUtleSk7XG59O1xudmFyIG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEgPSBmdW5jdGlvbihNZXRhZGF0YUtleSwgTWV0YWRhdGFWYWx1ZSwgTywgUCl7XG4gIGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgdHJ1ZSkuc2V0KE1ldGFkYXRhS2V5LCBNZXRhZGF0YVZhbHVlKTtcbn07XG52YXIgb3JkaW5hcnlPd25NZXRhZGF0YUtleXMgPSBmdW5jdGlvbih0YXJnZXQsIHRhcmdldEtleSl7XG4gIHZhciBtZXRhZGF0YU1hcCA9IGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAodGFyZ2V0LCB0YXJnZXRLZXksIGZhbHNlKVxuICAgICwga2V5cyAgICAgICAgPSBbXTtcbiAgaWYobWV0YWRhdGFNYXApbWV0YWRhdGFNYXAuZm9yRWFjaChmdW5jdGlvbihfLCBrZXkpeyBrZXlzLnB1c2goa2V5KTsgfSk7XG4gIHJldHVybiBrZXlzO1xufTtcbnZhciB0b01ldGFLZXkgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogU3RyaW5nKGl0KTtcbn07XG52YXIgZXhwID0gZnVuY3Rpb24oTyl7XG4gICRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIE8pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHN0b3JlOiBzdG9yZSxcbiAgbWFwOiBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwLFxuICBoYXM6IG9yZGluYXJ5SGFzT3duTWV0YWRhdGEsXG4gIGdldDogb3JkaW5hcnlHZXRPd25NZXRhZGF0YSxcbiAgc2V0OiBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhLFxuICBrZXlzOiBvcmRpbmFyeU93bk1ldGFkYXRhS2V5cyxcbiAga2V5OiB0b01ldGFLZXksXG4gIGV4cDogZXhwXG59OyIsInZhciBnbG9iYWwgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIG1hY3JvdGFzayA9IHJlcXVpcmUoJy4vX3Rhc2snKS5zZXRcbiAgLCBPYnNlcnZlciAgPSBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlclxuICAsIHByb2Nlc3MgICA9IGdsb2JhbC5wcm9jZXNzXG4gICwgUHJvbWlzZSAgID0gZ2xvYmFsLlByb21pc2VcbiAgLCBpc05vZGUgICAgPSByZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKXtcbiAgdmFyIGhlYWQsIGxhc3QsIG5vdGlmeTtcblxuICB2YXIgZmx1c2ggPSBmdW5jdGlvbigpe1xuICAgIHZhciBwYXJlbnQsIGZuO1xuICAgIGlmKGlzTm9kZSAmJiAocGFyZW50ID0gcHJvY2Vzcy5kb21haW4pKXBhcmVudC5leGl0KCk7XG4gICAgd2hpbGUoaGVhZCl7XG4gICAgICBmbiAgID0gaGVhZC5mbjtcbiAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgICB0cnkge1xuICAgICAgICBmbigpO1xuICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgaWYoaGVhZClub3RpZnkoKTtcbiAgICAgICAgZWxzZSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0gbGFzdCA9IHVuZGVmaW5lZDtcbiAgICBpZihwYXJlbnQpcGFyZW50LmVudGVyKCk7XG4gIH07XG5cbiAgLy8gTm9kZS5qc1xuICBpZihpc05vZGUpe1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgICB9O1xuICAvLyBicm93c2VycyB3aXRoIE11dGF0aW9uT2JzZXJ2ZXJcbiAgfSBlbHNlIGlmKE9ic2VydmVyKXtcbiAgICB2YXIgdG9nZ2xlID0gdHJ1ZVxuICAgICAgLCBub2RlICAgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgbmV3IE9ic2VydmVyKGZsdXNoKS5vYnNlcnZlKG5vZGUsIHtjaGFyYWN0ZXJEYXRhOiB0cnVlfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24oKXtcbiAgICAgIG5vZGUuZGF0YSA9IHRvZ2dsZSA9ICF0b2dnbGU7XG4gICAgfTtcbiAgLy8gZW52aXJvbm1lbnRzIHdpdGggbWF5YmUgbm9uLWNvbXBsZXRlbHkgY29ycmVjdCwgYnV0IGV4aXN0ZW50IFByb21pc2VcbiAgfSBlbHNlIGlmKFByb21pc2UgJiYgUHJvbWlzZS5yZXNvbHZlKXtcbiAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgICBwcm9taXNlLnRoZW4oZmx1c2gpO1xuICAgIH07XG4gIC8vIGZvciBvdGhlciBlbnZpcm9ubWVudHMgLSBtYWNyb3Rhc2sgYmFzZWQgb246XG4gIC8vIC0gc2V0SW1tZWRpYXRlXG4gIC8vIC0gTWVzc2FnZUNoYW5uZWxcbiAgLy8gLSB3aW5kb3cucG9zdE1lc3NhZ1xuICAvLyAtIG9ucmVhZHlzdGF0ZWNoYW5nZVxuICAvLyAtIHNldFRpbWVvdXRcbiAgfSBlbHNlIHtcbiAgICBub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgICAgLy8gc3RyYW5nZSBJRSArIHdlYnBhY2sgZGV2IHNlcnZlciBidWcgLSB1c2UgLmNhbGwoZ2xvYmFsKVxuICAgICAgbWFjcm90YXNrLmNhbGwoZ2xvYmFsLCBmbHVzaCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbihmbil7XG4gICAgdmFyIHRhc2sgPSB7Zm46IGZuLCBuZXh0OiB1bmRlZmluZWR9O1xuICAgIGlmKGxhc3QpbGFzdC5uZXh0ID0gdGFzaztcbiAgICBpZighaGVhZCl7XG4gICAgICBoZWFkID0gdGFzaztcbiAgICAgIG5vdGlmeSgpO1xuICAgIH0gbGFzdCA9IHRhc2s7XG4gIH07XG59OyIsIid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMi4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UsIC4uLilcbnZhciBnZXRLZXlzICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCBnT1BTICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJylcbiAgLCBwSUUgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKVxuICAsIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCBJT2JqZWN0ICA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKVxuICAsICRhc3NpZ24gID0gT2JqZWN0LmFzc2lnbjtcblxuLy8gc2hvdWxkIHdvcmsgd2l0aCBzeW1ib2xzIGFuZCBzaG91bGQgaGF2ZSBkZXRlcm1pbmlzdGljIHByb3BlcnR5IG9yZGVyIChWOCBidWcpXG5tb2R1bGUuZXhwb3J0cyA9ICEkYXNzaWduIHx8IHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgdmFyIEEgPSB7fVxuICAgICwgQiA9IHt9XG4gICAgLCBTID0gU3ltYm9sKClcbiAgICAsIEsgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuICBBW1NdID0gNztcbiAgSy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbihrKXsgQltrXSA9IGs7IH0pO1xuICByZXR1cm4gJGFzc2lnbih7fSwgQSlbU10gIT0gNyB8fCBPYmplY3Qua2V5cygkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gSztcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICB2YXIgVCAgICAgPSB0b09iamVjdCh0YXJnZXQpXG4gICAgLCBhTGVuICA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIGluZGV4ID0gMVxuICAgICwgZ2V0U3ltYm9scyA9IGdPUFMuZlxuICAgICwgaXNFbnVtICAgICA9IHBJRS5mO1xuICB3aGlsZShhTGVuID4gaW5kZXgpe1xuICAgIHZhciBTICAgICAgPSBJT2JqZWN0KGFyZ3VtZW50c1tpbmRleCsrXSlcbiAgICAgICwga2V5cyAgID0gZ2V0U3ltYm9scyA/IGdldEtleXMoUykuY29uY2F0KGdldFN5bWJvbHMoUykpIDogZ2V0S2V5cyhTKVxuICAgICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICAgLCBqICAgICAgPSAwXG4gICAgICAsIGtleTtcbiAgICB3aGlsZShsZW5ndGggPiBqKWlmKGlzRW51bS5jYWxsKFMsIGtleSA9IGtleXNbaisrXSkpVFtrZXldID0gU1trZXldO1xuICB9IHJldHVybiBUO1xufSA6ICRhc3NpZ247IiwiLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG52YXIgYW5PYmplY3QgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGRQcyAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwcycpXG4gICwgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJylcbiAgLCBJRV9QUk9UTyAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKVxuICAsIEVtcHR5ICAgICAgID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfVxuICAsIFBST1RPVFlQRSAgID0gJ3Byb3RvdHlwZSc7XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24oKXtcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgdmFyIGlmcmFtZSA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnaWZyYW1lJylcbiAgICAsIGkgICAgICA9IGVudW1CdWdLZXlzLmxlbmd0aFxuICAgICwgbHQgICAgID0gJzwnXG4gICAgLCBndCAgICAgPSAnPidcbiAgICAsIGlmcmFtZURvY3VtZW50O1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgcmVxdWlyZSgnLi9faHRtbCcpLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDonOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNjcmlwdC11cmxcbiAgLy8gY3JlYXRlRGljdCA9IGlmcmFtZS5jb250ZW50V2luZG93Lk9iamVjdDtcbiAgLy8gaHRtbC5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XG4gIGlmcmFtZURvY3VtZW50LndyaXRlKGx0ICsgJ3NjcmlwdCcgKyBndCArICdkb2N1bWVudC5GPU9iamVjdCcgKyBsdCArICcvc2NyaXB0JyArIGd0KTtcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgY3JlYXRlRGljdCA9IGlmcmFtZURvY3VtZW50LkY7XG4gIHdoaWxlKGktLSlkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2ldXTtcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcyl7XG4gIHZhciByZXN1bHQ7XG4gIGlmKE8gIT09IG51bGwpe1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHk7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZFBzKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuIiwidmFyIGFuT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJylcbiAgLCB0b1ByaW1pdGl2ZSAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgZFAgICAgICAgICAgICAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKXtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmKElFOF9ET01fREVGSU5FKXRyeSB7XG4gICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG4gIGlmKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcyl0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpO1xuICBpZigndmFsdWUnIGluIEF0dHJpYnV0ZXMpT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTsiLCJ2YXIgZFAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBnZXRLZXlzICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKXtcbiAgYW5PYmplY3QoTyk7XG4gIHZhciBrZXlzICAgPSBnZXRLZXlzKFByb3BlcnRpZXMpXG4gICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICwgaSA9IDBcbiAgICAsIFA7XG4gIHdoaWxlKGxlbmd0aCA+IGkpZFAuZihPLCBQID0ga2V5c1tpKytdLCBQcm9wZXJ0aWVzW1BdKTtcbiAgcmV0dXJuIE87XG59OyIsIi8vIEZvcmNlZCByZXBsYWNlbWVudCBwcm90b3R5cGUgYWNjZXNzb3JzIG1ldGhvZHNcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fbGlicmFyeScpfHwgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgdmFyIEsgPSBNYXRoLnJhbmRvbSgpO1xuICAvLyBJbiBGRiB0aHJvd3Mgb25seSBkZWZpbmUgbWV0aG9kc1xuICBfX2RlZmluZVNldHRlcl9fLmNhbGwobnVsbCwgSywgZnVuY3Rpb24oKXsgLyogZW1wdHkgKi99KTtcbiAgZGVsZXRlIHJlcXVpcmUoJy4vX2dsb2JhbCcpW0tdO1xufSk7IiwidmFyIHBJRSAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpXG4gICwgY3JlYXRlRGVzYyAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgLCB0b0lPYmplY3QgICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIHRvUHJpbWl0aXZlICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpXG4gICwgZ09QRCAgICAgICAgICAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZ09QRCA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKXtcbiAgTyA9IHRvSU9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBpZihJRThfRE9NX0RFRklORSl0cnkge1xuICAgIHJldHVybiBnT1BEKE8sIFApO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG4gIGlmKGhhcyhPLCBQKSlyZXR1cm4gY3JlYXRlRGVzYyghcElFLmYuY2FsbChPLCBQKSwgT1tQXSk7XG59OyIsIi8vIGZhbGxiYWNrIGZvciBJRTExIGJ1Z2d5IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHdpdGggaWZyYW1lIGFuZCB3aW5kb3dcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCBnT1BOICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmZcbiAgLCB0b1N0cmluZyAgPSB7fS50b1N0cmluZztcblxudmFyIHdpbmRvd05hbWVzID0gdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNcbiAgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3aW5kb3cpIDogW107XG5cbnZhciBnZXRXaW5kb3dOYW1lcyA9IGZ1bmN0aW9uKGl0KXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZ09QTihpdCk7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIHdpbmRvd05hbWVzLnNsaWNlKCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KXtcbiAgcmV0dXJuIHdpbmRvd05hbWVzICYmIHRvU3RyaW5nLmNhbGwoaXQpID09ICdbb2JqZWN0IFdpbmRvd10nID8gZ2V0V2luZG93TmFtZXMoaXQpIDogZ09QTih0b0lPYmplY3QoaXQpKTtcbn07XG4iLCIvLyAxOS4xLjIuNyAvIDE1LjIuMy40IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG52YXIgJGtleXMgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJylcbiAgLCBoaWRkZW5LZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpO1xuXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pe1xuICByZXR1cm4gJGtleXMoTywgaGlkZGVuS2V5cyk7XG59OyIsImV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7IiwiLy8gMTkuMS4yLjkgLyAxNS4yLjMuMiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciBoYXMgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgdG9PYmplY3QgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIElFX1BST1RPICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpXG4gICwgT2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbihPKXtcbiAgTyA9IHRvT2JqZWN0KE8pO1xuICBpZihoYXMoTywgSUVfUFJPVE8pKXJldHVybiBPW0lFX1BST1RPXTtcbiAgaWYodHlwZW9mIE8uY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBPIGluc3RhbmNlb2YgTy5jb25zdHJ1Y3Rvcil7XG4gICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xuICB9IHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG8gOiBudWxsO1xufTsiLCJ2YXIgaGFzICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCB0b0lPYmplY3QgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCBhcnJheUluZGV4T2YgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKVxuICAsIElFX1BST1RPICAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QsIG5hbWVzKXtcbiAgdmFyIE8gICAgICA9IHRvSU9iamVjdChvYmplY3QpXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCByZXN1bHQgPSBbXVxuICAgICwga2V5O1xuICBmb3Ioa2V5IGluIE8paWYoa2V5ICE9IElFX1BST1RPKWhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSlpZihoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpe1xuICAgIH5hcnJheUluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07IiwiLy8gMTkuMS4yLjE0IC8gMTUuMi4zLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgJGtleXMgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpXG4gICwgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKXtcbiAgcmV0dXJuICRrZXlzKE8sIGVudW1CdWdLZXlzKTtcbn07IiwiZXhwb3J0cy5mID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7IiwiLy8gbW9zdCBPYmplY3QgbWV0aG9kcyBieSBFUzYgc2hvdWxkIGFjY2VwdCBwcmltaXRpdmVzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgY29yZSAgICA9IHJlcXVpcmUoJy4vX2NvcmUnKVxuICAsIGZhaWxzICAgPSByZXF1aXJlKCcuL19mYWlscycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihLRVksIGV4ZWMpe1xuICB2YXIgZm4gID0gKGNvcmUuT2JqZWN0IHx8IHt9KVtLRVldIHx8IE9iamVjdFtLRVldXG4gICAgLCBleHAgPSB7fTtcbiAgZXhwW0tFWV0gPSBleGVjKGZuKTtcbiAgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbigpeyBmbigxKTsgfSksICdPYmplY3QnLCBleHApO1xufTsiLCJ2YXIgZ2V0S2V5cyAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKVxuICAsIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIGlzRW51bSAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKS5mO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpc0VudHJpZXMpe1xuICByZXR1cm4gZnVuY3Rpb24oaXQpe1xuICAgIHZhciBPICAgICAgPSB0b0lPYmplY3QoaXQpXG4gICAgICAsIGtleXMgICA9IGdldEtleXMoTylcbiAgICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAgICwgaSAgICAgID0gMFxuICAgICAgLCByZXN1bHQgPSBbXVxuICAgICAgLCBrZXk7XG4gICAgd2hpbGUobGVuZ3RoID4gaSlpZihpc0VudW0uY2FsbChPLCBrZXkgPSBrZXlzW2krK10pKXtcbiAgICAgIHJlc3VsdC5wdXNoKGlzRW50cmllcyA/IFtrZXksIE9ba2V5XV0gOiBPW2tleV0pO1xuICAgIH0gcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn07IiwiLy8gYWxsIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBub24tZW51bWVyYWJsZSBhbmQgc3ltYm9sc1xudmFyIGdPUE4gICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKVxuICAsIGdPUFMgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKVxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBSZWZsZWN0ICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlJlZmxlY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IFJlZmxlY3QgJiYgUmVmbGVjdC5vd25LZXlzIHx8IGZ1bmN0aW9uIG93bktleXMoaXQpe1xuICB2YXIga2V5cyAgICAgICA9IGdPUE4uZihhbk9iamVjdChpdCkpXG4gICAgLCBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICByZXR1cm4gZ2V0U3ltYm9scyA/IGtleXMuY29uY2F0KGdldFN5bWJvbHMoaXQpKSA6IGtleXM7XG59OyIsInZhciAkcGFyc2VGbG9hdCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLnBhcnNlRmxvYXRcbiAgLCAkdHJpbSAgICAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy10cmltJykudHJpbTtcblxubW9kdWxlLmV4cG9ydHMgPSAxIC8gJHBhcnNlRmxvYXQocmVxdWlyZSgnLi9fc3RyaW5nLXdzJykgKyAnLTAnKSAhPT0gLUluZmluaXR5ID8gZnVuY3Rpb24gcGFyc2VGbG9hdChzdHIpe1xuICB2YXIgc3RyaW5nID0gJHRyaW0oU3RyaW5nKHN0ciksIDMpXG4gICAgLCByZXN1bHQgPSAkcGFyc2VGbG9hdChzdHJpbmcpO1xuICByZXR1cm4gcmVzdWx0ID09PSAwICYmIHN0cmluZy5jaGFyQXQoMCkgPT0gJy0nID8gLTAgOiByZXN1bHQ7XG59IDogJHBhcnNlRmxvYXQ7IiwidmFyICRwYXJzZUludCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLnBhcnNlSW50XG4gICwgJHRyaW0gICAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKS50cmltXG4gICwgd3MgICAgICAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLXdzJylcbiAgLCBoZXggICAgICAgPSAvXltcXC0rXT8wW3hYXS87XG5cbm1vZHVsZS5leHBvcnRzID0gJHBhcnNlSW50KHdzICsgJzA4JykgIT09IDggfHwgJHBhcnNlSW50KHdzICsgJzB4MTYnKSAhPT0gMjIgPyBmdW5jdGlvbiBwYXJzZUludChzdHIsIHJhZGl4KXtcbiAgdmFyIHN0cmluZyA9ICR0cmltKFN0cmluZyhzdHIpLCAzKTtcbiAgcmV0dXJuICRwYXJzZUludChzdHJpbmcsIChyYWRpeCA+Pj4gMCkgfHwgKGhleC50ZXN0KHN0cmluZykgPyAxNiA6IDEwKSk7XG59IDogJHBhcnNlSW50OyIsIid1c2Ugc3RyaWN0JztcbnZhciBwYXRoICAgICAgPSByZXF1aXJlKCcuL19wYXRoJylcbiAgLCBpbnZva2UgICAgPSByZXF1aXJlKCcuL19pbnZva2UnKVxuICAsIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oLyogLi4ucGFyZ3MgKi8pe1xuICB2YXIgZm4gICAgID0gYUZ1bmN0aW9uKHRoaXMpXG4gICAgLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBwYXJncyAgPSBBcnJheShsZW5ndGgpXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCBfICAgICAgPSBwYXRoLl9cbiAgICAsIGhvbGRlciA9IGZhbHNlO1xuICB3aGlsZShsZW5ndGggPiBpKWlmKChwYXJnc1tpXSA9IGFyZ3VtZW50c1tpKytdKSA9PT0gXylob2xkZXIgPSB0cnVlO1xuICByZXR1cm4gZnVuY3Rpb24oLyogLi4uYXJncyAqLyl7XG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgICAsIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAsIGogPSAwLCBrID0gMCwgYXJncztcbiAgICBpZighaG9sZGVyICYmICFhTGVuKXJldHVybiBpbnZva2UoZm4sIHBhcmdzLCB0aGF0KTtcbiAgICBhcmdzID0gcGFyZ3Muc2xpY2UoKTtcbiAgICBpZihob2xkZXIpZm9yKDtsZW5ndGggPiBqOyBqKyspaWYoYXJnc1tqXSA9PT0gXylhcmdzW2pdID0gYXJndW1lbnRzW2srK107XG4gICAgd2hpbGUoYUxlbiA+IGspYXJncy5wdXNoKGFyZ3VtZW50c1trKytdKTtcbiAgICByZXR1cm4gaW52b2tlKGZuLCBhcmdzLCB0aGF0KTtcbiAgfTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19nbG9iYWwnKTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGJpdG1hcCwgdmFsdWUpe1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGUgIDogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGUgICAgOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlICAgICAgIDogdmFsdWVcbiAgfTtcbn07IiwidmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odGFyZ2V0LCBzcmMsIHNhZmUpe1xuICBmb3IodmFyIGtleSBpbiBzcmMpcmVkZWZpbmUodGFyZ2V0LCBrZXksIHNyY1trZXldLCBzYWZlKTtcbiAgcmV0dXJuIHRhcmdldDtcbn07IiwidmFyIGdsb2JhbCAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgaGlkZSAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgaGFzICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBTUkMgICAgICAgPSByZXF1aXJlKCcuL191aWQnKSgnc3JjJylcbiAgLCBUT19TVFJJTkcgPSAndG9TdHJpbmcnXG4gICwgJHRvU3RyaW5nID0gRnVuY3Rpb25bVE9fU1RSSU5HXVxuICAsIFRQTCAgICAgICA9ICgnJyArICR0b1N0cmluZykuc3BsaXQoVE9fU1RSSU5HKTtcblxucmVxdWlyZSgnLi9fY29yZScpLmluc3BlY3RTb3VyY2UgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiAkdG9TdHJpbmcuY2FsbChpdCk7XG59O1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihPLCBrZXksIHZhbCwgc2FmZSl7XG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIHZhbCA9PSAnZnVuY3Rpb24nO1xuICBpZihpc0Z1bmN0aW9uKWhhcyh2YWwsICduYW1lJykgfHwgaGlkZSh2YWwsICduYW1lJywga2V5KTtcbiAgaWYoT1trZXldID09PSB2YWwpcmV0dXJuO1xuICBpZihpc0Z1bmN0aW9uKWhhcyh2YWwsIFNSQykgfHwgaGlkZSh2YWwsIFNSQywgT1trZXldID8gJycgKyBPW2tleV0gOiBUUEwuam9pbihTdHJpbmcoa2V5KSkpO1xuICBpZihPID09PSBnbG9iYWwpe1xuICAgIE9ba2V5XSA9IHZhbDtcbiAgfSBlbHNlIHtcbiAgICBpZighc2FmZSl7XG4gICAgICBkZWxldGUgT1trZXldO1xuICAgICAgaGlkZShPLCBrZXksIHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKE9ba2V5XSlPW2tleV0gPSB2YWw7XG4gICAgICBlbHNlIGhpZGUoTywga2V5LCB2YWwpO1xuICAgIH1cbiAgfVxuLy8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXG59KShGdW5jdGlvbi5wcm90b3R5cGUsIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKXtcbiAgcmV0dXJuIHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgJiYgdGhpc1tTUkNdIHx8ICR0b1N0cmluZy5jYWxsKHRoaXMpO1xufSk7IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihyZWdFeHAsIHJlcGxhY2Upe1xuICB2YXIgcmVwbGFjZXIgPSByZXBsYWNlID09PSBPYmplY3QocmVwbGFjZSkgPyBmdW5jdGlvbihwYXJ0KXtcbiAgICByZXR1cm4gcmVwbGFjZVtwYXJ0XTtcbiAgfSA6IHJlcGxhY2U7XG4gIHJldHVybiBmdW5jdGlvbihpdCl7XG4gICAgcmV0dXJuIFN0cmluZyhpdCkucmVwbGFjZShyZWdFeHAsIHJlcGxhY2VyKTtcbiAgfTtcbn07IiwiLy8gNy4yLjkgU2FtZVZhbHVlKHgsIHkpXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5pcyB8fCBmdW5jdGlvbiBpcyh4LCB5KXtcbiAgcmV0dXJuIHggPT09IHkgPyB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geSA6IHggIT0geCAmJiB5ICE9IHk7XG59OyIsIi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBjaGVjayA9IGZ1bmN0aW9uKE8sIHByb3RvKXtcbiAgYW5PYmplY3QoTyk7XG4gIGlmKCFpc09iamVjdChwcm90bykgJiYgcHJvdG8gIT09IG51bGwpdGhyb3cgVHlwZUVycm9yKHByb3RvICsgXCI6IGNhbid0IHNldCBhcyBwcm90b3R5cGUhXCIpO1xufTtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgZnVuY3Rpb24odGVzdCwgYnVnZ3ksIHNldCl7XG4gICAgICB0cnkge1xuICAgICAgICBzZXQgPSByZXF1aXJlKCcuL19jdHgnKShGdW5jdGlvbi5jYWxsLCByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmYoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldCwgMik7XG4gICAgICAgIHNldCh0ZXN0LCBbXSk7XG4gICAgICAgIGJ1Z2d5ID0gISh0ZXN0IGluc3RhbmNlb2YgQXJyYXkpO1xuICAgICAgfSBjYXRjaChlKXsgYnVnZ3kgPSB0cnVlOyB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pe1xuICAgICAgICBjaGVjayhPLCBwcm90byk7XG4gICAgICAgIGlmKGJ1Z2d5KU8uX19wcm90b19fID0gcHJvdG87XG4gICAgICAgIGVsc2Ugc2V0KE8sIHByb3RvKTtcbiAgICAgICAgcmV0dXJuIE87XG4gICAgICB9O1xuICAgIH0oe30sIGZhbHNlKSA6IHVuZGVmaW5lZCksXG4gIGNoZWNrOiBjaGVja1xufTsiLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGRQICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJylcbiAgLCBTUEVDSUVTICAgICA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oS0VZKXtcbiAgdmFyIEMgPSBnbG9iYWxbS0VZXTtcbiAgaWYoREVTQ1JJUFRPUlMgJiYgQyAmJiAhQ1tTUEVDSUVTXSlkUC5mKEMsIFNQRUNJRVMsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfVxuICB9KTtcbn07IiwidmFyIGRlZiA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBoYXMgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCB0YWcsIHN0YXQpe1xuICBpZihpdCAmJiAhaGFzKGl0ID0gc3RhdCA/IGl0IDogaXQucHJvdG90eXBlLCBUQUcpKWRlZihpdCwgVEFHLCB7Y29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogdGFnfSk7XG59OyIsInZhciBzaGFyZWQgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgna2V5cycpXG4gICwgdWlkICAgID0gcmVxdWlyZSgnLi9fdWlkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiBzaGFyZWRba2V5XSB8fCAoc2hhcmVkW2tleV0gPSB1aWQoa2V5KSk7XG59OyIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nXG4gICwgc3RvcmUgID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHt9KTtcbn07IiwiLy8gNy4zLjIwIFNwZWNpZXNDb25zdHJ1Y3RvcihPLCBkZWZhdWx0Q29uc3RydWN0b3IpXG52YXIgYW5PYmplY3QgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCBTUEVDSUVTICAgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihPLCBEKXtcbiAgdmFyIEMgPSBhbk9iamVjdChPKS5jb25zdHJ1Y3RvciwgUztcbiAgcmV0dXJuIEMgPT09IHVuZGVmaW5lZCB8fCAoUyA9IGFuT2JqZWN0KEMpW1NQRUNJRVNdKSA9PSB1bmRlZmluZWQgPyBEIDogYUZ1bmN0aW9uKFMpO1xufTsiLCJ2YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1ldGhvZCwgYXJnKXtcbiAgcmV0dXJuICEhbWV0aG9kICYmIGZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgYXJnID8gbWV0aG9kLmNhbGwobnVsbCwgZnVuY3Rpb24oKXt9LCAxKSA6IG1ldGhvZC5jYWxsKG51bGwpO1xuICB9KTtcbn07IiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIGRlZmluZWQgICA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbi8vIHRydWUgIC0+IFN0cmluZyNhdFxuLy8gZmFsc2UgLT4gU3RyaW5nI2NvZGVQb2ludEF0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFRPX1NUUklORyl7XG4gIHJldHVybiBmdW5jdGlvbih0aGF0LCBwb3Mpe1xuICAgIHZhciBzID0gU3RyaW5nKGRlZmluZWQodGhhdCkpXG4gICAgICAsIGkgPSB0b0ludGVnZXIocG9zKVxuICAgICAgLCBsID0gcy5sZW5ndGhcbiAgICAgICwgYSwgYjtcbiAgICBpZihpIDwgMCB8fCBpID49IGwpcmV0dXJuIFRPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGEgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgcmV0dXJuIGEgPCAweGQ4MDAgfHwgYSA+IDB4ZGJmZiB8fCBpICsgMSA9PT0gbCB8fCAoYiA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGIgPiAweGRmZmZcbiAgICAgID8gVE9fU1RSSU5HID8gcy5jaGFyQXQoaSkgOiBhXG4gICAgICA6IFRPX1NUUklORyA/IHMuc2xpY2UoaSwgaSArIDIpIDogKGEgLSAweGQ4MDAgPDwgMTApICsgKGIgLSAweGRjMDApICsgMHgxMDAwMDtcbiAgfTtcbn07IiwiLy8gaGVscGVyIGZvciBTdHJpbmcje3N0YXJ0c1dpdGgsIGVuZHNXaXRoLCBpbmNsdWRlc31cbnZhciBpc1JlZ0V4cCA9IHJlcXVpcmUoJy4vX2lzLXJlZ2V4cCcpXG4gICwgZGVmaW5lZCAgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odGhhdCwgc2VhcmNoU3RyaW5nLCBOQU1FKXtcbiAgaWYoaXNSZWdFeHAoc2VhcmNoU3RyaW5nKSl0aHJvdyBUeXBlRXJyb3IoJ1N0cmluZyMnICsgTkFNRSArIFwiIGRvZXNuJ3QgYWNjZXB0IHJlZ2V4IVwiKTtcbiAgcmV0dXJuIFN0cmluZyhkZWZpbmVkKHRoYXQpKTtcbn07IiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGZhaWxzICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKVxuICAsIHF1b3QgICAgPSAvXCIvZztcbi8vIEIuMi4zLjIuMSBDcmVhdGVIVE1MKHN0cmluZywgdGFnLCBhdHRyaWJ1dGUsIHZhbHVlKVxudmFyIGNyZWF0ZUhUTUwgPSBmdW5jdGlvbihzdHJpbmcsIHRhZywgYXR0cmlidXRlLCB2YWx1ZSkge1xuICB2YXIgUyAgPSBTdHJpbmcoZGVmaW5lZChzdHJpbmcpKVxuICAgICwgcDEgPSAnPCcgKyB0YWc7XG4gIGlmKGF0dHJpYnV0ZSAhPT0gJycpcDEgKz0gJyAnICsgYXR0cmlidXRlICsgJz1cIicgKyBTdHJpbmcodmFsdWUpLnJlcGxhY2UocXVvdCwgJyZxdW90OycpICsgJ1wiJztcbiAgcmV0dXJuIHAxICsgJz4nICsgUyArICc8LycgKyB0YWcgKyAnPic7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihOQU1FLCBleGVjKXtcbiAgdmFyIE8gPSB7fTtcbiAgT1tOQU1FXSA9IGV4ZWMoY3JlYXRlSFRNTCk7XG4gICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24oKXtcbiAgICB2YXIgdGVzdCA9ICcnW05BTUVdKCdcIicpO1xuICAgIHJldHVybiB0ZXN0ICE9PSB0ZXN0LnRvTG93ZXJDYXNlKCkgfHwgdGVzdC5zcGxpdCgnXCInKS5sZW5ndGggPiAzO1xuICB9KSwgJ1N0cmluZycsIE8pO1xufTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1zdHJpbmctcGFkLXN0YXJ0LWVuZFxudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCByZXBlYXQgICA9IHJlcXVpcmUoJy4vX3N0cmluZy1yZXBlYXQnKVxuICAsIGRlZmluZWQgID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRoYXQsIG1heExlbmd0aCwgZmlsbFN0cmluZywgbGVmdCl7XG4gIHZhciBTICAgICAgICAgICAgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSlcbiAgICAsIHN0cmluZ0xlbmd0aCA9IFMubGVuZ3RoXG4gICAgLCBmaWxsU3RyICAgICAgPSBmaWxsU3RyaW5nID09PSB1bmRlZmluZWQgPyAnICcgOiBTdHJpbmcoZmlsbFN0cmluZylcbiAgICAsIGludE1heExlbmd0aCA9IHRvTGVuZ3RoKG1heExlbmd0aCk7XG4gIGlmKGludE1heExlbmd0aCA8PSBzdHJpbmdMZW5ndGggfHwgZmlsbFN0ciA9PSAnJylyZXR1cm4gUztcbiAgdmFyIGZpbGxMZW4gPSBpbnRNYXhMZW5ndGggLSBzdHJpbmdMZW5ndGhcbiAgICAsIHN0cmluZ0ZpbGxlciA9IHJlcGVhdC5jYWxsKGZpbGxTdHIsIE1hdGguY2VpbChmaWxsTGVuIC8gZmlsbFN0ci5sZW5ndGgpKTtcbiAgaWYoc3RyaW5nRmlsbGVyLmxlbmd0aCA+IGZpbGxMZW4pc3RyaW5nRmlsbGVyID0gc3RyaW5nRmlsbGVyLnNsaWNlKDAsIGZpbGxMZW4pO1xuICByZXR1cm4gbGVmdCA/IHN0cmluZ0ZpbGxlciArIFMgOiBTICsgc3RyaW5nRmlsbGVyO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBkZWZpbmVkICAgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVwZWF0KGNvdW50KXtcbiAgdmFyIHN0ciA9IFN0cmluZyhkZWZpbmVkKHRoaXMpKVxuICAgICwgcmVzID0gJydcbiAgICAsIG4gICA9IHRvSW50ZWdlcihjb3VudCk7XG4gIGlmKG4gPCAwIHx8IG4gPT0gSW5maW5pdHkpdGhyb3cgUmFuZ2VFcnJvcihcIkNvdW50IGNhbid0IGJlIG5lZ2F0aXZlXCIpO1xuICBmb3IoO24gPiAwOyAobiA+Pj49IDEpICYmIChzdHIgKz0gc3RyKSlpZihuICYgMSlyZXMgKz0gc3RyO1xuICByZXR1cm4gcmVzO1xufTsiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKVxuICAsIGZhaWxzICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgc3BhY2VzICA9IHJlcXVpcmUoJy4vX3N0cmluZy13cycpXG4gICwgc3BhY2UgICA9ICdbJyArIHNwYWNlcyArICddJ1xuICAsIG5vbiAgICAgPSAnXFx1MjAwYlxcdTAwODUnXG4gICwgbHRyaW0gICA9IFJlZ0V4cCgnXicgKyBzcGFjZSArIHNwYWNlICsgJyonKVxuICAsIHJ0cmltICAgPSBSZWdFeHAoc3BhY2UgKyBzcGFjZSArICcqJCcpO1xuXG52YXIgZXhwb3J0ZXIgPSBmdW5jdGlvbihLRVksIGV4ZWMsIEFMSUFTKXtcbiAgdmFyIGV4cCAgID0ge307XG4gIHZhciBGT1JDRSA9IGZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuICEhc3BhY2VzW0tFWV0oKSB8fCBub25bS0VZXSgpICE9IG5vbjtcbiAgfSk7XG4gIHZhciBmbiA9IGV4cFtLRVldID0gRk9SQ0UgPyBleGVjKHRyaW0pIDogc3BhY2VzW0tFWV07XG4gIGlmKEFMSUFTKWV4cFtBTElBU10gPSBmbjtcbiAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBGT1JDRSwgJ1N0cmluZycsIGV4cCk7XG59O1xuXG4vLyAxIC0+IFN0cmluZyN0cmltTGVmdFxuLy8gMiAtPiBTdHJpbmcjdHJpbVJpZ2h0XG4vLyAzIC0+IFN0cmluZyN0cmltXG52YXIgdHJpbSA9IGV4cG9ydGVyLnRyaW0gPSBmdW5jdGlvbihzdHJpbmcsIFRZUEUpe1xuICBzdHJpbmcgPSBTdHJpbmcoZGVmaW5lZChzdHJpbmcpKTtcbiAgaWYoVFlQRSAmIDEpc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UobHRyaW0sICcnKTtcbiAgaWYoVFlQRSAmIDIpc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocnRyaW0sICcnKTtcbiAgcmV0dXJuIHN0cmluZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0ZXI7IiwibW9kdWxlLmV4cG9ydHMgPSAnXFx4MDlcXHgwQVxceDBCXFx4MENcXHgwRFxceDIwXFx4QTBcXHUxNjgwXFx1MTgwRVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDMnICtcbiAgJ1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMEFcXHUyMDJGXFx1MjA1RlxcdTMwMDBcXHUyMDI4XFx1MjAyOVxcdUZFRkYnOyIsInZhciBjdHggICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIGludm9rZSAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2ludm9rZScpXG4gICwgaHRtbCAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faHRtbCcpXG4gICwgY2VsICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpXG4gICwgZ2xvYmFsICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBwcm9jZXNzICAgICAgICAgICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIHNldFRhc2sgICAgICAgICAgICA9IGdsb2JhbC5zZXRJbW1lZGlhdGVcbiAgLCBjbGVhclRhc2sgICAgICAgICAgPSBnbG9iYWwuY2xlYXJJbW1lZGlhdGVcbiAgLCBNZXNzYWdlQ2hhbm5lbCAgICAgPSBnbG9iYWwuTWVzc2FnZUNoYW5uZWxcbiAgLCBjb3VudGVyICAgICAgICAgICAgPSAwXG4gICwgcXVldWUgICAgICAgICAgICAgID0ge31cbiAgLCBPTlJFQURZU1RBVEVDSEFOR0UgPSAnb25yZWFkeXN0YXRlY2hhbmdlJ1xuICAsIGRlZmVyLCBjaGFubmVsLCBwb3J0O1xudmFyIHJ1biA9IGZ1bmN0aW9uKCl7XG4gIHZhciBpZCA9ICt0aGlzO1xuICBpZihxdWV1ZS5oYXNPd25Qcm9wZXJ0eShpZCkpe1xuICAgIHZhciBmbiA9IHF1ZXVlW2lkXTtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICAgIGZuKCk7XG4gIH1cbn07XG52YXIgbGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCl7XG4gIHJ1bi5jYWxsKGV2ZW50LmRhdGEpO1xufTtcbi8vIE5vZGUuanMgMC45KyAmIElFMTArIGhhcyBzZXRJbW1lZGlhdGUsIG90aGVyd2lzZTpcbmlmKCFzZXRUYXNrIHx8ICFjbGVhclRhc2spe1xuICBzZXRUYXNrID0gZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGZuKXtcbiAgICB2YXIgYXJncyA9IFtdLCBpID0gMTtcbiAgICB3aGlsZShhcmd1bWVudHMubGVuZ3RoID4gaSlhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgIHF1ZXVlWysrY291bnRlcl0gPSBmdW5jdGlvbigpe1xuICAgICAgaW52b2tlKHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nID8gZm4gOiBGdW5jdGlvbihmbiksIGFyZ3MpO1xuICAgIH07XG4gICAgZGVmZXIoY291bnRlcik7XG4gICAgcmV0dXJuIGNvdW50ZXI7XG4gIH07XG4gIGNsZWFyVGFzayA9IGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGlkKXtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICB9O1xuICAvLyBOb2RlLmpzIDAuOC1cbiAgaWYocmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnKXtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY3R4KHJ1biwgaWQsIDEpKTtcbiAgICB9O1xuICAvLyBCcm93c2VycyB3aXRoIE1lc3NhZ2VDaGFubmVsLCBpbmNsdWRlcyBXZWJXb3JrZXJzXG4gIH0gZWxzZSBpZihNZXNzYWdlQ2hhbm5lbCl7XG4gICAgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbDtcbiAgICBwb3J0ICAgID0gY2hhbm5lbC5wb3J0MjtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpc3RlbmVyO1xuICAgIGRlZmVyID0gY3R4KHBvcnQucG9zdE1lc3NhZ2UsIHBvcnQsIDEpO1xuICAvLyBCcm93c2VycyB3aXRoIHBvc3RNZXNzYWdlLCBza2lwIFdlYldvcmtlcnNcbiAgLy8gSUU4IGhhcyBwb3N0TWVzc2FnZSwgYnV0IGl0J3Mgc3luYyAmIHR5cGVvZiBpdHMgcG9zdE1lc3NhZ2UgaXMgJ29iamVjdCdcbiAgfSBlbHNlIGlmKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyICYmIHR5cGVvZiBwb3N0TWVzc2FnZSA9PSAnZnVuY3Rpb24nICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cyl7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoaWQgKyAnJywgJyonKTtcbiAgICB9O1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIsIGZhbHNlKTtcbiAgLy8gSUU4LVxuICB9IGVsc2UgaWYoT05SRUFEWVNUQVRFQ0hBTkdFIGluIGNlbCgnc2NyaXB0Jykpe1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgaHRtbC5hcHBlbmRDaGlsZChjZWwoJ3NjcmlwdCcpKVtPTlJFQURZU1RBVEVDSEFOR0VdID0gZnVuY3Rpb24oKXtcbiAgICAgICAgaHRtbC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgcnVuLmNhbGwoaWQpO1xuICAgICAgfTtcbiAgICB9O1xuICAvLyBSZXN0IG9sZCBicm93c2Vyc1xuICB9IGVsc2Uge1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgc2V0VGltZW91dChjdHgocnVuLCBpZCwgMSksIDApO1xuICAgIH07XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6ICAgc2V0VGFzayxcbiAgY2xlYXI6IGNsZWFyVGFza1xufTsiLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgbWF4ICAgICAgID0gTWF0aC5tYXhcbiAgLCBtaW4gICAgICAgPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaW5kZXgsIGxlbmd0aCl7XG4gIGluZGV4ID0gdG9JbnRlZ2VyKGluZGV4KTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IG1heChpbmRleCArIGxlbmd0aCwgMCkgOiBtaW4oaW5kZXgsIGxlbmd0aCk7XG59OyIsIi8vIDcuMS40IFRvSW50ZWdlclxudmFyIGNlaWwgID0gTWF0aC5jZWlsXG4gICwgZmxvb3IgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpc05hTihpdCA9ICtpdCkgPyAwIDogKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xufTsiLCIvLyB0byBpbmRleGVkIG9iamVjdCwgdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpXG4gICwgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gSU9iamVjdChkZWZpbmVkKGl0KSk7XG59OyIsIi8vIDcuMS4xNSBUb0xlbmd0aFxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIG1pbiAgICAgICA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdCA+IDAgPyBtaW4odG9JbnRlZ2VyKGl0KSwgMHgxZmZmZmZmZmZmZmZmZikgOiAwOyAvLyBwb3coMiwgNTMpIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59OyIsIi8vIDcuMS4xMyBUb09iamVjdChhcmd1bWVudClcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBPYmplY3QoZGVmaW5lZChpdCkpO1xufTsiLCIvLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2Vcbi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBTKXtcbiAgaWYoIWlzT2JqZWN0KGl0KSlyZXR1cm4gaXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZihTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIGlmKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgaWYoIVMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTsiLCIndXNlIHN0cmljdCc7XG5pZihyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpKXtcbiAgdmFyIExJQlJBUlkgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcbiAgICAsIGdsb2JhbCAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAgICwgZmFpbHMgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgICAsICRleHBvcnQgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAgICwgJHR5cGVkICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3R5cGVkJylcbiAgICAsICRidWZmZXIgICAgICAgICAgICAgPSByZXF1aXJlKCcuL190eXBlZC1idWZmZXInKVxuICAgICwgY3R4ICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICAgLCBhbkluc3RhbmNlICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKVxuICAgICwgcHJvcGVydHlEZXNjICAgICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKVxuICAgICwgaGlkZSAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAgICwgcmVkZWZpbmVBbGwgICAgICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpXG4gICAgLCB0b0ludGVnZXIgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICAgLCB0b0xlbmd0aCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgICAsIHRvSW5kZXggICAgICAgICAgICAgPSByZXF1aXJlKCcuL190by1pbmRleCcpXG4gICAgLCB0b1ByaW1pdGl2ZSAgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgICAsIGhhcyAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAgICwgc2FtZSAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3NhbWUtdmFsdWUnKVxuICAgICwgY2xhc3NvZiAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKVxuICAgICwgaXNPYmplY3QgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICAgLCB0b09iamVjdCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgICAsIGlzQXJyYXlJdGVyICAgICAgICAgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJylcbiAgICAsIGNyZWF0ZSAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJylcbiAgICAsIGdldFByb3RvdHlwZU9mICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgICAsIGdPUE4gICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmZcbiAgICAsIGdldEl0ZXJGbiAgICAgICAgICAgPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpXG4gICAgLCB1aWQgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdWlkJylcbiAgICAsIHdrcyAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL193a3MnKVxuICAgICwgY3JlYXRlQXJyYXlNZXRob2QgICA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKVxuICAgICwgY3JlYXRlQXJyYXlJbmNsdWRlcyA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJylcbiAgICAsIHNwZWNpZXNDb25zdHJ1Y3RvciAgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJylcbiAgICAsIEFycmF5SXRlcmF0b3JzICAgICAgPSByZXF1aXJlKCcuL2VzNi5hcnJheS5pdGVyYXRvcicpXG4gICAgLCBJdGVyYXRvcnMgICAgICAgICAgID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJylcbiAgICAsICRpdGVyRGV0ZWN0ICAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpXG4gICAgLCBzZXRTcGVjaWVzICAgICAgICAgID0gcmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKVxuICAgICwgYXJyYXlGaWxsICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FycmF5LWZpbGwnKVxuICAgICwgYXJyYXlDb3B5V2l0aGluICAgICA9IHJlcXVpcmUoJy4vX2FycmF5LWNvcHktd2l0aGluJylcbiAgICAsICREUCAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAgICwgJEdPUEQgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJylcbiAgICAsIGRQICAgICAgICAgICAgICAgICAgPSAkRFAuZlxuICAgICwgZ09QRCAgICAgICAgICAgICAgICA9ICRHT1BELmZcbiAgICAsIFJhbmdlRXJyb3IgICAgICAgICAgPSBnbG9iYWwuUmFuZ2VFcnJvclxuICAgICwgVHlwZUVycm9yICAgICAgICAgICA9IGdsb2JhbC5UeXBlRXJyb3JcbiAgICAsIFVpbnQ4QXJyYXkgICAgICAgICAgPSBnbG9iYWwuVWludDhBcnJheVxuICAgICwgQVJSQVlfQlVGRkVSICAgICAgICA9ICdBcnJheUJ1ZmZlcidcbiAgICAsIFNIQVJFRF9CVUZGRVIgICAgICAgPSAnU2hhcmVkJyArIEFSUkFZX0JVRkZFUlxuICAgICwgQllURVNfUEVSX0VMRU1FTlQgICA9ICdCWVRFU19QRVJfRUxFTUVOVCdcbiAgICAsIFBST1RPVFlQRSAgICAgICAgICAgPSAncHJvdG90eXBlJ1xuICAgICwgQXJyYXlQcm90byAgICAgICAgICA9IEFycmF5W1BST1RPVFlQRV1cbiAgICAsICRBcnJheUJ1ZmZlciAgICAgICAgPSAkYnVmZmVyLkFycmF5QnVmZmVyXG4gICAgLCAkRGF0YVZpZXcgICAgICAgICAgID0gJGJ1ZmZlci5EYXRhVmlld1xuICAgICwgYXJyYXlGb3JFYWNoICAgICAgICA9IGNyZWF0ZUFycmF5TWV0aG9kKDApXG4gICAgLCBhcnJheUZpbHRlciAgICAgICAgID0gY3JlYXRlQXJyYXlNZXRob2QoMilcbiAgICAsIGFycmF5U29tZSAgICAgICAgICAgPSBjcmVhdGVBcnJheU1ldGhvZCgzKVxuICAgICwgYXJyYXlFdmVyeSAgICAgICAgICA9IGNyZWF0ZUFycmF5TWV0aG9kKDQpXG4gICAgLCBhcnJheUZpbmQgICAgICAgICAgID0gY3JlYXRlQXJyYXlNZXRob2QoNSlcbiAgICAsIGFycmF5RmluZEluZGV4ICAgICAgPSBjcmVhdGVBcnJheU1ldGhvZCg2KVxuICAgICwgYXJyYXlJbmNsdWRlcyAgICAgICA9IGNyZWF0ZUFycmF5SW5jbHVkZXModHJ1ZSlcbiAgICAsIGFycmF5SW5kZXhPZiAgICAgICAgPSBjcmVhdGVBcnJheUluY2x1ZGVzKGZhbHNlKVxuICAgICwgYXJyYXlWYWx1ZXMgICAgICAgICA9IEFycmF5SXRlcmF0b3JzLnZhbHVlc1xuICAgICwgYXJyYXlLZXlzICAgICAgICAgICA9IEFycmF5SXRlcmF0b3JzLmtleXNcbiAgICAsIGFycmF5RW50cmllcyAgICAgICAgPSBBcnJheUl0ZXJhdG9ycy5lbnRyaWVzXG4gICAgLCBhcnJheUxhc3RJbmRleE9mICAgID0gQXJyYXlQcm90by5sYXN0SW5kZXhPZlxuICAgICwgYXJyYXlSZWR1Y2UgICAgICAgICA9IEFycmF5UHJvdG8ucmVkdWNlXG4gICAgLCBhcnJheVJlZHVjZVJpZ2h0ICAgID0gQXJyYXlQcm90by5yZWR1Y2VSaWdodFxuICAgICwgYXJyYXlKb2luICAgICAgICAgICA9IEFycmF5UHJvdG8uam9pblxuICAgICwgYXJyYXlTb3J0ICAgICAgICAgICA9IEFycmF5UHJvdG8uc29ydFxuICAgICwgYXJyYXlTbGljZSAgICAgICAgICA9IEFycmF5UHJvdG8uc2xpY2VcbiAgICAsIGFycmF5VG9TdHJpbmcgICAgICAgPSBBcnJheVByb3RvLnRvU3RyaW5nXG4gICAgLCBhcnJheVRvTG9jYWxlU3RyaW5nID0gQXJyYXlQcm90by50b0xvY2FsZVN0cmluZ1xuICAgICwgSVRFUkFUT1IgICAgICAgICAgICA9IHdrcygnaXRlcmF0b3InKVxuICAgICwgVEFHICAgICAgICAgICAgICAgICA9IHdrcygndG9TdHJpbmdUYWcnKVxuICAgICwgVFlQRURfQ09OU1RSVUNUT1IgICA9IHVpZCgndHlwZWRfY29uc3RydWN0b3InKVxuICAgICwgREVGX0NPTlNUUlVDVE9SICAgICA9IHVpZCgnZGVmX2NvbnN0cnVjdG9yJylcbiAgICAsIEFMTF9DT05TVFJVQ1RPUlMgICAgPSAkdHlwZWQuQ09OU1RSXG4gICAgLCBUWVBFRF9BUlJBWSAgICAgICAgID0gJHR5cGVkLlRZUEVEXG4gICAgLCBWSUVXICAgICAgICAgICAgICAgID0gJHR5cGVkLlZJRVdcbiAgICAsIFdST05HX0xFTkdUSCAgICAgICAgPSAnV3JvbmcgbGVuZ3RoISc7XG5cbiAgdmFyICRtYXAgPSBjcmVhdGVBcnJheU1ldGhvZCgxLCBmdW5jdGlvbihPLCBsZW5ndGgpe1xuICAgIHJldHVybiBhbGxvY2F0ZShzcGVjaWVzQ29uc3RydWN0b3IoTywgT1tERUZfQ09OU1RSVUNUT1JdKSwgbGVuZ3RoKTtcbiAgfSk7XG5cbiAgdmFyIExJVFRMRV9FTkRJQU4gPSBmYWlscyhmdW5jdGlvbigpe1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVWludDE2QXJyYXkoWzFdKS5idWZmZXIpWzBdID09PSAxO1xuICB9KTtcblxuICB2YXIgRk9SQ0VEX1NFVCA9ICEhVWludDhBcnJheSAmJiAhIVVpbnQ4QXJyYXlbUFJPVE9UWVBFXS5zZXQgJiYgZmFpbHMoZnVuY3Rpb24oKXtcbiAgICBuZXcgVWludDhBcnJheSgxKS5zZXQoe30pO1xuICB9KTtcblxuICB2YXIgc3RyaWN0VG9MZW5ndGggPSBmdW5jdGlvbihpdCwgU0FNRSl7XG4gICAgaWYoaXQgPT09IHVuZGVmaW5lZCl0aHJvdyBUeXBlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICB2YXIgbnVtYmVyID0gK2l0XG4gICAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKGl0KTtcbiAgICBpZihTQU1FICYmICFzYW1lKG51bWJlciwgbGVuZ3RoKSl0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgcmV0dXJuIGxlbmd0aDtcbiAgfTtcblxuICB2YXIgdG9PZmZzZXQgPSBmdW5jdGlvbihpdCwgQllURVMpe1xuICAgIHZhciBvZmZzZXQgPSB0b0ludGVnZXIoaXQpO1xuICAgIGlmKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICUgQllURVMpdGhyb3cgUmFuZ2VFcnJvcignV3Jvbmcgb2Zmc2V0IScpO1xuICAgIHJldHVybiBvZmZzZXQ7XG4gIH07XG5cbiAgdmFyIHZhbGlkYXRlID0gZnVuY3Rpb24oaXQpe1xuICAgIGlmKGlzT2JqZWN0KGl0KSAmJiBUWVBFRF9BUlJBWSBpbiBpdClyZXR1cm4gaXQ7XG4gICAgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSB0eXBlZCBhcnJheSEnKTtcbiAgfTtcblxuICB2YXIgYWxsb2NhdGUgPSBmdW5jdGlvbihDLCBsZW5ndGgpe1xuICAgIGlmKCEoaXNPYmplY3QoQykgJiYgVFlQRURfQ09OU1RSVUNUT1IgaW4gQykpe1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdJdCBpcyBub3QgYSB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvciEnKTtcbiAgICB9IHJldHVybiBuZXcgQyhsZW5ndGgpO1xuICB9O1xuXG4gIHZhciBzcGVjaWVzRnJvbUxpc3QgPSBmdW5jdGlvbihPLCBsaXN0KXtcbiAgICByZXR1cm4gZnJvbUxpc3Qoc3BlY2llc0NvbnN0cnVjdG9yKE8sIE9bREVGX0NPTlNUUlVDVE9SXSksIGxpc3QpO1xuICB9O1xuXG4gIHZhciBmcm9tTGlzdCA9IGZ1bmN0aW9uKEMsIGxpc3Qpe1xuICAgIHZhciBpbmRleCAgPSAwXG4gICAgICAsIGxlbmd0aCA9IGxpc3QubGVuZ3RoXG4gICAgICAsIHJlc3VsdCA9IGFsbG9jYXRlKEMsIGxlbmd0aCk7XG4gICAgd2hpbGUobGVuZ3RoID4gaW5kZXgpcmVzdWx0W2luZGV4XSA9IGxpc3RbaW5kZXgrK107XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICB2YXIgYWRkR2V0dGVyID0gZnVuY3Rpb24oaXQsIGtleSwgaW50ZXJuYWwpe1xuICAgIGRQKGl0LCBrZXksIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLl9kW2ludGVybmFsXTsgfX0pO1xuICB9O1xuXG4gIHZhciAkZnJvbSA9IGZ1bmN0aW9uIGZyb20oc291cmNlIC8qLCBtYXBmbiwgdGhpc0FyZyAqLyl7XG4gICAgdmFyIE8gICAgICAgPSB0b09iamVjdChzb3VyY2UpXG4gICAgICAsIGFMZW4gICAgPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAsIG1hcGZuICAgPSBhTGVuID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZFxuICAgICAgLCBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZFxuICAgICAgLCBpdGVyRm4gID0gZ2V0SXRlckZuKE8pXG4gICAgICAsIGksIGxlbmd0aCwgdmFsdWVzLCByZXN1bHQsIHN0ZXAsIGl0ZXJhdG9yO1xuICAgIGlmKGl0ZXJGbiAhPSB1bmRlZmluZWQgJiYgIWlzQXJyYXlJdGVyKGl0ZXJGbikpe1xuICAgICAgZm9yKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoTyksIHZhbHVlcyA9IFtdLCBpID0gMDsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpKyspe1xuICAgICAgICB2YWx1ZXMucHVzaChzdGVwLnZhbHVlKTtcbiAgICAgIH0gTyA9IHZhbHVlcztcbiAgICB9XG4gICAgaWYobWFwcGluZyAmJiBhTGVuID4gMiltYXBmbiA9IGN0eChtYXBmbiwgYXJndW1lbnRzWzJdLCAyKTtcbiAgICBmb3IoaSA9IDAsIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKSwgcmVzdWx0ID0gYWxsb2NhdGUodGhpcywgbGVuZ3RoKTsgbGVuZ3RoID4gaTsgaSsrKXtcbiAgICAgIHJlc3VsdFtpXSA9IG1hcHBpbmcgPyBtYXBmbihPW2ldLCBpKSA6IE9baV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyICRvZiA9IGZ1bmN0aW9uIG9mKC8qLi4uaXRlbXMqLyl7XG4gICAgdmFyIGluZGV4ICA9IDBcbiAgICAgICwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCByZXN1bHQgPSBhbGxvY2F0ZSh0aGlzLCBsZW5ndGgpO1xuICAgIHdoaWxlKGxlbmd0aCA+IGluZGV4KXJlc3VsdFtpbmRleF0gPSBhcmd1bWVudHNbaW5kZXgrK107XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBpT1MgU2FmYXJpIDYueCBmYWlscyBoZXJlXG4gIHZhciBUT19MT0NBTEVfQlVHID0gISFVaW50OEFycmF5ICYmIGZhaWxzKGZ1bmN0aW9uKCl7IGFycmF5VG9Mb2NhbGVTdHJpbmcuY2FsbChuZXcgVWludDhBcnJheSgxKSk7IH0pO1xuXG4gIHZhciAkdG9Mb2NhbGVTdHJpbmcgPSBmdW5jdGlvbiB0b0xvY2FsZVN0cmluZygpe1xuICAgIHJldHVybiBhcnJheVRvTG9jYWxlU3RyaW5nLmFwcGx5KFRPX0xPQ0FMRV9CVUcgPyBhcnJheVNsaWNlLmNhbGwodmFsaWRhdGUodGhpcykpIDogdmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgdmFyIHByb3RvID0ge1xuICAgIGNvcHlXaXRoaW46IGZ1bmN0aW9uIGNvcHlXaXRoaW4odGFyZ2V0LCBzdGFydCAvKiwgZW5kICovKXtcbiAgICAgIHJldHVybiBhcnJheUNvcHlXaXRoaW4uY2FsbCh2YWxpZGF0ZSh0aGlzKSwgdGFyZ2V0LCBzdGFydCwgYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgZXZlcnk6IGZ1bmN0aW9uIGV2ZXJ5KGNhbGxiYWNrZm4gLyosIHRoaXNBcmcgKi8pe1xuICAgICAgcmV0dXJuIGFycmF5RXZlcnkodmFsaWRhdGUodGhpcyksIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGZpbGw6IGZ1bmN0aW9uIGZpbGwodmFsdWUgLyosIHN0YXJ0LCBlbmQgKi8peyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlGaWxsLmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoY2FsbGJhY2tmbiAvKiwgdGhpc0FyZyAqLyl7XG4gICAgICByZXR1cm4gc3BlY2llc0Zyb21MaXN0KHRoaXMsIGFycmF5RmlsdGVyKHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLFxuICAgICAgICBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCkpO1xuICAgIH0sXG4gICAgZmluZDogZnVuY3Rpb24gZmluZChwcmVkaWNhdGUgLyosIHRoaXNBcmcgKi8pe1xuICAgICAgcmV0dXJuIGFycmF5RmluZCh2YWxpZGF0ZSh0aGlzKSwgcHJlZGljYXRlLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBmaW5kSW5kZXg6IGZ1bmN0aW9uIGZpbmRJbmRleChwcmVkaWNhdGUgLyosIHRoaXNBcmcgKi8pe1xuICAgICAgcmV0dXJuIGFycmF5RmluZEluZGV4KHZhbGlkYXRlKHRoaXMpLCBwcmVkaWNhdGUsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiwgdGhpc0FyZyAqLyl7XG4gICAgICBhcnJheUZvckVhY2godmFsaWRhdGUodGhpcyksIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGluZGV4T2Y6IGZ1bmN0aW9uIGluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiwgZnJvbUluZGV4ICovKXtcbiAgICAgIHJldHVybiBhcnJheUluZGV4T2YodmFsaWRhdGUodGhpcyksIHNlYXJjaEVsZW1lbnQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhzZWFyY2hFbGVtZW50IC8qLCBmcm9tSW5kZXggKi8pe1xuICAgICAgcmV0dXJuIGFycmF5SW5jbHVkZXModmFsaWRhdGUodGhpcyksIHNlYXJjaEVsZW1lbnQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGpvaW46IGZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5Sm9pbi5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGxhc3RJbmRleE9mOiBmdW5jdGlvbiBsYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50IC8qLCBmcm9tSW5kZXggKi8peyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlMYXN0SW5kZXhPZi5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIG1hcDogZnVuY3Rpb24gbWFwKG1hcGZuIC8qLCB0aGlzQXJnICovKXtcbiAgICAgIHJldHVybiAkbWFwKHZhbGlkYXRlKHRoaXMpLCBtYXBmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoY2FsbGJhY2tmbiAvKiwgaW5pdGlhbFZhbHVlICovKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5UmVkdWNlLmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgcmVkdWNlUmlnaHQ6IGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGNhbGxiYWNrZm4gLyosIGluaXRpYWxWYWx1ZSAqLyl7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheVJlZHVjZVJpZ2h0LmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgcmV2ZXJzZTogZnVuY3Rpb24gcmV2ZXJzZSgpe1xuICAgICAgdmFyIHRoYXQgICA9IHRoaXNcbiAgICAgICAgLCBsZW5ndGggPSB2YWxpZGF0ZSh0aGF0KS5sZW5ndGhcbiAgICAgICAgLCBtaWRkbGUgPSBNYXRoLmZsb29yKGxlbmd0aCAvIDIpXG4gICAgICAgICwgaW5kZXggID0gMFxuICAgICAgICAsIHZhbHVlO1xuICAgICAgd2hpbGUoaW5kZXggPCBtaWRkbGUpe1xuICAgICAgICB2YWx1ZSAgICAgICAgID0gdGhhdFtpbmRleF07XG4gICAgICAgIHRoYXRbaW5kZXgrK10gPSB0aGF0Wy0tbGVuZ3RoXTtcbiAgICAgICAgdGhhdFtsZW5ndGhdICA9IHZhbHVlO1xuICAgICAgfSByZXR1cm4gdGhhdDtcbiAgICB9LFxuICAgIHNvbWU6IGZ1bmN0aW9uIHNvbWUoY2FsbGJhY2tmbiAvKiwgdGhpc0FyZyAqLyl7XG4gICAgICByZXR1cm4gYXJyYXlTb21lKHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBzb3J0OiBmdW5jdGlvbiBzb3J0KGNvbXBhcmVmbil7XG4gICAgICByZXR1cm4gYXJyYXlTb3J0LmNhbGwodmFsaWRhdGUodGhpcyksIGNvbXBhcmVmbik7XG4gICAgfSxcbiAgICBzdWJhcnJheTogZnVuY3Rpb24gc3ViYXJyYXkoYmVnaW4sIGVuZCl7XG4gICAgICB2YXIgTyAgICAgID0gdmFsaWRhdGUodGhpcylcbiAgICAgICAgLCBsZW5ndGggPSBPLmxlbmd0aFxuICAgICAgICAsICRiZWdpbiA9IHRvSW5kZXgoYmVnaW4sIGxlbmd0aCk7XG4gICAgICByZXR1cm4gbmV3IChzcGVjaWVzQ29uc3RydWN0b3IoTywgT1tERUZfQ09OU1RSVUNUT1JdKSkoXG4gICAgICAgIE8uYnVmZmVyLFxuICAgICAgICBPLmJ5dGVPZmZzZXQgKyAkYmVnaW4gKiBPLkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICB0b0xlbmd0aCgoZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiB0b0luZGV4KGVuZCwgbGVuZ3RoKSkgLSAkYmVnaW4pXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICB2YXIgJHNsaWNlID0gZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCl7XG4gICAgcmV0dXJuIHNwZWNpZXNGcm9tTGlzdCh0aGlzLCBhcnJheVNsaWNlLmNhbGwodmFsaWRhdGUodGhpcyksIHN0YXJ0LCBlbmQpKTtcbiAgfTtcblxuICB2YXIgJHNldCA9IGZ1bmN0aW9uIHNldChhcnJheUxpa2UgLyosIG9mZnNldCAqLyl7XG4gICAgdmFsaWRhdGUodGhpcyk7XG4gICAgdmFyIG9mZnNldCA9IHRvT2Zmc2V0KGFyZ3VtZW50c1sxXSwgMSlcbiAgICAgICwgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICAgICwgc3JjICAgID0gdG9PYmplY3QoYXJyYXlMaWtlKVxuICAgICAgLCBsZW4gICAgPSB0b0xlbmd0aChzcmMubGVuZ3RoKVxuICAgICAgLCBpbmRleCAgPSAwO1xuICAgIGlmKGxlbiArIG9mZnNldCA+IGxlbmd0aCl0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgd2hpbGUoaW5kZXggPCBsZW4pdGhpc1tvZmZzZXQgKyBpbmRleF0gPSBzcmNbaW5kZXgrK107XG4gIH07XG5cbiAgdmFyICRpdGVyYXRvcnMgPSB7XG4gICAgZW50cmllczogZnVuY3Rpb24gZW50cmllcygpe1xuICAgICAgcmV0dXJuIGFycmF5RW50cmllcy5jYWxsKHZhbGlkYXRlKHRoaXMpKTtcbiAgICB9LFxuICAgIGtleXM6IGZ1bmN0aW9uIGtleXMoKXtcbiAgICAgIHJldHVybiBhcnJheUtleXMuY2FsbCh2YWxpZGF0ZSh0aGlzKSk7XG4gICAgfSxcbiAgICB2YWx1ZXM6IGZ1bmN0aW9uIHZhbHVlcygpe1xuICAgICAgcmV0dXJuIGFycmF5VmFsdWVzLmNhbGwodmFsaWRhdGUodGhpcykpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaXNUQUluZGV4ID0gZnVuY3Rpb24odGFyZ2V0LCBrZXkpe1xuICAgIHJldHVybiBpc09iamVjdCh0YXJnZXQpXG4gICAgICAmJiB0YXJnZXRbVFlQRURfQVJSQVldXG4gICAgICAmJiB0eXBlb2Yga2V5ICE9ICdzeW1ib2wnXG4gICAgICAmJiBrZXkgaW4gdGFyZ2V0XG4gICAgICAmJiBTdHJpbmcoK2tleSkgPT0gU3RyaW5nKGtleSk7XG4gIH07XG4gIHZhciAkZ2V0RGVzYyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSl7XG4gICAgcmV0dXJuIGlzVEFJbmRleCh0YXJnZXQsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpXG4gICAgICA/IHByb3BlcnR5RGVzYygyLCB0YXJnZXRba2V5XSlcbiAgICAgIDogZ09QRCh0YXJnZXQsIGtleSk7XG4gIH07XG4gIHZhciAkc2V0RGVzYyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBkZXNjKXtcbiAgICBpZihpc1RBSW5kZXgodGFyZ2V0LCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKVxuICAgICAgJiYgaXNPYmplY3QoZGVzYylcbiAgICAgICYmIGhhcyhkZXNjLCAndmFsdWUnKVxuICAgICAgJiYgIWhhcyhkZXNjLCAnZ2V0JylcbiAgICAgICYmICFoYXMoZGVzYywgJ3NldCcpXG4gICAgICAvLyBUT0RPOiBhZGQgdmFsaWRhdGlvbiBkZXNjcmlwdG9yIHcvbyBjYWxsaW5nIGFjY2Vzc29yc1xuICAgICAgJiYgIWRlc2MuY29uZmlndXJhYmxlXG4gICAgICAmJiAoIWhhcyhkZXNjLCAnd3JpdGFibGUnKSB8fCBkZXNjLndyaXRhYmxlKVxuICAgICAgJiYgKCFoYXMoZGVzYywgJ2VudW1lcmFibGUnKSB8fCBkZXNjLmVudW1lcmFibGUpXG4gICAgKXtcbiAgICAgIHRhcmdldFtrZXldID0gZGVzYy52YWx1ZTtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfSBlbHNlIHJldHVybiBkUCh0YXJnZXQsIGtleSwgZGVzYyk7XG4gIH07XG5cbiAgaWYoIUFMTF9DT05TVFJVQ1RPUlMpe1xuICAgICRHT1BELmYgPSAkZ2V0RGVzYztcbiAgICAkRFAuZiAgID0gJHNldERlc2M7XG4gIH1cblxuICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFBTExfQ09OU1RSVUNUT1JTLCAnT2JqZWN0Jywge1xuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldERlc2MsXG4gICAgZGVmaW5lUHJvcGVydHk6ICAgICAgICAgICAkc2V0RGVzY1xuICB9KTtcblxuICBpZihmYWlscyhmdW5jdGlvbigpeyBhcnJheVRvU3RyaW5nLmNhbGwoe30pOyB9KSl7XG4gICAgYXJyYXlUb1N0cmluZyA9IGFycmF5VG9Mb2NhbGVTdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgICAgcmV0dXJuIGFycmF5Sm9pbi5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIHZhciAkVHlwZWRBcnJheVByb3RvdHlwZSQgPSByZWRlZmluZUFsbCh7fSwgcHJvdG8pO1xuICByZWRlZmluZUFsbCgkVHlwZWRBcnJheVByb3RvdHlwZSQsICRpdGVyYXRvcnMpO1xuICBoaWRlKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgSVRFUkFUT1IsICRpdGVyYXRvcnMudmFsdWVzKTtcbiAgcmVkZWZpbmVBbGwoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCB7XG4gICAgc2xpY2U6ICAgICAgICAgICRzbGljZSxcbiAgICBzZXQ6ICAgICAgICAgICAgJHNldCxcbiAgICBjb25zdHJ1Y3RvcjogICAgZnVuY3Rpb24oKXsgLyogbm9vcCAqLyB9LFxuICAgIHRvU3RyaW5nOiAgICAgICBhcnJheVRvU3RyaW5nLFxuICAgIHRvTG9jYWxlU3RyaW5nOiAkdG9Mb2NhbGVTdHJpbmdcbiAgfSk7XG4gIGFkZEdldHRlcigkVHlwZWRBcnJheVByb3RvdHlwZSQsICdidWZmZXInLCAnYicpO1xuICBhZGRHZXR0ZXIoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAnYnl0ZU9mZnNldCcsICdvJyk7XG4gIGFkZEdldHRlcigkVHlwZWRBcnJheVByb3RvdHlwZSQsICdieXRlTGVuZ3RoJywgJ2wnKTtcbiAgYWRkR2V0dGVyKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJ2xlbmd0aCcsICdlJyk7XG4gIGRQKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgVEFHLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpc1tUWVBFRF9BUlJBWV07IH1cbiAgfSk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihLRVksIEJZVEVTLCB3cmFwcGVyLCBDTEFNUEVEKXtcbiAgICBDTEFNUEVEID0gISFDTEFNUEVEO1xuICAgIHZhciBOQU1FICAgICAgID0gS0VZICsgKENMQU1QRUQgPyAnQ2xhbXBlZCcgOiAnJykgKyAnQXJyYXknXG4gICAgICAsIElTTlRfVUlOVDggPSBOQU1FICE9ICdVaW50OEFycmF5J1xuICAgICAgLCBHRVRURVIgICAgID0gJ2dldCcgKyBLRVlcbiAgICAgICwgU0VUVEVSICAgICA9ICdzZXQnICsgS0VZXG4gICAgICAsIFR5cGVkQXJyYXkgPSBnbG9iYWxbTkFNRV1cbiAgICAgICwgQmFzZSAgICAgICA9IFR5cGVkQXJyYXkgfHwge31cbiAgICAgICwgVEFDICAgICAgICA9IFR5cGVkQXJyYXkgJiYgZ2V0UHJvdG90eXBlT2YoVHlwZWRBcnJheSlcbiAgICAgICwgRk9SQ0VEICAgICA9ICFUeXBlZEFycmF5IHx8ICEkdHlwZWQuQUJWXG4gICAgICAsIE8gICAgICAgICAgPSB7fVxuICAgICAgLCBUeXBlZEFycmF5UHJvdG90eXBlID0gVHlwZWRBcnJheSAmJiBUeXBlZEFycmF5W1BST1RPVFlQRV07XG4gICAgdmFyIGdldHRlciA9IGZ1bmN0aW9uKHRoYXQsIGluZGV4KXtcbiAgICAgIHZhciBkYXRhID0gdGhhdC5fZDtcbiAgICAgIHJldHVybiBkYXRhLnZbR0VUVEVSXShpbmRleCAqIEJZVEVTICsgZGF0YS5vLCBMSVRUTEVfRU5ESUFOKTtcbiAgICB9O1xuICAgIHZhciBzZXR0ZXIgPSBmdW5jdGlvbih0aGF0LCBpbmRleCwgdmFsdWUpe1xuICAgICAgdmFyIGRhdGEgPSB0aGF0Ll9kO1xuICAgICAgaWYoQ0xBTVBFRCl2YWx1ZSA9ICh2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUpKSA8IDAgPyAwIDogdmFsdWUgPiAweGZmID8gMHhmZiA6IHZhbHVlICYgMHhmZjtcbiAgICAgIGRhdGEudltTRVRURVJdKGluZGV4ICogQllURVMgKyBkYXRhLm8sIHZhbHVlLCBMSVRUTEVfRU5ESUFOKTtcbiAgICB9O1xuICAgIHZhciBhZGRFbGVtZW50ID0gZnVuY3Rpb24odGhhdCwgaW5kZXgpe1xuICAgICAgZFAodGhhdCwgaW5kZXgsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpe1xuICAgICAgICAgIHJldHVybiBnZXR0ZXIodGhpcywgaW5kZXgpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgICAgICByZXR1cm4gc2V0dGVyKHRoaXMsIGluZGV4LCB2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH07XG4gICAgaWYoRk9SQ0VEKXtcbiAgICAgIFR5cGVkQXJyYXkgPSB3cmFwcGVyKGZ1bmN0aW9uKHRoYXQsIGRhdGEsICRvZmZzZXQsICRsZW5ndGgpe1xuICAgICAgICBhbkluc3RhbmNlKHRoYXQsIFR5cGVkQXJyYXksIE5BTUUsICdfZCcpO1xuICAgICAgICB2YXIgaW5kZXggID0gMFxuICAgICAgICAgICwgb2Zmc2V0ID0gMFxuICAgICAgICAgICwgYnVmZmVyLCBieXRlTGVuZ3RoLCBsZW5ndGgsIGtsYXNzO1xuICAgICAgICBpZighaXNPYmplY3QoZGF0YSkpe1xuICAgICAgICAgIGxlbmd0aCAgICAgPSBzdHJpY3RUb0xlbmd0aChkYXRhLCB0cnVlKVxuICAgICAgICAgIGJ5dGVMZW5ndGggPSBsZW5ndGggKiBCWVRFUztcbiAgICAgICAgICBidWZmZXIgICAgID0gbmV3ICRBcnJheUJ1ZmZlcihieXRlTGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIGlmKGRhdGEgaW5zdGFuY2VvZiAkQXJyYXlCdWZmZXIgfHwgKGtsYXNzID0gY2xhc3NvZihkYXRhKSkgPT0gQVJSQVlfQlVGRkVSIHx8IGtsYXNzID09IFNIQVJFRF9CVUZGRVIpe1xuICAgICAgICAgIGJ1ZmZlciA9IGRhdGE7XG4gICAgICAgICAgb2Zmc2V0ID0gdG9PZmZzZXQoJG9mZnNldCwgQllURVMpO1xuICAgICAgICAgIHZhciAkbGVuID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICAgIGlmKCRsZW5ndGggPT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICBpZigkbGVuICUgQllURVMpdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgICAgICAgICAgYnl0ZUxlbmd0aCA9ICRsZW4gLSBvZmZzZXQ7XG4gICAgICAgICAgICBpZihieXRlTGVuZ3RoIDwgMCl0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ5dGVMZW5ndGggPSB0b0xlbmd0aCgkbGVuZ3RoKSAqIEJZVEVTO1xuICAgICAgICAgICAgaWYoYnl0ZUxlbmd0aCArIG9mZnNldCA+ICRsZW4pdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZW5ndGggPSBieXRlTGVuZ3RoIC8gQllURVM7XG4gICAgICAgIH0gZWxzZSBpZihUWVBFRF9BUlJBWSBpbiBkYXRhKXtcbiAgICAgICAgICByZXR1cm4gZnJvbUxpc3QoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICRmcm9tLmNhbGwoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaGlkZSh0aGF0LCAnX2QnLCB7XG4gICAgICAgICAgYjogYnVmZmVyLFxuICAgICAgICAgIG86IG9mZnNldCxcbiAgICAgICAgICBsOiBieXRlTGVuZ3RoLFxuICAgICAgICAgIGU6IGxlbmd0aCxcbiAgICAgICAgICB2OiBuZXcgJERhdGFWaWV3KGJ1ZmZlcilcbiAgICAgICAgfSk7XG4gICAgICAgIHdoaWxlKGluZGV4IDwgbGVuZ3RoKWFkZEVsZW1lbnQodGhhdCwgaW5kZXgrKyk7XG4gICAgICB9KTtcbiAgICAgIFR5cGVkQXJyYXlQcm90b3R5cGUgPSBUeXBlZEFycmF5W1BST1RPVFlQRV0gPSBjcmVhdGUoJFR5cGVkQXJyYXlQcm90b3R5cGUkKTtcbiAgICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgJ2NvbnN0cnVjdG9yJywgVHlwZWRBcnJheSk7XG4gICAgfSBlbHNlIGlmKCEkaXRlckRldGVjdChmdW5jdGlvbihpdGVyKXtcbiAgICAgIC8vIFY4IHdvcmtzIHdpdGggaXRlcmF0b3JzLCBidXQgZmFpbHMgaW4gbWFueSBvdGhlciBjYXNlc1xuICAgICAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQ1NTJcbiAgICAgIG5ldyBUeXBlZEFycmF5KG51bGwpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgICAgbmV3IFR5cGVkQXJyYXkoaXRlcik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgfSwgdHJ1ZSkpe1xuICAgICAgVHlwZWRBcnJheSA9IHdyYXBwZXIoZnVuY3Rpb24odGhhdCwgZGF0YSwgJG9mZnNldCwgJGxlbmd0aCl7XG4gICAgICAgIGFuSW5zdGFuY2UodGhhdCwgVHlwZWRBcnJheSwgTkFNRSk7XG4gICAgICAgIHZhciBrbGFzcztcbiAgICAgICAgLy8gYHdzYCBtb2R1bGUgYnVnLCB0ZW1wb3JhcmlseSByZW1vdmUgdmFsaWRhdGlvbiBsZW5ndGggZm9yIFVpbnQ4QXJyYXlcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnNvY2tldHMvd3MvcHVsbC82NDVcbiAgICAgICAgaWYoIWlzT2JqZWN0KGRhdGEpKXJldHVybiBuZXcgQmFzZShzdHJpY3RUb0xlbmd0aChkYXRhLCBJU05UX1VJTlQ4KSk7XG4gICAgICAgIGlmKGRhdGEgaW5zdGFuY2VvZiAkQXJyYXlCdWZmZXIgfHwgKGtsYXNzID0gY2xhc3NvZihkYXRhKSkgPT0gQVJSQVlfQlVGRkVSIHx8IGtsYXNzID09IFNIQVJFRF9CVUZGRVIpe1xuICAgICAgICAgIHJldHVybiAkbGVuZ3RoICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gbmV3IEJhc2UoZGF0YSwgdG9PZmZzZXQoJG9mZnNldCwgQllURVMpLCAkbGVuZ3RoKVxuICAgICAgICAgICAgOiAkb2Zmc2V0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgPyBuZXcgQmFzZShkYXRhLCB0b09mZnNldCgkb2Zmc2V0LCBCWVRFUykpXG4gICAgICAgICAgICAgIDogbmV3IEJhc2UoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYoVFlQRURfQVJSQVkgaW4gZGF0YSlyZXR1cm4gZnJvbUxpc3QoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICAgIHJldHVybiAkZnJvbS5jYWxsKFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgfSk7XG4gICAgICBhcnJheUZvckVhY2goVEFDICE9PSBGdW5jdGlvbi5wcm90b3R5cGUgPyBnT1BOKEJhc2UpLmNvbmNhdChnT1BOKFRBQykpIDogZ09QTihCYXNlKSwgZnVuY3Rpb24oa2V5KXtcbiAgICAgICAgaWYoIShrZXkgaW4gVHlwZWRBcnJheSkpaGlkZShUeXBlZEFycmF5LCBrZXksIEJhc2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICAgIFR5cGVkQXJyYXlbUFJPVE9UWVBFXSA9IFR5cGVkQXJyYXlQcm90b3R5cGU7XG4gICAgICBpZighTElCUkFSWSlUeXBlZEFycmF5UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVHlwZWRBcnJheTtcbiAgICB9XG4gICAgdmFyICRuYXRpdmVJdGVyYXRvciAgID0gVHlwZWRBcnJheVByb3RvdHlwZVtJVEVSQVRPUl1cbiAgICAgICwgQ09SUkVDVF9JVEVSX05BTUUgPSAhISRuYXRpdmVJdGVyYXRvciAmJiAoJG5hdGl2ZUl0ZXJhdG9yLm5hbWUgPT0gJ3ZhbHVlcycgfHwgJG5hdGl2ZUl0ZXJhdG9yLm5hbWUgPT0gdW5kZWZpbmVkKVxuICAgICAgLCAkaXRlcmF0b3IgICAgICAgICA9ICRpdGVyYXRvcnMudmFsdWVzO1xuICAgIGhpZGUoVHlwZWRBcnJheSwgVFlQRURfQ09OU1RSVUNUT1IsIHRydWUpO1xuICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgVFlQRURfQVJSQVksIE5BTUUpO1xuICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgVklFVywgdHJ1ZSk7XG4gICAgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBERUZfQ09OU1RSVUNUT1IsIFR5cGVkQXJyYXkpO1xuXG4gICAgaWYoQ0xBTVBFRCA/IG5ldyBUeXBlZEFycmF5KDEpW1RBR10gIT0gTkFNRSA6ICEoVEFHIGluIFR5cGVkQXJyYXlQcm90b3R5cGUpKXtcbiAgICAgIGRQKFR5cGVkQXJyYXlQcm90b3R5cGUsIFRBRywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiBOQU1FOyB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBPW05BTUVdID0gVHlwZWRBcnJheTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogKFR5cGVkQXJyYXkgIT0gQmFzZSksIE8pO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlMsIE5BTUUsIHtcbiAgICAgIEJZVEVTX1BFUl9FTEVNRU5UOiBCWVRFUyxcbiAgICAgIGZyb206ICRmcm9tLFxuICAgICAgb2Y6ICRvZlxuICAgIH0pO1xuXG4gICAgaWYoIShCWVRFU19QRVJfRUxFTUVOVCBpbiBUeXBlZEFycmF5UHJvdG90eXBlKSloaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIEJZVEVTX1BFUl9FTEVNRU5ULCBCWVRFUyk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCwgTkFNRSwgcHJvdG8pO1xuXG4gICAgc2V0U3BlY2llcyhOQU1FKTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogRk9SQ0VEX1NFVCwgTkFNRSwge3NldDogJHNldH0pO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhQ09SUkVDVF9JVEVSX05BTUUsIE5BTUUsICRpdGVyYXRvcnMpO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoVHlwZWRBcnJheVByb3RvdHlwZS50b1N0cmluZyAhPSBhcnJheVRvU3RyaW5nKSwgTkFNRSwge3RvU3RyaW5nOiBhcnJheVRvU3RyaW5nfSk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgICBuZXcgVHlwZWRBcnJheSgxKS5zbGljZSgpO1xuICAgIH0pLCBOQU1FLCB7c2xpY2U6ICRzbGljZX0pO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoZmFpbHMoZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiBbMSwgMl0udG9Mb2NhbGVTdHJpbmcoKSAhPSBuZXcgVHlwZWRBcnJheShbMSwgMl0pLnRvTG9jYWxlU3RyaW5nKClcbiAgICB9KSB8fCAhZmFpbHMoZnVuY3Rpb24oKXtcbiAgICAgIFR5cGVkQXJyYXlQcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcuY2FsbChbMSwgMl0pO1xuICAgIH0pKSwgTkFNRSwge3RvTG9jYWxlU3RyaW5nOiAkdG9Mb2NhbGVTdHJpbmd9KTtcblxuICAgIEl0ZXJhdG9yc1tOQU1FXSA9IENPUlJFQ1RfSVRFUl9OQU1FID8gJG5hdGl2ZUl0ZXJhdG9yIDogJGl0ZXJhdG9yO1xuICAgIGlmKCFMSUJSQVJZICYmICFDT1JSRUNUX0lURVJfTkFNRSloaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIElURVJBVE9SLCAkaXRlcmF0b3IpO1xuICB9O1xufSBlbHNlIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfTsiLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIERFU0NSSVBUT1JTICAgID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKVxuICAsIExJQlJBUlkgICAgICAgID0gcmVxdWlyZSgnLi9fbGlicmFyeScpXG4gICwgJHR5cGVkICAgICAgICAgPSByZXF1aXJlKCcuL190eXBlZCcpXG4gICwgaGlkZSAgICAgICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCByZWRlZmluZUFsbCAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpXG4gICwgZmFpbHMgICAgICAgICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgYW5JbnN0YW5jZSAgICAgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpXG4gICwgdG9JbnRlZ2VyICAgICAgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCB0b0xlbmd0aCAgICAgICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgZ09QTiAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmZcbiAgLCBkUCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBhcnJheUZpbGwgICAgICA9IHJlcXVpcmUoJy4vX2FycmF5LWZpbGwnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIEFSUkFZX0JVRkZFUiAgID0gJ0FycmF5QnVmZmVyJ1xuICAsIERBVEFfVklFVyAgICAgID0gJ0RhdGFWaWV3J1xuICAsIFBST1RPVFlQRSAgICAgID0gJ3Byb3RvdHlwZSdcbiAgLCBXUk9OR19MRU5HVEggICA9ICdXcm9uZyBsZW5ndGghJ1xuICAsIFdST05HX0lOREVYICAgID0gJ1dyb25nIGluZGV4ISdcbiAgLCAkQXJyYXlCdWZmZXIgICA9IGdsb2JhbFtBUlJBWV9CVUZGRVJdXG4gICwgJERhdGFWaWV3ICAgICAgPSBnbG9iYWxbREFUQV9WSUVXXVxuICAsIE1hdGggICAgICAgICAgID0gZ2xvYmFsLk1hdGhcbiAgLCBSYW5nZUVycm9yICAgICA9IGdsb2JhbC5SYW5nZUVycm9yXG4gICwgSW5maW5pdHkgICAgICAgPSBnbG9iYWwuSW5maW5pdHlcbiAgLCBCYXNlQnVmZmVyICAgICA9ICRBcnJheUJ1ZmZlclxuICAsIGFicyAgICAgICAgICAgID0gTWF0aC5hYnNcbiAgLCBwb3cgICAgICAgICAgICA9IE1hdGgucG93XG4gICwgZmxvb3IgICAgICAgICAgPSBNYXRoLmZsb29yXG4gICwgbG9nICAgICAgICAgICAgPSBNYXRoLmxvZ1xuICAsIExOMiAgICAgICAgICAgID0gTWF0aC5MTjJcbiAgLCBCVUZGRVIgICAgICAgICA9ICdidWZmZXInXG4gICwgQllURV9MRU5HVEggICAgPSAnYnl0ZUxlbmd0aCdcbiAgLCBCWVRFX09GRlNFVCAgICA9ICdieXRlT2Zmc2V0J1xuICAsICRCVUZGRVIgICAgICAgID0gREVTQ1JJUFRPUlMgPyAnX2InIDogQlVGRkVSXG4gICwgJExFTkdUSCAgICAgICAgPSBERVNDUklQVE9SUyA/ICdfbCcgOiBCWVRFX0xFTkdUSFxuICAsICRPRkZTRVQgICAgICAgID0gREVTQ1JJUFRPUlMgPyAnX28nIDogQllURV9PRkZTRVQ7XG5cbi8vIElFRUU3NTQgY29udmVyc2lvbnMgYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9pZWVlNzU0XG52YXIgcGFja0lFRUU3NTQgPSBmdW5jdGlvbih2YWx1ZSwgbUxlbiwgbkJ5dGVzKXtcbiAgdmFyIGJ1ZmZlciA9IEFycmF5KG5CeXRlcylcbiAgICAsIGVMZW4gICA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICAgICwgZU1heCAgID0gKDEgPDwgZUxlbikgLSAxXG4gICAgLCBlQmlhcyAgPSBlTWF4ID4+IDFcbiAgICAsIHJ0ICAgICA9IG1MZW4gPT09IDIzID8gcG93KDIsIC0yNCkgLSBwb3coMiwgLTc3KSA6IDBcbiAgICAsIGkgICAgICA9IDBcbiAgICAsIHMgICAgICA9IHZhbHVlIDwgMCB8fCB2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwID8gMSA6IDBcbiAgICAsIGUsIG0sIGM7XG4gIHZhbHVlID0gYWJzKHZhbHVlKVxuICBpZih2YWx1ZSAhPSB2YWx1ZSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpe1xuICAgIG0gPSB2YWx1ZSAhPSB2YWx1ZSA/IDEgOiAwO1xuICAgIGUgPSBlTWF4O1xuICB9IGVsc2Uge1xuICAgIGUgPSBmbG9vcihsb2codmFsdWUpIC8gTE4yKTtcbiAgICBpZih2YWx1ZSAqIChjID0gcG93KDIsIC1lKSkgPCAxKXtcbiAgICAgIGUtLTtcbiAgICAgIGMgKj0gMjtcbiAgICB9XG4gICAgaWYoZSArIGVCaWFzID49IDEpe1xuICAgICAgdmFsdWUgKz0gcnQgLyBjO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIHBvdygyLCAxIC0gZUJpYXMpO1xuICAgIH1cbiAgICBpZih2YWx1ZSAqIGMgPj0gMil7XG4gICAgICBlKys7XG4gICAgICBjIC89IDI7XG4gICAgfVxuICAgIGlmKGUgKyBlQmlhcyA+PSBlTWF4KXtcbiAgICAgIG0gPSAwO1xuICAgICAgZSA9IGVNYXg7XG4gICAgfSBlbHNlIGlmKGUgKyBlQmlhcyA+PSAxKXtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBwb3coMiwgbUxlbik7XG4gICAgICBlID0gZSArIGVCaWFzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBwb3coMiwgZUJpYXMgLSAxKSAqIHBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSAwO1xuICAgIH1cbiAgfVxuICBmb3IoOyBtTGVuID49IDg7IGJ1ZmZlcltpKytdID0gbSAmIDI1NSwgbSAvPSAyNTYsIG1MZW4gLT0gOCk7XG4gIGUgPSBlIDw8IG1MZW4gfCBtO1xuICBlTGVuICs9IG1MZW47XG4gIGZvcig7IGVMZW4gPiAwOyBidWZmZXJbaSsrXSA9IGUgJiAyNTUsIGUgLz0gMjU2LCBlTGVuIC09IDgpO1xuICBidWZmZXJbLS1pXSB8PSBzICogMTI4O1xuICByZXR1cm4gYnVmZmVyO1xufTtcbnZhciB1bnBhY2tJRUVFNzU0ID0gZnVuY3Rpb24oYnVmZmVyLCBtTGVuLCBuQnl0ZXMpe1xuICB2YXIgZUxlbiAgPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgICAsIGVNYXggID0gKDEgPDwgZUxlbikgLSAxXG4gICAgLCBlQmlhcyA9IGVNYXggPj4gMVxuICAgICwgbkJpdHMgPSBlTGVuIC0gN1xuICAgICwgaSAgICAgPSBuQnl0ZXMgLSAxXG4gICAgLCBzICAgICA9IGJ1ZmZlcltpLS1dXG4gICAgLCBlICAgICA9IHMgJiAxMjdcbiAgICAsIG07XG4gIHMgPj49IDc7XG4gIGZvcig7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbaV0sIGktLSwgbkJpdHMgLT0gOCk7XG4gIG0gPSBlICYgKDEgPDwgLW5CaXRzKSAtIDE7XG4gIGUgPj49IC1uQml0cztcbiAgbkJpdHMgKz0gbUxlbjtcbiAgZm9yKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltpXSwgaS0tLCBuQml0cyAtPSA4KTtcbiAgaWYoZSA9PT0gMCl7XG4gICAgZSA9IDEgLSBlQmlhcztcbiAgfSBlbHNlIGlmKGUgPT09IGVNYXgpe1xuICAgIHJldHVybiBtID8gTmFOIDogcyA/IC1JbmZpbml0eSA6IEluZmluaXR5O1xuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgcG93KDIsIG1MZW4pO1xuICAgIGUgPSBlIC0gZUJpYXM7XG4gIH0gcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBwb3coMiwgZSAtIG1MZW4pO1xufTtcblxudmFyIHVucGFja0kzMiA9IGZ1bmN0aW9uKGJ5dGVzKXtcbiAgcmV0dXJuIGJ5dGVzWzNdIDw8IDI0IHwgYnl0ZXNbMl0gPDwgMTYgfCBieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMF07XG59O1xudmFyIHBhY2tJOCA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIFtpdCAmIDB4ZmZdO1xufTtcbnZhciBwYWNrSTE2ID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gW2l0ICYgMHhmZiwgaXQgPj4gOCAmIDB4ZmZdO1xufTtcbnZhciBwYWNrSTMyID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gW2l0ICYgMHhmZiwgaXQgPj4gOCAmIDB4ZmYsIGl0ID4+IDE2ICYgMHhmZiwgaXQgPj4gMjQgJiAweGZmXTtcbn07XG52YXIgcGFja0Y2NCA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHBhY2tJRUVFNzU0KGl0LCA1MiwgOCk7XG59O1xudmFyIHBhY2tGMzIgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBwYWNrSUVFRTc1NChpdCwgMjMsIDQpO1xufTtcblxudmFyIGFkZEdldHRlciA9IGZ1bmN0aW9uKEMsIGtleSwgaW50ZXJuYWwpe1xuICBkUChDW1BST1RPVFlQRV0sIGtleSwge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXNbaW50ZXJuYWxdOyB9fSk7XG59O1xuXG52YXIgZ2V0ID0gZnVuY3Rpb24odmlldywgYnl0ZXMsIGluZGV4LCBpc0xpdHRsZUVuZGlhbil7XG4gIHZhciBudW1JbmRleCA9ICtpbmRleFxuICAgICwgaW50SW5kZXggPSB0b0ludGVnZXIobnVtSW5kZXgpO1xuICBpZihudW1JbmRleCAhPSBpbnRJbmRleCB8fCBpbnRJbmRleCA8IDAgfHwgaW50SW5kZXggKyBieXRlcyA+IHZpZXdbJExFTkdUSF0pdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19JTkRFWCk7XG4gIHZhciBzdG9yZSA9IHZpZXdbJEJVRkZFUl0uX2JcbiAgICAsIHN0YXJ0ID0gaW50SW5kZXggKyB2aWV3WyRPRkZTRVRdXG4gICAgLCBwYWNrICA9IHN0b3JlLnNsaWNlKHN0YXJ0LCBzdGFydCArIGJ5dGVzKTtcbiAgcmV0dXJuIGlzTGl0dGxlRW5kaWFuID8gcGFjayA6IHBhY2sucmV2ZXJzZSgpO1xufTtcbnZhciBzZXQgPSBmdW5jdGlvbih2aWV3LCBieXRlcywgaW5kZXgsIGNvbnZlcnNpb24sIHZhbHVlLCBpc0xpdHRsZUVuZGlhbil7XG4gIHZhciBudW1JbmRleCA9ICtpbmRleFxuICAgICwgaW50SW5kZXggPSB0b0ludGVnZXIobnVtSW5kZXgpO1xuICBpZihudW1JbmRleCAhPSBpbnRJbmRleCB8fCBpbnRJbmRleCA8IDAgfHwgaW50SW5kZXggKyBieXRlcyA+IHZpZXdbJExFTkdUSF0pdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19JTkRFWCk7XG4gIHZhciBzdG9yZSA9IHZpZXdbJEJVRkZFUl0uX2JcbiAgICAsIHN0YXJ0ID0gaW50SW5kZXggKyB2aWV3WyRPRkZTRVRdXG4gICAgLCBwYWNrICA9IGNvbnZlcnNpb24oK3ZhbHVlKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGJ5dGVzOyBpKyspc3RvcmVbc3RhcnQgKyBpXSA9IHBhY2tbaXNMaXR0bGVFbmRpYW4gPyBpIDogYnl0ZXMgLSBpIC0gMV07XG59O1xuXG52YXIgdmFsaWRhdGVBcnJheUJ1ZmZlckFyZ3VtZW50cyA9IGZ1bmN0aW9uKHRoYXQsIGxlbmd0aCl7XG4gIGFuSW5zdGFuY2UodGhhdCwgJEFycmF5QnVmZmVyLCBBUlJBWV9CVUZGRVIpO1xuICB2YXIgbnVtYmVyTGVuZ3RoID0gK2xlbmd0aFxuICAgICwgYnl0ZUxlbmd0aCAgID0gdG9MZW5ndGgobnVtYmVyTGVuZ3RoKTtcbiAgaWYobnVtYmVyTGVuZ3RoICE9IGJ5dGVMZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICByZXR1cm4gYnl0ZUxlbmd0aDtcbn07XG5cbmlmKCEkdHlwZWQuQUJWKXtcbiAgJEFycmF5QnVmZmVyID0gZnVuY3Rpb24gQXJyYXlCdWZmZXIobGVuZ3RoKXtcbiAgICB2YXIgYnl0ZUxlbmd0aCA9IHZhbGlkYXRlQXJyYXlCdWZmZXJBcmd1bWVudHModGhpcywgbGVuZ3RoKTtcbiAgICB0aGlzLl9iICAgICAgID0gYXJyYXlGaWxsLmNhbGwoQXJyYXkoYnl0ZUxlbmd0aCksIDApO1xuICAgIHRoaXNbJExFTkdUSF0gPSBieXRlTGVuZ3RoO1xuICB9O1xuXG4gICREYXRhVmlldyA9IGZ1bmN0aW9uIERhdGFWaWV3KGJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCl7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCAkRGF0YVZpZXcsIERBVEFfVklFVyk7XG4gICAgYW5JbnN0YW5jZShidWZmZXIsICRBcnJheUJ1ZmZlciwgREFUQV9WSUVXKTtcbiAgICB2YXIgYnVmZmVyTGVuZ3RoID0gYnVmZmVyWyRMRU5HVEhdXG4gICAgICAsIG9mZnNldCAgICAgICA9IHRvSW50ZWdlcihieXRlT2Zmc2V0KTtcbiAgICBpZihvZmZzZXQgPCAwIHx8IG9mZnNldCA+IGJ1ZmZlckxlbmd0aCl0aHJvdyBSYW5nZUVycm9yKCdXcm9uZyBvZmZzZXQhJyk7XG4gICAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPT09IHVuZGVmaW5lZCA/IGJ1ZmZlckxlbmd0aCAtIG9mZnNldCA6IHRvTGVuZ3RoKGJ5dGVMZW5ndGgpO1xuICAgIGlmKG9mZnNldCArIGJ5dGVMZW5ndGggPiBidWZmZXJMZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgIHRoaXNbJEJVRkZFUl0gPSBidWZmZXI7XG4gICAgdGhpc1skT0ZGU0VUXSA9IG9mZnNldDtcbiAgICB0aGlzWyRMRU5HVEhdID0gYnl0ZUxlbmd0aDtcbiAgfTtcblxuICBpZihERVNDUklQVE9SUyl7XG4gICAgYWRkR2V0dGVyKCRBcnJheUJ1ZmZlciwgQllURV9MRU5HVEgsICdfbCcpO1xuICAgIGFkZEdldHRlcigkRGF0YVZpZXcsIEJVRkZFUiwgJ19iJyk7XG4gICAgYWRkR2V0dGVyKCREYXRhVmlldywgQllURV9MRU5HVEgsICdfbCcpO1xuICAgIGFkZEdldHRlcigkRGF0YVZpZXcsIEJZVEVfT0ZGU0VULCAnX28nKTtcbiAgfVxuXG4gIHJlZGVmaW5lQWxsKCREYXRhVmlld1tQUk9UT1RZUEVdLCB7XG4gICAgZ2V0SW50ODogZnVuY3Rpb24gZ2V0SW50OChieXRlT2Zmc2V0KXtcbiAgICAgIHJldHVybiBnZXQodGhpcywgMSwgYnl0ZU9mZnNldClbMF0gPDwgMjQgPj4gMjQ7XG4gICAgfSxcbiAgICBnZXRVaW50ODogZnVuY3Rpb24gZ2V0VWludDgoYnl0ZU9mZnNldCl7XG4gICAgICByZXR1cm4gZ2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQpWzBdO1xuICAgIH0sXG4gICAgZ2V0SW50MTY6IGZ1bmN0aW9uIGdldEludDE2KGJ5dGVPZmZzZXQgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICB2YXIgYnl0ZXMgPSBnZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKTtcbiAgICAgIHJldHVybiAoYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzBdKSA8PCAxNiA+PiAxNjtcbiAgICB9LFxuICAgIGdldFVpbnQxNjogZnVuY3Rpb24gZ2V0VWludDE2KGJ5dGVPZmZzZXQgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICB2YXIgYnl0ZXMgPSBnZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKTtcbiAgICAgIHJldHVybiBieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMF07XG4gICAgfSxcbiAgICBnZXRJbnQzMjogZnVuY3Rpb24gZ2V0SW50MzIoYnl0ZU9mZnNldCAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHJldHVybiB1bnBhY2tJMzIoZ2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSkpO1xuICAgIH0sXG4gICAgZ2V0VWludDMyOiBmdW5jdGlvbiBnZXRVaW50MzIoYnl0ZU9mZnNldCAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHJldHVybiB1bnBhY2tJMzIoZ2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSkpID4+PiAwO1xuICAgIH0sXG4gICAgZ2V0RmxvYXQzMjogZnVuY3Rpb24gZ2V0RmxvYXQzMihieXRlT2Zmc2V0IC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgcmV0dXJuIHVucGFja0lFRUU3NTQoZ2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSksIDIzLCA0KTtcbiAgICB9LFxuICAgIGdldEZsb2F0NjQ6IGZ1bmN0aW9uIGdldEZsb2F0NjQoYnl0ZU9mZnNldCAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHJldHVybiB1bnBhY2tJRUVFNzU0KGdldCh0aGlzLCA4LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pLCA1MiwgOCk7XG4gICAgfSxcbiAgICBzZXRJbnQ4OiBmdW5jdGlvbiBzZXRJbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKXtcbiAgICAgIHNldCh0aGlzLCAxLCBieXRlT2Zmc2V0LCBwYWNrSTgsIHZhbHVlKTtcbiAgICB9LFxuICAgIHNldFVpbnQ4OiBmdW5jdGlvbiBzZXRVaW50OChieXRlT2Zmc2V0LCB2YWx1ZSl7XG4gICAgICBzZXQodGhpcywgMSwgYnl0ZU9mZnNldCwgcGFja0k4LCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzZXRJbnQxNjogZnVuY3Rpb24gc2V0SW50MTYoYnl0ZU9mZnNldCwgdmFsdWUgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICBzZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgcGFja0kxNiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRVaW50MTY6IGZ1bmN0aW9uIHNldFVpbnQxNihieXRlT2Zmc2V0LCB2YWx1ZSAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHNldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBwYWNrSTE2LCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldEludDMyOiBmdW5jdGlvbiBzZXRJbnQzMihieXRlT2Zmc2V0LCB2YWx1ZSAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrSTMyLCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldFVpbnQzMjogZnVuY3Rpb24gc2V0VWludDMyKGJ5dGVPZmZzZXQsIHZhbHVlIC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgc2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIHBhY2tJMzIsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0RmxvYXQzMjogZnVuY3Rpb24gc2V0RmxvYXQzMihieXRlT2Zmc2V0LCB2YWx1ZSAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrRjMyLCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldEZsb2F0NjQ6IGZ1bmN0aW9uIHNldEZsb2F0NjQoYnl0ZU9mZnNldCwgdmFsdWUgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICBzZXQodGhpcywgOCwgYnl0ZU9mZnNldCwgcGFja0Y2NCwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIGlmKCFmYWlscyhmdW5jdGlvbigpe1xuICAgIG5ldyAkQXJyYXlCdWZmZXI7ICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICB9KSB8fCAhZmFpbHMoZnVuY3Rpb24oKXtcbiAgICBuZXcgJEFycmF5QnVmZmVyKC41KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgfSkpe1xuICAgICRBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIEFycmF5QnVmZmVyKGxlbmd0aCl7XG4gICAgICByZXR1cm4gbmV3IEJhc2VCdWZmZXIodmFsaWRhdGVBcnJheUJ1ZmZlckFyZ3VtZW50cyh0aGlzLCBsZW5ndGgpKTtcbiAgICB9O1xuICAgIHZhciBBcnJheUJ1ZmZlclByb3RvID0gJEFycmF5QnVmZmVyW1BST1RPVFlQRV0gPSBCYXNlQnVmZmVyW1BST1RPVFlQRV07XG4gICAgZm9yKHZhciBrZXlzID0gZ09QTihCYXNlQnVmZmVyKSwgaiA9IDAsIGtleTsga2V5cy5sZW5ndGggPiBqOyApe1xuICAgICAgaWYoISgoa2V5ID0ga2V5c1tqKytdKSBpbiAkQXJyYXlCdWZmZXIpKWhpZGUoJEFycmF5QnVmZmVyLCBrZXksIEJhc2VCdWZmZXJba2V5XSk7XG4gICAgfTtcbiAgICBpZighTElCUkFSWSlBcnJheUJ1ZmZlclByb3RvLmNvbnN0cnVjdG9yID0gJEFycmF5QnVmZmVyO1xuICB9XG4gIC8vIGlPUyBTYWZhcmkgNy54IGJ1Z1xuICB2YXIgdmlldyA9IG5ldyAkRGF0YVZpZXcobmV3ICRBcnJheUJ1ZmZlcigyKSlcbiAgICAsICRzZXRJbnQ4ID0gJERhdGFWaWV3W1BST1RPVFlQRV0uc2V0SW50ODtcbiAgdmlldy5zZXRJbnQ4KDAsIDIxNDc0ODM2NDgpO1xuICB2aWV3LnNldEludDgoMSwgMjE0NzQ4MzY0OSk7XG4gIGlmKHZpZXcuZ2V0SW50OCgwKSB8fCAhdmlldy5nZXRJbnQ4KDEpKXJlZGVmaW5lQWxsKCREYXRhVmlld1tQUk9UT1RZUEVdLCB7XG4gICAgc2V0SW50ODogZnVuY3Rpb24gc2V0SW50OChieXRlT2Zmc2V0LCB2YWx1ZSl7XG4gICAgICAkc2V0SW50OC5jYWxsKHRoaXMsIGJ5dGVPZmZzZXQsIHZhbHVlIDw8IDI0ID4+IDI0KTtcbiAgICB9LFxuICAgIHNldFVpbnQ4OiBmdW5jdGlvbiBzZXRVaW50OChieXRlT2Zmc2V0LCB2YWx1ZSl7XG4gICAgICAkc2V0SW50OC5jYWxsKHRoaXMsIGJ5dGVPZmZzZXQsIHZhbHVlIDw8IDI0ID4+IDI0KTtcbiAgICB9XG4gIH0sIHRydWUpO1xufVxuc2V0VG9TdHJpbmdUYWcoJEFycmF5QnVmZmVyLCBBUlJBWV9CVUZGRVIpO1xuc2V0VG9TdHJpbmdUYWcoJERhdGFWaWV3LCBEQVRBX1ZJRVcpO1xuaGlkZSgkRGF0YVZpZXdbUFJPVE9UWVBFXSwgJHR5cGVkLlZJRVcsIHRydWUpO1xuZXhwb3J0c1tBUlJBWV9CVUZGRVJdID0gJEFycmF5QnVmZmVyO1xuZXhwb3J0c1tEQVRBX1ZJRVddID0gJERhdGFWaWV3OyIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGhpZGUgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIHVpZCAgICA9IHJlcXVpcmUoJy4vX3VpZCcpXG4gICwgVFlQRUQgID0gdWlkKCd0eXBlZF9hcnJheScpXG4gICwgVklFVyAgID0gdWlkKCd2aWV3JylcbiAgLCBBQlYgICAgPSAhIShnbG9iYWwuQXJyYXlCdWZmZXIgJiYgZ2xvYmFsLkRhdGFWaWV3KVxuICAsIENPTlNUUiA9IEFCVlxuICAsIGkgPSAwLCBsID0gOSwgVHlwZWQ7XG5cbnZhciBUeXBlZEFycmF5Q29uc3RydWN0b3JzID0gKFxuICAnSW50OEFycmF5LFVpbnQ4QXJyYXksVWludDhDbGFtcGVkQXJyYXksSW50MTZBcnJheSxVaW50MTZBcnJheSxJbnQzMkFycmF5LFVpbnQzMkFycmF5LEZsb2F0MzJBcnJheSxGbG9hdDY0QXJyYXknXG4pLnNwbGl0KCcsJyk7XG5cbndoaWxlKGkgPCBsKXtcbiAgaWYoVHlwZWQgPSBnbG9iYWxbVHlwZWRBcnJheUNvbnN0cnVjdG9yc1tpKytdXSl7XG4gICAgaGlkZShUeXBlZC5wcm90b3R5cGUsIFRZUEVELCB0cnVlKTtcbiAgICBoaWRlKFR5cGVkLnByb3RvdHlwZSwgVklFVywgdHJ1ZSk7XG4gIH0gZWxzZSBDT05TVFIgPSBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEFCVjogICAgQUJWLFxuICBDT05TVFI6IENPTlNUUixcbiAgVFlQRUQ6ICBUWVBFRCxcbiAgVklFVzogICBWSUVXXG59OyIsInZhciBpZCA9IDBcbiAgLCBweCA9IE1hdGgucmFuZG9tKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59OyIsInZhciBnbG9iYWwgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgY29yZSAgICAgICAgICAgPSByZXF1aXJlKCcuL19jb3JlJylcbiAgLCBMSUJSQVJZICAgICAgICA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKVxuICAsIHdrc0V4dCAgICAgICAgID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpXG4gICwgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihuYW1lKXtcbiAgdmFyICRTeW1ib2wgPSBjb3JlLlN5bWJvbCB8fCAoY29yZS5TeW1ib2wgPSBMSUJSQVJZID8ge30gOiBnbG9iYWwuU3ltYm9sIHx8IHt9KTtcbiAgaWYobmFtZS5jaGFyQXQoMCkgIT0gJ18nICYmICEobmFtZSBpbiAkU3ltYm9sKSlkZWZpbmVQcm9wZXJ0eSgkU3ltYm9sLCBuYW1lLCB7dmFsdWU6IHdrc0V4dC5mKG5hbWUpfSk7XG59OyIsImV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX3drcycpOyIsInZhciBzdG9yZSAgICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ3drcycpXG4gICwgdWlkICAgICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpXG4gICwgU3ltYm9sICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlN5bWJvbFxuICAsIFVTRV9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09ICdmdW5jdGlvbic7XG5cbnZhciAkZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obmFtZSl7XG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxuICAgIFVTRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdIHx8IChVU0VfU1lNQk9MID8gU3ltYm9sIDogdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG59O1xuXG4kZXhwb3J0cy5zdG9yZSA9IHN0b3JlOyIsInZhciBjbGFzc29mICAgPSByZXF1aXJlKCcuL19jbGFzc29mJylcbiAgLCBJVEVSQVRPUiAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb3JlJykuZ2V0SXRlcmF0b3JNZXRob2QgPSBmdW5jdGlvbihpdCl7XG4gIGlmKGl0ICE9IHVuZGVmaW5lZClyZXR1cm4gaXRbSVRFUkFUT1JdXG4gICAgfHwgaXRbJ0BAaXRlcmF0b3InXVxuICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XG59OyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iZW5qYW1pbmdyL1JleEV4cC5lc2NhcGVcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkcmUgICAgID0gcmVxdWlyZSgnLi9fcmVwbGFjZXInKSgvW1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWdFeHAnLCB7ZXNjYXBlOiBmdW5jdGlvbiBlc2NhcGUoaXQpeyByZXR1cm4gJHJlKGl0KTsgfX0pO1xuIiwiLy8gMjIuMS4zLjMgQXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4odGFyZ2V0LCBzdGFydCwgZW5kID0gdGhpcy5sZW5ndGgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0FycmF5Jywge2NvcHlXaXRoaW46IHJlcXVpcmUoJy4vX2FycmF5LWNvcHktd2l0aGluJyl9KTtcblxucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoJ2NvcHlXaXRoaW4nKTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGV2ZXJ5ICA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSg0KTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLmV2ZXJ5LCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuNSAvIDE1LjQuNC4xNiBBcnJheS5wcm90b3R5cGUuZXZlcnkoY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgZXZlcnk6IGZ1bmN0aW9uIGV2ZXJ5KGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKXtcbiAgICByZXR1cm4gJGV2ZXJ5KHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pOyIsIi8vIDIyLjEuMy42IEFycmF5LnByb3RvdHlwZS5maWxsKHZhbHVlLCBzdGFydCA9IDAsIGVuZCA9IHRoaXMubGVuZ3RoKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdBcnJheScsIHtmaWxsOiByZXF1aXJlKCcuL19hcnJheS1maWxsJyl9KTtcblxucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoJ2ZpbGwnKTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGZpbHRlciA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgyKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLmZpbHRlciwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjcgLyAxNS40LjQuMjAgQXJyYXkucHJvdG90eXBlLmZpbHRlcihjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLyl7XG4gICAgcmV0dXJuICRmaWx0ZXIodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjIuMS4zLjkgQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleChwcmVkaWNhdGUsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGZpbmQgICA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSg2KVxuICAsIEtFWSAgICAgPSAnZmluZEluZGV4J1xuICAsIGZvcmNlZCAgPSB0cnVlO1xuLy8gU2hvdWxkbid0IHNraXAgaG9sZXNcbmlmKEtFWSBpbiBbXSlBcnJheSgxKVtLRVldKGZ1bmN0aW9uKCl7IGZvcmNlZCA9IGZhbHNlOyB9KTtcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogZm9yY2VkLCAnQXJyYXknLCB7XG4gIGZpbmRJbmRleDogZnVuY3Rpb24gZmluZEluZGV4KGNhbGxiYWNrZm4vKiwgdGhhdCA9IHVuZGVmaW5lZCAqLyl7XG4gICAgcmV0dXJuICRmaW5kKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKShLRVkpOyIsIid1c2Ugc3RyaWN0Jztcbi8vIDIyLjEuMy44IEFycmF5LnByb3RvdHlwZS5maW5kKHByZWRpY2F0ZSwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkZmluZCAgID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDUpXG4gICwgS0VZICAgICA9ICdmaW5kJ1xuICAsIGZvcmNlZCAgPSB0cnVlO1xuLy8gU2hvdWxkbid0IHNraXAgaG9sZXNcbmlmKEtFWSBpbiBbXSlBcnJheSgxKVtLRVldKGZ1bmN0aW9uKCl7IGZvcmNlZCA9IGZhbHNlOyB9KTtcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogZm9yY2VkLCAnQXJyYXknLCB7XG4gIGZpbmQ6IGZ1bmN0aW9uIGZpbmQoY2FsbGJhY2tmbi8qLCB0aGF0ID0gdW5kZWZpbmVkICovKXtcbiAgICByZXR1cm4gJGZpbmQodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKEtFWSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkZm9yRWFjaCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgwKVxuICAsIFNUUklDVCAgID0gcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLmZvckVhY2gsIHRydWUpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFTVFJJQ1QsICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjEwIC8gMTUuNC40LjE4IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pe1xuICAgIHJldHVybiAkZm9yRWFjaCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgY3R4ICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b09iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgY2FsbCAgICAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyLWNhbGwnKVxuICAsIGlzQXJyYXlJdGVyICAgID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpXG4gICwgdG9MZW5ndGggICAgICAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fY3JlYXRlLXByb3BlcnR5JylcbiAgLCBnZXRJdGVyRm4gICAgICA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JykoZnVuY3Rpb24oaXRlcil7IEFycmF5LmZyb20oaXRlcik7IH0pLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMi4xIEFycmF5LmZyb20oYXJyYXlMaWtlLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgZnJvbTogZnVuY3Rpb24gZnJvbShhcnJheUxpa2UvKiwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQqLyl7XG4gICAgdmFyIE8gICAgICAgPSB0b09iamVjdChhcnJheUxpa2UpXG4gICAgICAsIEMgICAgICAgPSB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5XG4gICAgICAsIGFMZW4gICAgPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAsIG1hcGZuICAgPSBhTGVuID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZFxuICAgICAgLCBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZFxuICAgICAgLCBpbmRleCAgID0gMFxuICAgICAgLCBpdGVyRm4gID0gZ2V0SXRlckZuKE8pXG4gICAgICAsIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvcjtcbiAgICBpZihtYXBwaW5nKW1hcGZuID0gY3R4KG1hcGZuLCBhTGVuID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCwgMik7XG4gICAgLy8gaWYgb2JqZWN0IGlzbid0IGl0ZXJhYmxlIG9yIGl0J3MgYXJyYXkgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yIC0gdXNlIHNpbXBsZSBjYXNlXG4gICAgaWYoaXRlckZuICE9IHVuZGVmaW5lZCAmJiAhKEMgPT0gQXJyYXkgJiYgaXNBcnJheUl0ZXIoaXRlckZuKSkpe1xuICAgICAgZm9yKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoTyksIHJlc3VsdCA9IG5ldyBDOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7IGluZGV4Kyspe1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gY2FsbChpdGVyYXRvciwgbWFwZm4sIFtzdGVwLnZhbHVlLCBpbmRleF0sIHRydWUpIDogc3RlcC52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICAgIGZvcihyZXN1bHQgPSBuZXcgQyhsZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKyl7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmcgPyBtYXBmbihPW2luZGV4XSwgaW5kZXgpIDogT1tpbmRleF0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQubGVuZ3RoID0gaW5kZXg7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGluZGV4T2YgICAgICA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpXG4gICwgJG5hdGl2ZSAgICAgICA9IFtdLmluZGV4T2ZcbiAgLCBORUdBVElWRV9aRVJPID0gISEkbmF0aXZlICYmIDEgLyBbMV0uaW5kZXhPZigxLCAtMCkgPCAwO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChORUdBVElWRV9aRVJPIHx8ICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoJG5hdGl2ZSkpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xMSAvIDE1LjQuNC4xNCBBcnJheS5wcm90b3R5cGUuaW5kZXhPZihzZWFyY2hFbGVtZW50IFssIGZyb21JbmRleF0pXG4gIGluZGV4T2Y6IGZ1bmN0aW9uIGluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiwgZnJvbUluZGV4ID0gMCAqLyl7XG4gICAgcmV0dXJuIE5FR0FUSVZFX1pFUk9cbiAgICAgIC8vIGNvbnZlcnQgLTAgdG8gKzBcbiAgICAgID8gJG5hdGl2ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IDBcbiAgICAgIDogJGluZGV4T2YodGhpcywgc2VhcmNoRWxlbWVudCwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7IiwiLy8gMjIuMS4yLjIgLyAxNS40LjMuMiBBcnJheS5pc0FycmF5KGFyZylcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnQXJyYXknLCB7aXNBcnJheTogcmVxdWlyZSgnLi9faXMtYXJyYXknKX0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJylcbiAgLCBzdGVwICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faXRlci1zdGVwJylcbiAgLCBJdGVyYXRvcnMgICAgICAgID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJylcbiAgLCB0b0lPYmplY3QgICAgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xuXG4vLyAyMi4xLjMuNCBBcnJheS5wcm90b3R5cGUuZW50cmllcygpXG4vLyAyMi4xLjMuMTMgQXJyYXkucHJvdG90eXBlLmtleXMoKVxuLy8gMjIuMS4zLjI5IEFycmF5LnByb3RvdHlwZS52YWx1ZXMoKVxuLy8gMjIuMS4zLjMwIEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uKGl0ZXJhdGVkLCBraW5kKXtcbiAgdGhpcy5fdCA9IHRvSU9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgLy8ga2luZFxuLy8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbigpe1xuICB2YXIgTyAgICAgPSB0aGlzLl90XG4gICAgLCBraW5kICA9IHRoaXMuX2tcbiAgICAsIGluZGV4ID0gdGhpcy5faSsrO1xuICBpZighTyB8fCBpbmRleCA+PSBPLmxlbmd0aCl7XG4gICAgdGhpcy5fdCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gc3RlcCgxKTtcbiAgfVxuICBpZihraW5kID09ICdrZXlzJyAgKXJldHVybiBzdGVwKDAsIGluZGV4KTtcbiAgaWYoa2luZCA9PSAndmFsdWVzJylyZXR1cm4gc3RlcCgwLCBPW2luZGV4XSk7XG4gIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5qb2luKHNlcGFyYXRvcilcbnZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIGFycmF5Sm9pbiA9IFtdLmpvaW47XG5cbi8vIGZhbGxiYWNrIGZvciBub3QgYXJyYXktbGlrZSBzdHJpbmdzXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChyZXF1aXJlKCcuL19pb2JqZWN0JykgIT0gT2JqZWN0IHx8ICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoYXJyYXlKb2luKSksICdBcnJheScsIHtcbiAgam9pbjogZnVuY3Rpb24gam9pbihzZXBhcmF0b3Ipe1xuICAgIHJldHVybiBhcnJheUpvaW4uY2FsbCh0b0lPYmplY3QodGhpcyksIHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkID8gJywnIDogc2VwYXJhdG9yKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvSU9iamVjdCAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCB0b0ludGVnZXIgICAgID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgdG9MZW5ndGggICAgICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgJG5hdGl2ZSAgICAgICA9IFtdLmxhc3RJbmRleE9mXG4gICwgTkVHQVRJVkVfWkVSTyA9ICEhJG5hdGl2ZSAmJiAxIC8gWzFdLmxhc3RJbmRleE9mKDEsIC0wKSA8IDA7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKE5FR0FUSVZFX1pFUk8gfHwgIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKSgkbmF0aXZlKSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjE0IC8gMTUuNC40LjE1IEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50IFssIGZyb21JbmRleF0pXG4gIGxhc3RJbmRleE9mOiBmdW5jdGlvbiBsYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50IC8qLCBmcm9tSW5kZXggPSBAWyotMV0gKi8pe1xuICAgIC8vIGNvbnZlcnQgLTAgdG8gKzBcbiAgICBpZihORUdBVElWRV9aRVJPKXJldHVybiAkbmF0aXZlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgMDtcbiAgICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KHRoaXMpXG4gICAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKVxuICAgICAgLCBpbmRleCAgPSBsZW5ndGggLSAxO1xuICAgIGlmKGFyZ3VtZW50cy5sZW5ndGggPiAxKWluZGV4ID0gTWF0aC5taW4oaW5kZXgsIHRvSW50ZWdlcihhcmd1bWVudHNbMV0pKTtcbiAgICBpZihpbmRleCA8IDApaW5kZXggPSBsZW5ndGggKyBpbmRleDtcbiAgICBmb3IoO2luZGV4ID49IDA7IGluZGV4LS0paWYoaW5kZXggaW4gTylpZihPW2luZGV4XSA9PT0gc2VhcmNoRWxlbWVudClyZXR1cm4gaW5kZXggfHwgMDtcbiAgICByZXR1cm4gLTE7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkbWFwICAgID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDEpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10ubWFwLCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTUgLyAxNS40LjQuMTkgQXJyYXkucHJvdG90eXBlLm1hcChjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBtYXA6IGZ1bmN0aW9uIG1hcChjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLyl7XG4gICAgcmV0dXJuICRtYXAodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2NyZWF0ZS1wcm9wZXJ0eScpO1xuXG4vLyBXZWJLaXQgQXJyYXkub2YgaXNuJ3QgZ2VuZXJpY1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIGZ1bmN0aW9uIEYoKXt9XG4gIHJldHVybiAhKEFycmF5Lm9mLmNhbGwoRikgaW5zdGFuY2VvZiBGKTtcbn0pLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMi4zIEFycmF5Lm9mKCAuLi5pdGVtcylcbiAgb2Y6IGZ1bmN0aW9uIG9mKC8qIC4uLmFyZ3MgKi8pe1xuICAgIHZhciBpbmRleCAgPSAwXG4gICAgICAsIGFMZW4gICA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICwgcmVzdWx0ID0gbmV3ICh0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5KShhTGVuKTtcbiAgICB3aGlsZShhTGVuID4gaW5kZXgpY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgYXJndW1lbnRzW2luZGV4KytdKTtcbiAgICByZXN1bHQubGVuZ3RoID0gYUxlbjtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHJlZHVjZSA9IHJlcXVpcmUoJy4vX2FycmF5LXJlZHVjZScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10ucmVkdWNlUmlnaHQsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xOSAvIDE1LjQuNC4yMiBBcnJheS5wcm90b3R5cGUucmVkdWNlUmlnaHQoY2FsbGJhY2tmbiBbLCBpbml0aWFsVmFsdWVdKVxuICByZWR1Y2VSaWdodDogZnVuY3Rpb24gcmVkdWNlUmlnaHQoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLyl7XG4gICAgcmV0dXJuICRyZWR1Y2UodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCwgYXJndW1lbnRzWzFdLCB0cnVlKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRyZWR1Y2UgPSByZXF1aXJlKCcuL19hcnJheS1yZWR1Y2UnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLnJlZHVjZSwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjE4IC8gMTUuNC40LjIxIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UoY2FsbGJhY2tmbiBbLCBpbml0aWFsVmFsdWVdKVxuICByZWR1Y2U6IGZ1bmN0aW9uIHJlZHVjZShjYWxsYmFja2ZuIC8qICwgaW5pdGlhbFZhbHVlICovKXtcbiAgICByZXR1cm4gJHJlZHVjZSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoLCBhcmd1bWVudHNbMV0sIGZhbHNlKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGh0bWwgICAgICAgPSByZXF1aXJlKCcuL19odG1sJylcbiAgLCBjb2YgICAgICAgID0gcmVxdWlyZSgnLi9fY29mJylcbiAgLCB0b0luZGV4ICAgID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKVxuICAsIHRvTGVuZ3RoICAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGFycmF5U2xpY2UgPSBbXS5zbGljZTtcblxuLy8gZmFsbGJhY2sgZm9yIG5vdCBhcnJheS1saWtlIEVTMyBzdHJpbmdzIGFuZCBET00gb2JqZWN0c1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIGlmKGh0bWwpYXJyYXlTbGljZS5jYWxsKGh0bWwpO1xufSksICdBcnJheScsIHtcbiAgc2xpY2U6IGZ1bmN0aW9uIHNsaWNlKGJlZ2luLCBlbmQpe1xuICAgIHZhciBsZW4gICA9IHRvTGVuZ3RoKHRoaXMubGVuZ3RoKVxuICAgICAgLCBrbGFzcyA9IGNvZih0aGlzKTtcbiAgICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IGVuZDtcbiAgICBpZihrbGFzcyA9PSAnQXJyYXknKXJldHVybiBhcnJheVNsaWNlLmNhbGwodGhpcywgYmVnaW4sIGVuZCk7XG4gICAgdmFyIHN0YXJ0ICA9IHRvSW5kZXgoYmVnaW4sIGxlbilcbiAgICAgICwgdXBUbyAgID0gdG9JbmRleChlbmQsIGxlbilcbiAgICAgICwgc2l6ZSAgID0gdG9MZW5ndGgodXBUbyAtIHN0YXJ0KVxuICAgICAgLCBjbG9uZWQgPSBBcnJheShzaXplKVxuICAgICAgLCBpICAgICAgPSAwO1xuICAgIGZvcig7IGkgPCBzaXplOyBpKyspY2xvbmVkW2ldID0ga2xhc3MgPT0gJ1N0cmluZydcbiAgICAgID8gdGhpcy5jaGFyQXQoc3RhcnQgKyBpKVxuICAgICAgOiB0aGlzW3N0YXJ0ICsgaV07XG4gICAgcmV0dXJuIGNsb25lZDtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRzb21lICAgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5zb21lLCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMjMgLyAxNS40LjQuMTcgQXJyYXkucHJvdG90eXBlLnNvbWUoY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgc29tZTogZnVuY3Rpb24gc29tZShjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLyl7XG4gICAgcmV0dXJuICRzb21lKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKVxuICAsIHRvT2JqZWN0ICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgZmFpbHMgICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsICRzb3J0ICAgICA9IFtdLnNvcnRcbiAgLCB0ZXN0ICAgICAgPSBbMSwgMiwgM107XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKGZhaWxzKGZ1bmN0aW9uKCl7XG4gIC8vIElFOC1cbiAgdGVzdC5zb3J0KHVuZGVmaW5lZCk7XG59KSB8fCAhZmFpbHMoZnVuY3Rpb24oKXtcbiAgLy8gVjggYnVnXG4gIHRlc3Quc29ydChudWxsKTtcbiAgLy8gT2xkIFdlYktpdFxufSkgfHwgIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKSgkc29ydCkpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4yNSBBcnJheS5wcm90b3R5cGUuc29ydChjb21wYXJlZm4pXG4gIHNvcnQ6IGZ1bmN0aW9uIHNvcnQoY29tcGFyZWZuKXtcbiAgICByZXR1cm4gY29tcGFyZWZuID09PSB1bmRlZmluZWRcbiAgICAgID8gJHNvcnQuY2FsbCh0b09iamVjdCh0aGlzKSlcbiAgICAgIDogJHNvcnQuY2FsbCh0b09iamVjdCh0aGlzKSwgYUZ1bmN0aW9uKGNvbXBhcmVmbikpO1xuICB9XG59KTsiLCJyZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKCdBcnJheScpOyIsIi8vIDIwLjMuMy4xIC8gMTUuOS40LjQgRGF0ZS5ub3coKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdEYXRlJywge25vdzogZnVuY3Rpb24oKXsgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpOyB9fSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjAuMy40LjM2IC8gMTUuOS41LjQzIERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nKClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBmYWlscyAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIGdldFRpbWUgPSBEYXRlLnByb3RvdHlwZS5nZXRUaW1lO1xuXG52YXIgbHogPSBmdW5jdGlvbihudW0pe1xuICByZXR1cm4gbnVtID4gOSA/IG51bSA6ICcwJyArIG51bTtcbn07XG5cbi8vIFBoYW50b21KUyAvIG9sZCBXZWJLaXQgaGFzIGEgYnJva2VuIGltcGxlbWVudGF0aW9uc1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoZmFpbHMoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIG5ldyBEYXRlKC01ZTEzIC0gMSkudG9JU09TdHJpbmcoKSAhPSAnMDM4NS0wNy0yNVQwNzowNjozOS45OTlaJztcbn0pIHx8ICFmYWlscyhmdW5jdGlvbigpe1xuICBuZXcgRGF0ZShOYU4pLnRvSVNPU3RyaW5nKCk7XG59KSksICdEYXRlJywge1xuICB0b0lTT1N0cmluZzogZnVuY3Rpb24gdG9JU09TdHJpbmcoKXtcbiAgICBpZighaXNGaW5pdGUoZ2V0VGltZS5jYWxsKHRoaXMpKSl0aHJvdyBSYW5nZUVycm9yKCdJbnZhbGlkIHRpbWUgdmFsdWUnKTtcbiAgICB2YXIgZCA9IHRoaXNcbiAgICAgICwgeSA9IGQuZ2V0VVRDRnVsbFllYXIoKVxuICAgICAgLCBtID0gZC5nZXRVVENNaWxsaXNlY29uZHMoKVxuICAgICAgLCBzID0geSA8IDAgPyAnLScgOiB5ID4gOTk5OSA/ICcrJyA6ICcnO1xuICAgIHJldHVybiBzICsgKCcwMDAwMCcgKyBNYXRoLmFicyh5KSkuc2xpY2UocyA/IC02IDogLTQpICtcbiAgICAgICctJyArIGx6KGQuZ2V0VVRDTW9udGgoKSArIDEpICsgJy0nICsgbHooZC5nZXRVVENEYXRlKCkpICtcbiAgICAgICdUJyArIGx6KGQuZ2V0VVRDSG91cnMoKSkgKyAnOicgKyBseihkLmdldFVUQ01pbnV0ZXMoKSkgK1xuICAgICAgJzonICsgbHooZC5nZXRVVENTZWNvbmRzKCkpICsgJy4nICsgKG0gPiA5OSA/IG0gOiAnMCcgKyBseihtKSkgKyAnWic7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9PYmplY3QgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gbmV3IERhdGUoTmFOKS50b0pTT04oKSAhPT0gbnVsbCB8fCBEYXRlLnByb3RvdHlwZS50b0pTT04uY2FsbCh7dG9JU09TdHJpbmc6IGZ1bmN0aW9uKCl7IHJldHVybiAxOyB9fSkgIT09IDE7XG59KSwgJ0RhdGUnLCB7XG4gIHRvSlNPTjogZnVuY3Rpb24gdG9KU09OKGtleSl7XG4gICAgdmFyIE8gID0gdG9PYmplY3QodGhpcylcbiAgICAgICwgcHYgPSB0b1ByaW1pdGl2ZShPKTtcbiAgICByZXR1cm4gdHlwZW9mIHB2ID09ICdudW1iZXInICYmICFpc0Zpbml0ZShwdikgPyBudWxsIDogTy50b0lTT1N0cmluZygpO1xuICB9XG59KTsiLCJ2YXIgVE9fUFJJTUlUSVZFID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvUHJpbWl0aXZlJylcbiAgLCBwcm90byAgICAgICAgPSBEYXRlLnByb3RvdHlwZTtcblxuaWYoIShUT19QUklNSVRJVkUgaW4gcHJvdG8pKXJlcXVpcmUoJy4vX2hpZGUnKShwcm90bywgVE9fUFJJTUlUSVZFLCByZXF1aXJlKCcuL19kYXRlLXRvLXByaW1pdGl2ZScpKTsiLCJ2YXIgRGF0ZVByb3RvICAgID0gRGF0ZS5wcm90b3R5cGVcbiAgLCBJTlZBTElEX0RBVEUgPSAnSW52YWxpZCBEYXRlJ1xuICAsIFRPX1NUUklORyAgICA9ICd0b1N0cmluZydcbiAgLCAkdG9TdHJpbmcgICAgPSBEYXRlUHJvdG9bVE9fU1RSSU5HXVxuICAsIGdldFRpbWUgICAgICA9IERhdGVQcm90by5nZXRUaW1lO1xuaWYobmV3IERhdGUoTmFOKSArICcnICE9IElOVkFMSURfREFURSl7XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoRGF0ZVByb3RvLCBUT19TVFJJTkcsIGZ1bmN0aW9uIHRvU3RyaW5nKCl7XG4gICAgdmFyIHZhbHVlID0gZ2V0VGltZS5jYWxsKHRoaXMpO1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgPyAkdG9TdHJpbmcuY2FsbCh0aGlzKSA6IElOVkFMSURfREFURTtcbiAgfSk7XG59IiwiLy8gMTkuMi4zLjIgLyAxNS4zLjQuNSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCh0aGlzQXJnLCBhcmdzLi4uKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdGdW5jdGlvbicsIHtiaW5kOiByZXF1aXJlKCcuL19iaW5kJyl9KTsiLCIndXNlIHN0cmljdCc7XG52YXIgaXNPYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgSEFTX0lOU1RBTkNFICAgPSByZXF1aXJlKCcuL193a3MnKSgnaGFzSW5zdGFuY2UnKVxuICAsIEZ1bmN0aW9uUHJvdG8gID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuLy8gMTkuMi4zLjYgRnVuY3Rpb24ucHJvdG90eXBlW0BAaGFzSW5zdGFuY2VdKFYpXG5pZighKEhBU19JTlNUQU5DRSBpbiBGdW5jdGlvblByb3RvKSlyZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mKEZ1bmN0aW9uUHJvdG8sIEhBU19JTlNUQU5DRSwge3ZhbHVlOiBmdW5jdGlvbihPKXtcbiAgaWYodHlwZW9mIHRoaXMgIT0gJ2Z1bmN0aW9uJyB8fCAhaXNPYmplY3QoTykpcmV0dXJuIGZhbHNlO1xuICBpZighaXNPYmplY3QodGhpcy5wcm90b3R5cGUpKXJldHVybiBPIGluc3RhbmNlb2YgdGhpcztcbiAgLy8gZm9yIGVudmlyb25tZW50IHcvbyBuYXRpdmUgYEBAaGFzSW5zdGFuY2VgIGxvZ2ljIGVub3VnaCBgaW5zdGFuY2VvZmAsIGJ1dCBhZGQgdGhpczpcbiAgd2hpbGUoTyA9IGdldFByb3RvdHlwZU9mKE8pKWlmKHRoaXMucHJvdG90eXBlID09PSBPKXJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59fSk7IiwidmFyIGRQICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mXG4gICwgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKVxuICAsIGhhcyAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIEZQcm90byAgICAgPSBGdW5jdGlvbi5wcm90b3R5cGVcbiAgLCBuYW1lUkUgICAgID0gL15cXHMqZnVuY3Rpb24gKFteIChdKikvXG4gICwgTkFNRSAgICAgICA9ICduYW1lJztcblxudmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgZnVuY3Rpb24oKXtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyAxOS4yLjQuMiBuYW1lXG5OQU1FIGluIEZQcm90byB8fCByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmIGRQKEZQcm90bywgTkFNRSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKXtcbiAgICB0cnkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgICAgICwgbmFtZSA9ICgnJyArIHRoYXQpLm1hdGNoKG5hbWVSRSlbMV07XG4gICAgICBoYXModGhhdCwgTkFNRSkgfHwgIWlzRXh0ZW5zaWJsZSh0aGF0KSB8fCBkUCh0aGF0LCBOQU1FLCBjcmVhdGVEZXNjKDUsIG5hbWUpKTtcbiAgICAgIHJldHVybiBuYW1lO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgc3Ryb25nID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi1zdHJvbmcnKTtcblxuLy8gMjMuMSBNYXAgT2JqZWN0c1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoJ01hcCcsIGZ1bmN0aW9uKGdldCl7XG4gIHJldHVybiBmdW5jdGlvbiBNYXAoKXsgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7IH07XG59LCB7XG4gIC8vIDIzLjEuMy42IE1hcC5wcm90b3R5cGUuZ2V0KGtleSlcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KXtcbiAgICB2YXIgZW50cnkgPSBzdHJvbmcuZ2V0RW50cnkodGhpcywga2V5KTtcbiAgICByZXR1cm4gZW50cnkgJiYgZW50cnkudjtcbiAgfSxcbiAgLy8gMjMuMS4zLjkgTWFwLnByb3RvdHlwZS5zZXQoa2V5LCB2YWx1ZSlcbiAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSl7XG4gICAgcmV0dXJuIHN0cm9uZy5kZWYodGhpcywga2V5ID09PSAwID8gMCA6IGtleSwgdmFsdWUpO1xuICB9XG59LCBzdHJvbmcsIHRydWUpOyIsIi8vIDIwLjIuMi4zIE1hdGguYWNvc2goeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBsb2cxcCAgID0gcmVxdWlyZSgnLi9fbWF0aC1sb2cxcCcpXG4gICwgc3FydCAgICA9IE1hdGguc3FydFxuICAsICRhY29zaCAgPSBNYXRoLmFjb3NoO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoJGFjb3NoXG4gIC8vIFY4IGJ1ZzogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTM1MDlcbiAgJiYgTWF0aC5mbG9vcigkYWNvc2goTnVtYmVyLk1BWF9WQUxVRSkpID09IDcxMFxuICAvLyBUb3IgQnJvd3NlciBidWc6IE1hdGguYWNvc2goSW5maW5pdHkpIC0+IE5hTiBcbiAgJiYgJGFjb3NoKEluZmluaXR5KSA9PSBJbmZpbml0eVxuKSwgJ01hdGgnLCB7XG4gIGFjb3NoOiBmdW5jdGlvbiBhY29zaCh4KXtcbiAgICByZXR1cm4gKHggPSAreCkgPCAxID8gTmFOIDogeCA+IDk0OTA2MjY1LjYyNDI1MTU2XG4gICAgICA/IE1hdGgubG9nKHgpICsgTWF0aC5MTjJcbiAgICAgIDogbG9nMXAoeCAtIDEgKyBzcXJ0KHggLSAxKSAqIHNxcnQoeCArIDEpKTtcbiAgfVxufSk7IiwiLy8gMjAuMi4yLjUgTWF0aC5hc2luaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRhc2luaCAgPSBNYXRoLmFzaW5oO1xuXG5mdW5jdGlvbiBhc2luaCh4KXtcbiAgcmV0dXJuICFpc0Zpbml0ZSh4ID0gK3gpIHx8IHggPT0gMCA/IHggOiB4IDwgMCA/IC1hc2luaCgteCkgOiBNYXRoLmxvZyh4ICsgTWF0aC5zcXJ0KHggKiB4ICsgMSkpO1xufVxuXG4vLyBUb3IgQnJvd3NlciBidWc6IE1hdGguYXNpbmgoMCkgLT4gLTAgXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoJGFzaW5oICYmIDEgLyAkYXNpbmgoMCkgPiAwKSwgJ01hdGgnLCB7YXNpbmg6IGFzaW5ofSk7IiwiLy8gMjAuMi4yLjcgTWF0aC5hdGFuaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRhdGFuaCAgPSBNYXRoLmF0YW5oO1xuXG4vLyBUb3IgQnJvd3NlciBidWc6IE1hdGguYXRhbmgoLTApIC0+IDAgXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoJGF0YW5oICYmIDEgLyAkYXRhbmgoLTApIDwgMCksICdNYXRoJywge1xuICBhdGFuaDogZnVuY3Rpb24gYXRhbmgoeCl7XG4gICAgcmV0dXJuICh4ID0gK3gpID09IDAgPyB4IDogTWF0aC5sb2coKDEgKyB4KSAvICgxIC0geCkpIC8gMjtcbiAgfVxufSk7IiwiLy8gMjAuMi4yLjkgTWF0aC5jYnJ0KHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgc2lnbiAgICA9IHJlcXVpcmUoJy4vX21hdGgtc2lnbicpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGNicnQ6IGZ1bmN0aW9uIGNicnQoeCl7XG4gICAgcmV0dXJuIHNpZ24oeCA9ICt4KSAqIE1hdGgucG93KE1hdGguYWJzKHgpLCAxIC8gMyk7XG4gIH1cbn0pOyIsIi8vIDIwLjIuMi4xMSBNYXRoLmNsejMyKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGNsejMyOiBmdW5jdGlvbiBjbHozMih4KXtcbiAgICByZXR1cm4gKHggPj4+PSAwKSA/IDMxIC0gTWF0aC5mbG9vcihNYXRoLmxvZyh4ICsgMC41KSAqIE1hdGguTE9HMkUpIDogMzI7XG4gIH1cbn0pOyIsIi8vIDIwLjIuMi4xMiBNYXRoLmNvc2goeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBleHAgICAgID0gTWF0aC5leHA7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgY29zaDogZnVuY3Rpb24gY29zaCh4KXtcbiAgICByZXR1cm4gKGV4cCh4ID0gK3gpICsgZXhwKC14KSkgLyAyO1xuICB9XG59KTsiLCIvLyAyMC4yLjIuMTQgTWF0aC5leHBtMSh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRleHBtMSAgPSByZXF1aXJlKCcuL19tYXRoLWV4cG0xJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCRleHBtMSAhPSBNYXRoLmV4cG0xKSwgJ01hdGgnLCB7ZXhwbTE6ICRleHBtMX0pOyIsIi8vIDIwLjIuMi4xNiBNYXRoLmZyb3VuZCh4KVxudmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgc2lnbiAgICAgID0gcmVxdWlyZSgnLi9fbWF0aC1zaWduJylcbiAgLCBwb3cgICAgICAgPSBNYXRoLnBvd1xuICAsIEVQU0lMT04gICA9IHBvdygyLCAtNTIpXG4gICwgRVBTSUxPTjMyID0gcG93KDIsIC0yMylcbiAgLCBNQVgzMiAgICAgPSBwb3coMiwgMTI3KSAqICgyIC0gRVBTSUxPTjMyKVxuICAsIE1JTjMyICAgICA9IHBvdygyLCAtMTI2KTtcblxudmFyIHJvdW5kVGllc1RvRXZlbiA9IGZ1bmN0aW9uKG4pe1xuICByZXR1cm4gbiArIDEgLyBFUFNJTE9OIC0gMSAvIEVQU0lMT047XG59O1xuXG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgZnJvdW5kOiBmdW5jdGlvbiBmcm91bmQoeCl7XG4gICAgdmFyICRhYnMgID0gTWF0aC5hYnMoeClcbiAgICAgICwgJHNpZ24gPSBzaWduKHgpXG4gICAgICAsIGEsIHJlc3VsdDtcbiAgICBpZigkYWJzIDwgTUlOMzIpcmV0dXJuICRzaWduICogcm91bmRUaWVzVG9FdmVuKCRhYnMgLyBNSU4zMiAvIEVQU0lMT04zMikgKiBNSU4zMiAqIEVQU0lMT04zMjtcbiAgICBhID0gKDEgKyBFUFNJTE9OMzIgLyBFUFNJTE9OKSAqICRhYnM7XG4gICAgcmVzdWx0ID0gYSAtIChhIC0gJGFicyk7XG4gICAgaWYocmVzdWx0ID4gTUFYMzIgfHwgcmVzdWx0ICE9IHJlc3VsdClyZXR1cm4gJHNpZ24gKiBJbmZpbml0eTtcbiAgICByZXR1cm4gJHNpZ24gKiByZXN1bHQ7XG4gIH1cbn0pOyIsIi8vIDIwLjIuMi4xNyBNYXRoLmh5cG90KFt2YWx1ZTFbLCB2YWx1ZTJbLCDigKYgXV1dKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGFicyAgICAgPSBNYXRoLmFicztcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBoeXBvdDogZnVuY3Rpb24gaHlwb3QodmFsdWUxLCB2YWx1ZTIpeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgdmFyIHN1bSAgPSAwXG4gICAgICAsIGkgICAgPSAwXG4gICAgICAsIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAsIGxhcmcgPSAwXG4gICAgICAsIGFyZywgZGl2O1xuICAgIHdoaWxlKGkgPCBhTGVuKXtcbiAgICAgIGFyZyA9IGFicyhhcmd1bWVudHNbaSsrXSk7XG4gICAgICBpZihsYXJnIDwgYXJnKXtcbiAgICAgICAgZGl2ICA9IGxhcmcgLyBhcmc7XG4gICAgICAgIHN1bSAgPSBzdW0gKiBkaXYgKiBkaXYgKyAxO1xuICAgICAgICBsYXJnID0gYXJnO1xuICAgICAgfSBlbHNlIGlmKGFyZyA+IDApe1xuICAgICAgICBkaXYgID0gYXJnIC8gbGFyZztcbiAgICAgICAgc3VtICs9IGRpdiAqIGRpdjtcbiAgICAgIH0gZWxzZSBzdW0gKz0gYXJnO1xuICAgIH1cbiAgICByZXR1cm4gbGFyZyA9PT0gSW5maW5pdHkgPyBJbmZpbml0eSA6IGxhcmcgKiBNYXRoLnNxcnQoc3VtKTtcbiAgfVxufSk7IiwiLy8gMjAuMi4yLjE4IE1hdGguaW11bCh4LCB5KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRpbXVsICAgPSBNYXRoLmltdWw7XG5cbi8vIHNvbWUgV2ViS2l0IHZlcnNpb25zIGZhaWxzIHdpdGggYmlnIG51bWJlcnMsIHNvbWUgaGFzIHdyb25nIGFyaXR5XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuICRpbXVsKDB4ZmZmZmZmZmYsIDUpICE9IC01IHx8ICRpbXVsLmxlbmd0aCAhPSAyO1xufSksICdNYXRoJywge1xuICBpbXVsOiBmdW5jdGlvbiBpbXVsKHgsIHkpe1xuICAgIHZhciBVSU5UMTYgPSAweGZmZmZcbiAgICAgICwgeG4gPSAreFxuICAgICAgLCB5biA9ICt5XG4gICAgICAsIHhsID0gVUlOVDE2ICYgeG5cbiAgICAgICwgeWwgPSBVSU5UMTYgJiB5bjtcbiAgICByZXR1cm4gMCB8IHhsICogeWwgKyAoKFVJTlQxNiAmIHhuID4+PiAxNikgKiB5bCArIHhsICogKFVJTlQxNiAmIHluID4+PiAxNikgPDwgMTYgPj4+IDApO1xuICB9XG59KTsiLCIvLyAyMC4yLjIuMjEgTWF0aC5sb2cxMCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBsb2cxMDogZnVuY3Rpb24gbG9nMTAoeCl7XG4gICAgcmV0dXJuIE1hdGgubG9nKHgpIC8gTWF0aC5MTjEwO1xuICB9XG59KTsiLCIvLyAyMC4yLjIuMjAgTWF0aC5sb2cxcCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge2xvZzFwOiByZXF1aXJlKCcuL19tYXRoLWxvZzFwJyl9KTsiLCIvLyAyMC4yLjIuMjIgTWF0aC5sb2cyKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGxvZzI6IGZ1bmN0aW9uIGxvZzIoeCl7XG4gICAgcmV0dXJuIE1hdGgubG9nKHgpIC8gTWF0aC5MTjI7XG4gIH1cbn0pOyIsIi8vIDIwLjIuMi4yOCBNYXRoLnNpZ24oeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtzaWduOiByZXF1aXJlKCcuL19tYXRoLXNpZ24nKX0pOyIsIi8vIDIwLjIuMi4zMCBNYXRoLnNpbmgoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBleHBtMSAgID0gcmVxdWlyZSgnLi9fbWF0aC1leHBtMScpXG4gICwgZXhwICAgICA9IE1hdGguZXhwO1xuXG4vLyBWOCBuZWFyIENocm9taXVtIDM4IGhhcyBhIHByb2JsZW0gd2l0aCB2ZXJ5IHNtYWxsIG51bWJlcnNcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gIU1hdGguc2luaCgtMmUtMTcpICE9IC0yZS0xNztcbn0pLCAnTWF0aCcsIHtcbiAgc2luaDogZnVuY3Rpb24gc2luaCh4KXtcbiAgICByZXR1cm4gTWF0aC5hYnMoeCA9ICt4KSA8IDFcbiAgICAgID8gKGV4cG0xKHgpIC0gZXhwbTEoLXgpKSAvIDJcbiAgICAgIDogKGV4cCh4IC0gMSkgLSBleHAoLXggLSAxKSkgKiAoTWF0aC5FIC8gMik7XG4gIH1cbn0pOyIsIi8vIDIwLjIuMi4zMyBNYXRoLnRhbmgoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBleHBtMSAgID0gcmVxdWlyZSgnLi9fbWF0aC1leHBtMScpXG4gICwgZXhwICAgICA9IE1hdGguZXhwO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIHRhbmg6IGZ1bmN0aW9uIHRhbmgoeCl7XG4gICAgdmFyIGEgPSBleHBtMSh4ID0gK3gpXG4gICAgICAsIGIgPSBleHBtMSgteCk7XG4gICAgcmV0dXJuIGEgPT0gSW5maW5pdHkgPyAxIDogYiA9PSBJbmZpbml0eSA/IC0xIDogKGEgLSBiKSAvIChleHAoeCkgKyBleHAoLXgpKTtcbiAgfVxufSk7IiwiLy8gMjAuMi4yLjM0IE1hdGgudHJ1bmMoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgdHJ1bmM6IGZ1bmN0aW9uIHRydW5jKGl0KXtcbiAgICByZXR1cm4gKGl0ID4gMCA/IE1hdGguZmxvb3IgOiBNYXRoLmNlaWwpKGl0KTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBoYXMgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgY29mICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jb2YnKVxuICAsIGluaGVyaXRJZlJlcXVpcmVkID0gcmVxdWlyZSgnLi9faW5oZXJpdC1pZi1yZXF1aXJlZCcpXG4gICwgdG9QcmltaXRpdmUgICAgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGZhaWxzICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIGdPUE4gICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mXG4gICwgZ09QRCAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmZcbiAgLCBkUCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCAkdHJpbSAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy10cmltJykudHJpbVxuICAsIE5VTUJFUiAgICAgICAgICAgID0gJ051bWJlcidcbiAgLCAkTnVtYmVyICAgICAgICAgICA9IGdsb2JhbFtOVU1CRVJdXG4gICwgQmFzZSAgICAgICAgICAgICAgPSAkTnVtYmVyXG4gICwgcHJvdG8gICAgICAgICAgICAgPSAkTnVtYmVyLnByb3RvdHlwZVxuICAvLyBPcGVyYSB+MTIgaGFzIGJyb2tlbiBPYmplY3QjdG9TdHJpbmdcbiAgLCBCUk9LRU5fQ09GICAgICAgICA9IGNvZihyZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJykocHJvdG8pKSA9PSBOVU1CRVJcbiAgLCBUUklNICAgICAgICAgICAgICA9ICd0cmltJyBpbiBTdHJpbmcucHJvdG90eXBlO1xuXG4vLyA3LjEuMyBUb051bWJlcihhcmd1bWVudClcbnZhciB0b051bWJlciA9IGZ1bmN0aW9uKGFyZ3VtZW50KXtcbiAgdmFyIGl0ID0gdG9QcmltaXRpdmUoYXJndW1lbnQsIGZhbHNlKTtcbiAgaWYodHlwZW9mIGl0ID09ICdzdHJpbmcnICYmIGl0Lmxlbmd0aCA+IDIpe1xuICAgIGl0ID0gVFJJTSA/IGl0LnRyaW0oKSA6ICR0cmltKGl0LCAzKTtcbiAgICB2YXIgZmlyc3QgPSBpdC5jaGFyQ29kZUF0KDApXG4gICAgICAsIHRoaXJkLCByYWRpeCwgbWF4Q29kZTtcbiAgICBpZihmaXJzdCA9PT0gNDMgfHwgZmlyc3QgPT09IDQ1KXtcbiAgICAgIHRoaXJkID0gaXQuY2hhckNvZGVBdCgyKTtcbiAgICAgIGlmKHRoaXJkID09PSA4OCB8fCB0aGlyZCA9PT0gMTIwKXJldHVybiBOYU47IC8vIE51bWJlcignKzB4MScpIHNob3VsZCBiZSBOYU4sIG9sZCBWOCBmaXhcbiAgICB9IGVsc2UgaWYoZmlyc3QgPT09IDQ4KXtcbiAgICAgIHN3aXRjaChpdC5jaGFyQ29kZUF0KDEpKXtcbiAgICAgICAgY2FzZSA2NiA6IGNhc2UgOTggIDogcmFkaXggPSAyOyBtYXhDb2RlID0gNDk7IGJyZWFrOyAvLyBmYXN0IGVxdWFsIC9eMGJbMDFdKyQvaVxuICAgICAgICBjYXNlIDc5IDogY2FzZSAxMTEgOiByYWRpeCA9IDg7IG1heENvZGUgPSA1NTsgYnJlYWs7IC8vIGZhc3QgZXF1YWwgL14wb1swLTddKyQvaVxuICAgICAgICBkZWZhdWx0IDogcmV0dXJuICtpdDtcbiAgICAgIH1cbiAgICAgIGZvcih2YXIgZGlnaXRzID0gaXQuc2xpY2UoMiksIGkgPSAwLCBsID0gZGlnaXRzLmxlbmd0aCwgY29kZTsgaSA8IGw7IGkrKyl7XG4gICAgICAgIGNvZGUgPSBkaWdpdHMuY2hhckNvZGVBdChpKTtcbiAgICAgICAgLy8gcGFyc2VJbnQgcGFyc2VzIGEgc3RyaW5nIHRvIGEgZmlyc3QgdW5hdmFpbGFibGUgc3ltYm9sXG4gICAgICAgIC8vIGJ1dCBUb051bWJlciBzaG91bGQgcmV0dXJuIE5hTiBpZiBhIHN0cmluZyBjb250YWlucyB1bmF2YWlsYWJsZSBzeW1ib2xzXG4gICAgICAgIGlmKGNvZGUgPCA0OCB8fCBjb2RlID4gbWF4Q29kZSlyZXR1cm4gTmFOO1xuICAgICAgfSByZXR1cm4gcGFyc2VJbnQoZGlnaXRzLCByYWRpeCk7XG4gICAgfVxuICB9IHJldHVybiAraXQ7XG59O1xuXG5pZighJE51bWJlcignIDBvMScpIHx8ICEkTnVtYmVyKCcwYjEnKSB8fCAkTnVtYmVyKCcrMHgxJykpe1xuICAkTnVtYmVyID0gZnVuY3Rpb24gTnVtYmVyKHZhbHVlKXtcbiAgICB2YXIgaXQgPSBhcmd1bWVudHMubGVuZ3RoIDwgMSA/IDAgOiB2YWx1ZVxuICAgICAgLCB0aGF0ID0gdGhpcztcbiAgICByZXR1cm4gdGhhdCBpbnN0YW5jZW9mICROdW1iZXJcbiAgICAgIC8vIGNoZWNrIG9uIDEuLmNvbnN0cnVjdG9yKGZvbykgY2FzZVxuICAgICAgJiYgKEJST0tFTl9DT0YgPyBmYWlscyhmdW5jdGlvbigpeyBwcm90by52YWx1ZU9mLmNhbGwodGhhdCk7IH0pIDogY29mKHRoYXQpICE9IE5VTUJFUilcbiAgICAgICAgPyBpbmhlcml0SWZSZXF1aXJlZChuZXcgQmFzZSh0b051bWJlcihpdCkpLCB0aGF0LCAkTnVtYmVyKSA6IHRvTnVtYmVyKGl0KTtcbiAgfTtcbiAgZm9yKHZhciBrZXlzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGdPUE4oQmFzZSkgOiAoXG4gICAgLy8gRVMzOlxuICAgICdNQVhfVkFMVUUsTUlOX1ZBTFVFLE5hTixORUdBVElWRV9JTkZJTklUWSxQT1NJVElWRV9JTkZJTklUWSwnICtcbiAgICAvLyBFUzYgKGluIGNhc2UsIGlmIG1vZHVsZXMgd2l0aCBFUzYgTnVtYmVyIHN0YXRpY3MgcmVxdWlyZWQgYmVmb3JlKTpcbiAgICAnRVBTSUxPTixpc0Zpbml0ZSxpc0ludGVnZXIsaXNOYU4saXNTYWZlSW50ZWdlcixNQVhfU0FGRV9JTlRFR0VSLCcgK1xuICAgICdNSU5fU0FGRV9JTlRFR0VSLHBhcnNlRmxvYXQscGFyc2VJbnQsaXNJbnRlZ2VyJ1xuICApLnNwbGl0KCcsJyksIGogPSAwLCBrZXk7IGtleXMubGVuZ3RoID4gajsgaisrKXtcbiAgICBpZihoYXMoQmFzZSwga2V5ID0ga2V5c1tqXSkgJiYgIWhhcygkTnVtYmVyLCBrZXkpKXtcbiAgICAgIGRQKCROdW1iZXIsIGtleSwgZ09QRChCYXNlLCBrZXkpKTtcbiAgICB9XG4gIH1cbiAgJE51bWJlci5wcm90b3R5cGUgPSBwcm90bztcbiAgcHJvdG8uY29uc3RydWN0b3IgPSAkTnVtYmVyO1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKGdsb2JhbCwgTlVNQkVSLCAkTnVtYmVyKTtcbn0iLCIvLyAyMC4xLjIuMSBOdW1iZXIuRVBTSUxPTlxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7RVBTSUxPTjogTWF0aC5wb3coMiwgLTUyKX0pOyIsIi8vIDIwLjEuMi4yIE51bWJlci5pc0Zpbml0ZShudW1iZXIpXG52YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBfaXNGaW5pdGUgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5pc0Zpbml0ZTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7XG4gIGlzRmluaXRlOiBmdW5jdGlvbiBpc0Zpbml0ZShpdCl7XG4gICAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnbnVtYmVyJyAmJiBfaXNGaW5pdGUoaXQpO1xuICB9XG59KTsiLCIvLyAyMC4xLjIuMyBOdW1iZXIuaXNJbnRlZ2VyKG51bWJlcilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge2lzSW50ZWdlcjogcmVxdWlyZSgnLi9faXMtaW50ZWdlcicpfSk7IiwiLy8gMjAuMS4yLjQgTnVtYmVyLmlzTmFOKG51bWJlcilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge1xuICBpc05hTjogZnVuY3Rpb24gaXNOYU4obnVtYmVyKXtcbiAgICByZXR1cm4gbnVtYmVyICE9IG51bWJlcjtcbiAgfVxufSk7IiwiLy8gMjAuMS4yLjUgTnVtYmVyLmlzU2FmZUludGVnZXIobnVtYmVyKVxudmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgaXNJbnRlZ2VyID0gcmVxdWlyZSgnLi9faXMtaW50ZWdlcicpXG4gICwgYWJzICAgICAgID0gTWF0aC5hYnM7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge1xuICBpc1NhZmVJbnRlZ2VyOiBmdW5jdGlvbiBpc1NhZmVJbnRlZ2VyKG51bWJlcil7XG4gICAgcmV0dXJuIGlzSW50ZWdlcihudW1iZXIpICYmIGFicyhudW1iZXIpIDw9IDB4MWZmZmZmZmZmZmZmZmY7XG4gIH1cbn0pOyIsIi8vIDIwLjEuMi42IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtNQVhfU0FGRV9JTlRFR0VSOiAweDFmZmZmZmZmZmZmZmZmfSk7IiwiLy8gMjAuMS4yLjEwIE51bWJlci5NSU5fU0FGRV9JTlRFR0VSXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtNSU5fU0FGRV9JTlRFR0VSOiAtMHgxZmZmZmZmZmZmZmZmZn0pOyIsInZhciAkZXhwb3J0ICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHBhcnNlRmxvYXQgPSByZXF1aXJlKCcuL19wYXJzZS1mbG9hdCcpO1xuLy8gMjAuMS4yLjEyIE51bWJlci5wYXJzZUZsb2F0KHN0cmluZylcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKE51bWJlci5wYXJzZUZsb2F0ICE9ICRwYXJzZUZsb2F0KSwgJ051bWJlcicsIHtwYXJzZUZsb2F0OiAkcGFyc2VGbG9hdH0pOyIsInZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRwYXJzZUludCA9IHJlcXVpcmUoJy4vX3BhcnNlLWludCcpO1xuLy8gMjAuMS4yLjEzIE51bWJlci5wYXJzZUludChzdHJpbmcsIHJhZGl4KVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTnVtYmVyLnBhcnNlSW50ICE9ICRwYXJzZUludCksICdOdW1iZXInLCB7cGFyc2VJbnQ6ICRwYXJzZUludH0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvSW50ZWdlciAgICA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIGFOdW1iZXJWYWx1ZSA9IHJlcXVpcmUoJy4vX2EtbnVtYmVyLXZhbHVlJylcbiAgLCByZXBlYXQgICAgICAgPSByZXF1aXJlKCcuL19zdHJpbmctcmVwZWF0JylcbiAgLCAkdG9GaXhlZCAgICAgPSAxLi50b0ZpeGVkXG4gICwgZmxvb3IgICAgICAgID0gTWF0aC5mbG9vclxuICAsIGRhdGEgICAgICAgICA9IFswLCAwLCAwLCAwLCAwLCAwXVxuICAsIEVSUk9SICAgICAgICA9ICdOdW1iZXIudG9GaXhlZDogaW5jb3JyZWN0IGludm9jYXRpb24hJ1xuICAsIFpFUk8gICAgICAgICA9ICcwJztcblxudmFyIG11bHRpcGx5ID0gZnVuY3Rpb24obiwgYyl7XG4gIHZhciBpICA9IC0xXG4gICAgLCBjMiA9IGM7XG4gIHdoaWxlKCsraSA8IDYpe1xuICAgIGMyICs9IG4gKiBkYXRhW2ldO1xuICAgIGRhdGFbaV0gPSBjMiAlIDFlNztcbiAgICBjMiA9IGZsb29yKGMyIC8gMWU3KTtcbiAgfVxufTtcbnZhciBkaXZpZGUgPSBmdW5jdGlvbihuKXtcbiAgdmFyIGkgPSA2XG4gICAgLCBjID0gMDtcbiAgd2hpbGUoLS1pID49IDApe1xuICAgIGMgKz0gZGF0YVtpXTtcbiAgICBkYXRhW2ldID0gZmxvb3IoYyAvIG4pO1xuICAgIGMgPSAoYyAlIG4pICogMWU3O1xuICB9XG59O1xudmFyIG51bVRvU3RyaW5nID0gZnVuY3Rpb24oKXtcbiAgdmFyIGkgPSA2XG4gICAgLCBzID0gJyc7XG4gIHdoaWxlKC0taSA+PSAwKXtcbiAgICBpZihzICE9PSAnJyB8fCBpID09PSAwIHx8IGRhdGFbaV0gIT09IDApe1xuICAgICAgdmFyIHQgPSBTdHJpbmcoZGF0YVtpXSk7XG4gICAgICBzID0gcyA9PT0gJycgPyB0IDogcyArIHJlcGVhdC5jYWxsKFpFUk8sIDcgLSB0Lmxlbmd0aCkgKyB0O1xuICAgIH1cbiAgfSByZXR1cm4gcztcbn07XG52YXIgcG93ID0gZnVuY3Rpb24oeCwgbiwgYWNjKXtcbiAgcmV0dXJuIG4gPT09IDAgPyBhY2MgOiBuICUgMiA9PT0gMSA/IHBvdyh4LCBuIC0gMSwgYWNjICogeCkgOiBwb3coeCAqIHgsIG4gLyAyLCBhY2MpO1xufTtcbnZhciBsb2cgPSBmdW5jdGlvbih4KXtcbiAgdmFyIG4gID0gMFxuICAgICwgeDIgPSB4O1xuICB3aGlsZSh4MiA+PSA0MDk2KXtcbiAgICBuICs9IDEyO1xuICAgIHgyIC89IDQwOTY7XG4gIH1cbiAgd2hpbGUoeDIgPj0gMil7XG4gICAgbiAgKz0gMTtcbiAgICB4MiAvPSAyO1xuICB9IHJldHVybiBuO1xufTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoISEkdG9GaXhlZCAmJiAoXG4gIDAuMDAwMDgudG9GaXhlZCgzKSAhPT0gJzAuMDAwJyB8fFxuICAwLjkudG9GaXhlZCgwKSAhPT0gJzEnIHx8XG4gIDEuMjU1LnRvRml4ZWQoMikgIT09ICcxLjI1JyB8fFxuICAxMDAwMDAwMDAwMDAwMDAwMTI4Li50b0ZpeGVkKDApICE9PSAnMTAwMDAwMDAwMDAwMDAwMDEyOCdcbikgfHwgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgLy8gVjggfiBBbmRyb2lkIDQuMy1cbiAgJHRvRml4ZWQuY2FsbCh7fSk7XG59KSksICdOdW1iZXInLCB7XG4gIHRvRml4ZWQ6IGZ1bmN0aW9uIHRvRml4ZWQoZnJhY3Rpb25EaWdpdHMpe1xuICAgIHZhciB4ID0gYU51bWJlclZhbHVlKHRoaXMsIEVSUk9SKVxuICAgICAgLCBmID0gdG9JbnRlZ2VyKGZyYWN0aW9uRGlnaXRzKVxuICAgICAgLCBzID0gJydcbiAgICAgICwgbSA9IFpFUk9cbiAgICAgICwgZSwgeiwgaiwgaztcbiAgICBpZihmIDwgMCB8fCBmID4gMjApdGhyb3cgUmFuZ2VFcnJvcihFUlJPUik7XG4gICAgaWYoeCAhPSB4KXJldHVybiAnTmFOJztcbiAgICBpZih4IDw9IC0xZTIxIHx8IHggPj0gMWUyMSlyZXR1cm4gU3RyaW5nKHgpO1xuICAgIGlmKHggPCAwKXtcbiAgICAgIHMgPSAnLSc7XG4gICAgICB4ID0gLXg7XG4gICAgfVxuICAgIGlmKHggPiAxZS0yMSl7XG4gICAgICBlID0gbG9nKHggKiBwb3coMiwgNjksIDEpKSAtIDY5O1xuICAgICAgeiA9IGUgPCAwID8geCAqIHBvdygyLCAtZSwgMSkgOiB4IC8gcG93KDIsIGUsIDEpO1xuICAgICAgeiAqPSAweDEwMDAwMDAwMDAwMDAwO1xuICAgICAgZSA9IDUyIC0gZTtcbiAgICAgIGlmKGUgPiAwKXtcbiAgICAgICAgbXVsdGlwbHkoMCwgeik7XG4gICAgICAgIGogPSBmO1xuICAgICAgICB3aGlsZShqID49IDcpe1xuICAgICAgICAgIG11bHRpcGx5KDFlNywgMCk7XG4gICAgICAgICAgaiAtPSA3O1xuICAgICAgICB9XG4gICAgICAgIG11bHRpcGx5KHBvdygxMCwgaiwgMSksIDApO1xuICAgICAgICBqID0gZSAtIDE7XG4gICAgICAgIHdoaWxlKGogPj0gMjMpe1xuICAgICAgICAgIGRpdmlkZSgxIDw8IDIzKTtcbiAgICAgICAgICBqIC09IDIzO1xuICAgICAgICB9XG4gICAgICAgIGRpdmlkZSgxIDw8IGopO1xuICAgICAgICBtdWx0aXBseSgxLCAxKTtcbiAgICAgICAgZGl2aWRlKDIpO1xuICAgICAgICBtID0gbnVtVG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG11bHRpcGx5KDAsIHopO1xuICAgICAgICBtdWx0aXBseSgxIDw8IC1lLCAwKTtcbiAgICAgICAgbSA9IG51bVRvU3RyaW5nKCkgKyByZXBlYXQuY2FsbChaRVJPLCBmKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYoZiA+IDApe1xuICAgICAgayA9IG0ubGVuZ3RoO1xuICAgICAgbSA9IHMgKyAoayA8PSBmID8gJzAuJyArIHJlcGVhdC5jYWxsKFpFUk8sIGYgLSBrKSArIG0gOiBtLnNsaWNlKDAsIGsgLSBmKSArICcuJyArIG0uc2xpY2UoayAtIGYpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHMgKyBtO1xuICAgIH0gcmV0dXJuIG07XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRmYWlscyAgICAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCBhTnVtYmVyVmFsdWUgPSByZXF1aXJlKCcuL19hLW51bWJlci12YWx1ZScpXG4gICwgJHRvUHJlY2lzaW9uID0gMS4udG9QcmVjaXNpb247XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKCRmYWlscyhmdW5jdGlvbigpe1xuICAvLyBJRTctXG4gIHJldHVybiAkdG9QcmVjaXNpb24uY2FsbCgxLCB1bmRlZmluZWQpICE9PSAnMSc7XG59KSB8fCAhJGZhaWxzKGZ1bmN0aW9uKCl7XG4gIC8vIFY4IH4gQW5kcm9pZCA0LjMtXG4gICR0b1ByZWNpc2lvbi5jYWxsKHt9KTtcbn0pKSwgJ051bWJlcicsIHtcbiAgdG9QcmVjaXNpb246IGZ1bmN0aW9uIHRvUHJlY2lzaW9uKHByZWNpc2lvbil7XG4gICAgdmFyIHRoYXQgPSBhTnVtYmVyVmFsdWUodGhpcywgJ051bWJlciN0b1ByZWNpc2lvbjogaW5jb3JyZWN0IGludm9jYXRpb24hJyk7XG4gICAgcmV0dXJuIHByZWNpc2lvbiA9PT0gdW5kZWZpbmVkID8gJHRvUHJlY2lzaW9uLmNhbGwodGhhdCkgOiAkdG9QcmVjaXNpb24uY2FsbCh0aGF0LCBwcmVjaXNpb24pOyBcbiAgfVxufSk7IiwiLy8gMTkuMS4zLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GLCAnT2JqZWN0Jywge2Fzc2lnbjogcmVxdWlyZSgnLi9fb2JqZWN0LWFzc2lnbicpfSk7IiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtjcmVhdGU6IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKX0pOyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4vLyAxOS4xLjIuMyAvIDE1LjIuMy43IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpLCAnT2JqZWN0Jywge2RlZmluZVByb3BlcnRpZXM6IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKX0pOyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4vLyAxOS4xLjIuNCAvIDE1LjIuMy42IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSwgJ09iamVjdCcsIHtkZWZpbmVQcm9wZXJ0eTogcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZn0pOyIsIi8vIDE5LjEuMi41IE9iamVjdC5mcmVlemUoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgbWV0YSAgICAgPSByZXF1aXJlKCcuL19tZXRhJykub25GcmVlemU7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnZnJlZXplJywgZnVuY3Rpb24oJGZyZWV6ZSl7XG4gIHJldHVybiBmdW5jdGlvbiBmcmVlemUoaXQpe1xuICAgIHJldHVybiAkZnJlZXplICYmIGlzT2JqZWN0KGl0KSA/ICRmcmVlemUobWV0YShpdCkpIDogaXQ7XG4gIH07XG59KTsiLCIvLyAxOS4xLjIuNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApXG52YXIgdG9JT2JqZWN0ICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmY7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJywgZnVuY3Rpb24oKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KXtcbiAgICByZXR1cm4gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0b0lPYmplY3QoaXQpLCBrZXkpO1xuICB9O1xufSk7IiwiLy8gMTkuMS4yLjcgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnZ2V0T3duUHJvcGVydHlOYW1lcycsIGZ1bmN0aW9uKCl7XG4gIHJldHVybiByZXF1aXJlKCcuL19vYmplY3QtZ29wbi1leHQnKS5mO1xufSk7IiwiLy8gMTkuMS4yLjkgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgdG9PYmplY3QgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCAkZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnZ2V0UHJvdG90eXBlT2YnLCBmdW5jdGlvbigpe1xuICByZXR1cm4gZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2YoaXQpe1xuICAgIHJldHVybiAkZ2V0UHJvdG90eXBlT2YodG9PYmplY3QoaXQpKTtcbiAgfTtcbn0pOyIsIi8vIDE5LjEuMi4xMSBPYmplY3QuaXNFeHRlbnNpYmxlKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdpc0V4dGVuc2libGUnLCBmdW5jdGlvbigkaXNFeHRlbnNpYmxlKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGlzRXh0ZW5zaWJsZShpdCl7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/ICRpc0V4dGVuc2libGUgPyAkaXNFeHRlbnNpYmxlKGl0KSA6IHRydWUgOiBmYWxzZTtcbiAgfTtcbn0pOyIsIi8vIDE5LjEuMi4xMiBPYmplY3QuaXNGcm96ZW4oTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2lzRnJvemVuJywgZnVuY3Rpb24oJGlzRnJvemVuKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGlzRnJvemVuKGl0KXtcbiAgICByZXR1cm4gaXNPYmplY3QoaXQpID8gJGlzRnJvemVuID8gJGlzRnJvemVuKGl0KSA6IGZhbHNlIDogdHJ1ZTtcbiAgfTtcbn0pOyIsIi8vIDE5LjEuMi4xMyBPYmplY3QuaXNTZWFsZWQoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2lzU2VhbGVkJywgZnVuY3Rpb24oJGlzU2VhbGVkKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGlzU2VhbGVkKGl0KXtcbiAgICByZXR1cm4gaXNPYmplY3QoaXQpID8gJGlzU2VhbGVkID8gJGlzU2VhbGVkKGl0KSA6IGZhbHNlIDogdHJ1ZTtcbiAgfTtcbn0pOyIsIi8vIDE5LjEuMy4xMCBPYmplY3QuaXModmFsdWUxLCB2YWx1ZTIpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7aXM6IHJlcXVpcmUoJy4vX3NhbWUtdmFsdWUnKX0pOyIsIi8vIDE5LjEuMi4xNCBPYmplY3Qua2V5cyhPKVxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCAka2V5cyAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgna2V5cycsIGZ1bmN0aW9uKCl7XG4gIHJldHVybiBmdW5jdGlvbiBrZXlzKGl0KXtcbiAgICByZXR1cm4gJGtleXModG9PYmplY3QoaXQpKTtcbiAgfTtcbn0pOyIsIi8vIDE5LjEuMi4xNSBPYmplY3QucHJldmVudEV4dGVuc2lvbnMoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgbWV0YSAgICAgPSByZXF1aXJlKCcuL19tZXRhJykub25GcmVlemU7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgncHJldmVudEV4dGVuc2lvbnMnLCBmdW5jdGlvbigkcHJldmVudEV4dGVuc2lvbnMpe1xuICByZXR1cm4gZnVuY3Rpb24gcHJldmVudEV4dGVuc2lvbnMoaXQpe1xuICAgIHJldHVybiAkcHJldmVudEV4dGVuc2lvbnMgJiYgaXNPYmplY3QoaXQpID8gJHByZXZlbnRFeHRlbnNpb25zKG1ldGEoaXQpKSA6IGl0O1xuICB9O1xufSk7IiwiLy8gMTkuMS4yLjE3IE9iamVjdC5zZWFsKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIG1ldGEgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpLm9uRnJlZXplO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ3NlYWwnLCBmdW5jdGlvbigkc2VhbCl7XG4gIHJldHVybiBmdW5jdGlvbiBzZWFsKGl0KXtcbiAgICByZXR1cm4gJHNlYWwgJiYgaXNPYmplY3QoaXQpID8gJHNlYWwobWV0YShpdCkpIDogaXQ7XG4gIH07XG59KTsiLCIvLyAxOS4xLjMuMTkgT2JqZWN0LnNldFByb3RvdHlwZU9mKE8sIHByb3RvKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge3NldFByb3RvdHlwZU9mOiByZXF1aXJlKCcuL19zZXQtcHJvdG8nKS5zZXR9KTsiLCIndXNlIHN0cmljdCc7XG4vLyAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpXG4gICwgdGVzdCAgICA9IHt9O1xudGVzdFtyZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKV0gPSAneic7XG5pZih0ZXN0ICsgJycgIT0gJ1tvYmplY3Qgel0nKXtcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShPYmplY3QucHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIHJldHVybiAnW29iamVjdCAnICsgY2xhc3NvZih0aGlzKSArICddJztcbiAgfSwgdHJ1ZSk7XG59IiwidmFyICRleHBvcnQgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkcGFyc2VGbG9hdCA9IHJlcXVpcmUoJy4vX3BhcnNlLWZsb2F0Jyk7XG4vLyAxOC4yLjQgcGFyc2VGbG9hdChzdHJpbmcpXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuRiAqIChwYXJzZUZsb2F0ICE9ICRwYXJzZUZsb2F0KSwge3BhcnNlRmxvYXQ6ICRwYXJzZUZsb2F0fSk7IiwidmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHBhcnNlSW50ID0gcmVxdWlyZSgnLi9fcGFyc2UtaW50Jyk7XG4vLyAxOC4yLjUgcGFyc2VJbnQoc3RyaW5nLCByYWRpeClcbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5GICogKHBhcnNlSW50ICE9ICRwYXJzZUludCksIHtwYXJzZUludDogJHBhcnNlSW50fSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKVxuICAsIGdsb2JhbCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgY3R4ICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBjbGFzc29mICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jbGFzc29mJylcbiAgLCAkZXhwb3J0ICAgICAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGlzT2JqZWN0ICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgYUZ1bmN0aW9uICAgICAgICAgID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgYW5JbnN0YW5jZSAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKVxuICAsIGZvck9mICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2Zvci1vZicpXG4gICwgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpXG4gICwgdGFzayAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdGFzaycpLnNldFxuICAsIG1pY3JvdGFzayAgICAgICAgICA9IHJlcXVpcmUoJy4vX21pY3JvdGFzaycpKClcbiAgLCBQUk9NSVNFICAgICAgICAgICAgPSAnUHJvbWlzZSdcbiAgLCBUeXBlRXJyb3IgICAgICAgICAgPSBnbG9iYWwuVHlwZUVycm9yXG4gICwgcHJvY2VzcyAgICAgICAgICAgID0gZ2xvYmFsLnByb2Nlc3NcbiAgLCAkUHJvbWlzZSAgICAgICAgICAgPSBnbG9iYWxbUFJPTUlTRV1cbiAgLCBwcm9jZXNzICAgICAgICAgICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIGlzTm9kZSAgICAgICAgICAgICA9IGNsYXNzb2YocHJvY2VzcykgPT0gJ3Byb2Nlc3MnXG4gICwgZW1wdHkgICAgICAgICAgICAgID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfVxuICAsIEludGVybmFsLCBHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHksIFdyYXBwZXI7XG5cbnZhciBVU0VfTkFUSVZFID0gISFmdW5jdGlvbigpe1xuICB0cnkge1xuICAgIC8vIGNvcnJlY3Qgc3ViY2xhc3Npbmcgd2l0aCBAQHNwZWNpZXMgc3VwcG9ydFxuICAgIHZhciBwcm9taXNlICAgICA9ICRQcm9taXNlLnJlc29sdmUoMSlcbiAgICAgICwgRmFrZVByb21pc2UgPSAocHJvbWlzZS5jb25zdHJ1Y3RvciA9IHt9KVtyZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpXSA9IGZ1bmN0aW9uKGV4ZWMpeyBleGVjKGVtcHR5LCBlbXB0eSk7IH07XG4gICAgLy8gdW5oYW5kbGVkIHJlamVjdGlvbnMgdHJhY2tpbmcgc3VwcG9ydCwgTm9kZUpTIFByb21pc2Ugd2l0aG91dCBpdCBmYWlscyBAQHNwZWNpZXMgdGVzdFxuICAgIHJldHVybiAoaXNOb2RlIHx8IHR5cGVvZiBQcm9taXNlUmVqZWN0aW9uRXZlbnQgPT0gJ2Z1bmN0aW9uJykgJiYgcHJvbWlzZS50aGVuKGVtcHR5KSBpbnN0YW5jZW9mIEZha2VQcm9taXNlO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG59KCk7XG5cbi8vIGhlbHBlcnNcbnZhciBzYW1lQ29uc3RydWN0b3IgPSBmdW5jdGlvbihhLCBiKXtcbiAgLy8gd2l0aCBsaWJyYXJ5IHdyYXBwZXIgc3BlY2lhbCBjYXNlXG4gIHJldHVybiBhID09PSBiIHx8IGEgPT09ICRQcm9taXNlICYmIGIgPT09IFdyYXBwZXI7XG59O1xudmFyIGlzVGhlbmFibGUgPSBmdW5jdGlvbihpdCl7XG4gIHZhciB0aGVuO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmIHR5cGVvZiAodGhlbiA9IGl0LnRoZW4pID09ICdmdW5jdGlvbicgPyB0aGVuIDogZmFsc2U7XG59O1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24oQyl7XG4gIHJldHVybiBzYW1lQ29uc3RydWN0b3IoJFByb21pc2UsIEMpXG4gICAgPyBuZXcgUHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICA6IG5ldyBHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG59O1xudmFyIFByb21pc2VDYXBhYmlsaXR5ID0gR2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24oQyl7XG4gIHZhciByZXNvbHZlLCByZWplY3Q7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBDKGZ1bmN0aW9uKCQkcmVzb2x2ZSwgJCRyZWplY3Qpe1xuICAgIGlmKHJlc29sdmUgIT09IHVuZGVmaW5lZCB8fCByZWplY3QgIT09IHVuZGVmaW5lZCl0aHJvdyBUeXBlRXJyb3IoJ0JhZCBQcm9taXNlIGNvbnN0cnVjdG9yJyk7XG4gICAgcmVzb2x2ZSA9ICQkcmVzb2x2ZTtcbiAgICByZWplY3QgID0gJCRyZWplY3Q7XG4gIH0pO1xuICB0aGlzLnJlc29sdmUgPSBhRnVuY3Rpb24ocmVzb2x2ZSk7XG4gIHRoaXMucmVqZWN0ICA9IGFGdW5jdGlvbihyZWplY3QpO1xufTtcbnZhciBwZXJmb3JtID0gZnVuY3Rpb24oZXhlYyl7XG4gIHRyeSB7XG4gICAgZXhlYygpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB7ZXJyb3I6IGV9O1xuICB9XG59O1xudmFyIG5vdGlmeSA9IGZ1bmN0aW9uKHByb21pc2UsIGlzUmVqZWN0KXtcbiAgaWYocHJvbWlzZS5fbilyZXR1cm47XG4gIHByb21pc2UuX24gPSB0cnVlO1xuICB2YXIgY2hhaW4gPSBwcm9taXNlLl9jO1xuICBtaWNyb3Rhc2soZnVuY3Rpb24oKXtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92XG4gICAgICAsIG9rICAgID0gcHJvbWlzZS5fcyA9PSAxXG4gICAgICAsIGkgICAgID0gMDtcbiAgICB2YXIgcnVuID0gZnVuY3Rpb24ocmVhY3Rpb24pe1xuICAgICAgdmFyIGhhbmRsZXIgPSBvayA/IHJlYWN0aW9uLm9rIDogcmVhY3Rpb24uZmFpbFxuICAgICAgICAsIHJlc29sdmUgPSByZWFjdGlvbi5yZXNvbHZlXG4gICAgICAgICwgcmVqZWN0ICA9IHJlYWN0aW9uLnJlamVjdFxuICAgICAgICAsIGRvbWFpbiAgPSByZWFjdGlvbi5kb21haW5cbiAgICAgICAgLCByZXN1bHQsIHRoZW47XG4gICAgICB0cnkge1xuICAgICAgICBpZihoYW5kbGVyKXtcbiAgICAgICAgICBpZighb2spe1xuICAgICAgICAgICAgaWYocHJvbWlzZS5faCA9PSAyKW9uSGFuZGxlVW5oYW5kbGVkKHByb21pc2UpO1xuICAgICAgICAgICAgcHJvbWlzZS5faCA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKGhhbmRsZXIgPT09IHRydWUpcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZihkb21haW4pZG9tYWluLmVudGVyKCk7XG4gICAgICAgICAgICByZXN1bHQgPSBoYW5kbGVyKHZhbHVlKTtcbiAgICAgICAgICAgIGlmKGRvbWFpbilkb21haW4uZXhpdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZihyZXN1bHQgPT09IHJlYWN0aW9uLnByb21pc2Upe1xuICAgICAgICAgICAgcmVqZWN0KFR5cGVFcnJvcignUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgICAgICB9IGVsc2UgaWYodGhlbiA9IGlzVGhlbmFibGUocmVzdWx0KSl7XG4gICAgICAgICAgICB0aGVuLmNhbGwocmVzdWx0LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSByZWplY3QodmFsdWUpO1xuICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgd2hpbGUoY2hhaW4ubGVuZ3RoID4gaSlydW4oY2hhaW5baSsrXSk7IC8vIHZhcmlhYmxlIGxlbmd0aCAtIGNhbid0IHVzZSBmb3JFYWNoXG4gICAgcHJvbWlzZS5fYyA9IFtdO1xuICAgIHByb21pc2UuX24gPSBmYWxzZTtcbiAgICBpZihpc1JlamVjdCAmJiAhcHJvbWlzZS5faClvblVuaGFuZGxlZChwcm9taXNlKTtcbiAgfSk7XG59O1xudmFyIG9uVW5oYW5kbGVkID0gZnVuY3Rpb24ocHJvbWlzZSl7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIHZhbHVlID0gcHJvbWlzZS5fdlxuICAgICAgLCBhYnJ1cHQsIGhhbmRsZXIsIGNvbnNvbGU7XG4gICAgaWYoaXNVbmhhbmRsZWQocHJvbWlzZSkpe1xuICAgICAgYWJydXB0ID0gcGVyZm9ybShmdW5jdGlvbigpe1xuICAgICAgICBpZihpc05vZGUpe1xuICAgICAgICAgIHByb2Nlc3MuZW1pdCgndW5oYW5kbGVkUmVqZWN0aW9uJywgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9IGVsc2UgaWYoaGFuZGxlciA9IGdsb2JhbC5vbnVuaGFuZGxlZHJlamVjdGlvbil7XG4gICAgICAgICAgaGFuZGxlcih7cHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiB2YWx1ZX0pO1xuICAgICAgICB9IGVsc2UgaWYoKGNvbnNvbGUgPSBnbG9iYWwuY29uc29sZSkgJiYgY29uc29sZS5lcnJvcil7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uJywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIEJyb3dzZXJzIHNob3VsZCBub3QgdHJpZ2dlciBgcmVqZWN0aW9uSGFuZGxlZGAgZXZlbnQgaWYgaXQgd2FzIGhhbmRsZWQgaGVyZSwgTm9kZUpTIC0gc2hvdWxkXG4gICAgICBwcm9taXNlLl9oID0gaXNOb2RlIHx8IGlzVW5oYW5kbGVkKHByb21pc2UpID8gMiA6IDE7XG4gICAgfSBwcm9taXNlLl9hID0gdW5kZWZpbmVkO1xuICAgIGlmKGFicnVwdCl0aHJvdyBhYnJ1cHQuZXJyb3I7XG4gIH0pO1xufTtcbnZhciBpc1VuaGFuZGxlZCA9IGZ1bmN0aW9uKHByb21pc2Upe1xuICBpZihwcm9taXNlLl9oID09IDEpcmV0dXJuIGZhbHNlO1xuICB2YXIgY2hhaW4gPSBwcm9taXNlLl9hIHx8IHByb21pc2UuX2NcbiAgICAsIGkgICAgID0gMFxuICAgICwgcmVhY3Rpb247XG4gIHdoaWxlKGNoYWluLmxlbmd0aCA+IGkpe1xuICAgIHJlYWN0aW9uID0gY2hhaW5baSsrXTtcbiAgICBpZihyZWFjdGlvbi5mYWlsIHx8ICFpc1VuaGFuZGxlZChyZWFjdGlvbi5wcm9taXNlKSlyZXR1cm4gZmFsc2U7XG4gIH0gcmV0dXJuIHRydWU7XG59O1xudmFyIG9uSGFuZGxlVW5oYW5kbGVkID0gZnVuY3Rpb24ocHJvbWlzZSl7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIGhhbmRsZXI7XG4gICAgaWYoaXNOb2RlKXtcbiAgICAgIHByb2Nlc3MuZW1pdCgncmVqZWN0aW9uSGFuZGxlZCcsIHByb21pc2UpO1xuICAgIH0gZWxzZSBpZihoYW5kbGVyID0gZ2xvYmFsLm9ucmVqZWN0aW9uaGFuZGxlZCl7XG4gICAgICBoYW5kbGVyKHtwcm9taXNlOiBwcm9taXNlLCByZWFzb246IHByb21pc2UuX3Z9KTtcbiAgICB9XG4gIH0pO1xufTtcbnZhciAkcmVqZWN0ID0gZnVuY3Rpb24odmFsdWUpe1xuICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gIGlmKHByb21pc2UuX2QpcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgcHJvbWlzZS5fcyA9IDI7XG4gIGlmKCFwcm9taXNlLl9hKXByb21pc2UuX2EgPSBwcm9taXNlLl9jLnNsaWNlKCk7XG4gIG5vdGlmeShwcm9taXNlLCB0cnVlKTtcbn07XG52YXIgJHJlc29sdmUgPSBmdW5jdGlvbih2YWx1ZSl7XG4gIHZhciBwcm9taXNlID0gdGhpc1xuICAgICwgdGhlbjtcbiAgaWYocHJvbWlzZS5fZClyZXR1cm47XG4gIHByb21pc2UuX2QgPSB0cnVlO1xuICBwcm9taXNlID0gcHJvbWlzZS5fdyB8fCBwcm9taXNlOyAvLyB1bndyYXBcbiAgdHJ5IHtcbiAgICBpZihwcm9taXNlID09PSB2YWx1ZSl0aHJvdyBUeXBlRXJyb3IoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZlwiKTtcbiAgICBpZih0aGVuID0gaXNUaGVuYWJsZSh2YWx1ZSkpe1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciB3cmFwcGVyID0ge193OiBwcm9taXNlLCBfZDogZmFsc2V9OyAvLyB3cmFwXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhlbi5jYWxsKHZhbHVlLCBjdHgoJHJlc29sdmUsIHdyYXBwZXIsIDEpLCBjdHgoJHJlamVjdCwgd3JhcHBlciwgMSkpO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICRyZWplY3QuY2FsbCh3cmFwcGVyLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgICAgIHByb21pc2UuX3MgPSAxO1xuICAgICAgbm90aWZ5KHByb21pc2UsIGZhbHNlKTtcbiAgICB9XG4gIH0gY2F0Y2goZSl7XG4gICAgJHJlamVjdC5jYWxsKHtfdzogcHJvbWlzZSwgX2Q6IGZhbHNlfSwgZSk7IC8vIHdyYXBcbiAgfVxufTtcblxuLy8gY29uc3RydWN0b3IgcG9seWZpbGxcbmlmKCFVU0VfTkFUSVZFKXtcbiAgLy8gMjUuNC4zLjEgUHJvbWlzZShleGVjdXRvcilcbiAgJFByb21pc2UgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKXtcbiAgICBhbkluc3RhbmNlKHRoaXMsICRQcm9taXNlLCBQUk9NSVNFLCAnX2gnKTtcbiAgICBhRnVuY3Rpb24oZXhlY3V0b3IpO1xuICAgIEludGVybmFsLmNhbGwodGhpcyk7XG4gICAgdHJ5IHtcbiAgICAgIGV4ZWN1dG9yKGN0eCgkcmVzb2x2ZSwgdGhpcywgMSksIGN0eCgkcmVqZWN0LCB0aGlzLCAxKSk7XG4gICAgfSBjYXRjaChlcnIpe1xuICAgICAgJHJlamVjdC5jYWxsKHRoaXMsIGVycik7XG4gICAgfVxuICB9O1xuICBJbnRlcm5hbCA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3Ipe1xuICAgIHRoaXMuX2MgPSBbXTsgICAgICAgICAgICAgLy8gPC0gYXdhaXRpbmcgcmVhY3Rpb25zXG4gICAgdGhpcy5fYSA9IHVuZGVmaW5lZDsgICAgICAvLyA8LSBjaGVja2VkIGluIGlzVW5oYW5kbGVkIHJlYWN0aW9uc1xuICAgIHRoaXMuX3MgPSAwOyAgICAgICAgICAgICAgLy8gPC0gc3RhdGVcbiAgICB0aGlzLl9kID0gZmFsc2U7ICAgICAgICAgIC8vIDwtIGRvbmVcbiAgICB0aGlzLl92ID0gdW5kZWZpbmVkOyAgICAgIC8vIDwtIHZhbHVlXG4gICAgdGhpcy5faCA9IDA7ICAgICAgICAgICAgICAvLyA8LSByZWplY3Rpb24gc3RhdGUsIDAgLSBkZWZhdWx0LCAxIC0gaGFuZGxlZCwgMiAtIHVuaGFuZGxlZFxuICAgIHRoaXMuX24gPSBmYWxzZTsgICAgICAgICAgLy8gPC0gbm90aWZ5XG4gIH07XG4gIEludGVybmFsLnByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpKCRQcm9taXNlLnByb3RvdHlwZSwge1xuICAgIC8vIDI1LjQuNS4zIFByb21pc2UucHJvdG90eXBlLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpXG4gICAgdGhlbjogZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCl7XG4gICAgICB2YXIgcmVhY3Rpb24gICAgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgJFByb21pc2UpKTtcbiAgICAgIHJlYWN0aW9uLm9rICAgICA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiB0cnVlO1xuICAgICAgcmVhY3Rpb24uZmFpbCAgID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT0gJ2Z1bmN0aW9uJyAmJiBvblJlamVjdGVkO1xuICAgICAgcmVhY3Rpb24uZG9tYWluID0gaXNOb2RlID8gcHJvY2Vzcy5kb21haW4gOiB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9jLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYodGhpcy5fYSl0aGlzLl9hLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYodGhpcy5fcylub3RpZnkodGhpcywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHJlYWN0aW9uLnByb21pc2U7XG4gICAgfSxcbiAgICAvLyAyNS40LjUuMSBQcm9taXNlLnByb3RvdHlwZS5jYXRjaChvblJlamVjdGVkKVxuICAgICdjYXRjaCc6IGZ1bmN0aW9uKG9uUmVqZWN0ZWQpe1xuICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH1cbiAgfSk7XG4gIFByb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgcHJvbWlzZSAgPSBuZXcgSW50ZXJuYWw7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICB0aGlzLnJlc29sdmUgPSBjdHgoJHJlc29sdmUsIHByb21pc2UsIDEpO1xuICAgIHRoaXMucmVqZWN0ICA9IGN0eCgkcmVqZWN0LCBwcm9taXNlLCAxKTtcbiAgfTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwge1Byb21pc2U6ICRQcm9taXNlfSk7XG5yZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpKCRQcm9taXNlLCBQUk9NSVNFKTtcbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoUFJPTUlTRSk7XG5XcmFwcGVyID0gcmVxdWlyZSgnLi9fY29yZScpW1BST01JU0VdO1xuXG4vLyBzdGF0aWNzXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC41IFByb21pc2UucmVqZWN0KHIpXG4gIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHIpe1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkodGhpcylcbiAgICAgICwgJCRyZWplY3QgICA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgICQkcmVqZWN0KHIpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTElCUkFSWSB8fCAhVVNFX05BVElWRSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjYgUHJvbWlzZS5yZXNvbHZlKHgpXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoeCl7XG4gICAgLy8gaW5zdGFuY2VvZiBpbnN0ZWFkIG9mIGludGVybmFsIHNsb3QgY2hlY2sgYmVjYXVzZSB3ZSBzaG91bGQgZml4IGl0IHdpdGhvdXQgcmVwbGFjZW1lbnQgbmF0aXZlIFByb21pc2UgY29yZVxuICAgIGlmKHggaW5zdGFuY2VvZiAkUHJvbWlzZSAmJiBzYW1lQ29uc3RydWN0b3IoeC5jb25zdHJ1Y3RvciwgdGhpcykpcmV0dXJuIHg7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSh0aGlzKVxuICAgICAgLCAkJHJlc29sdmUgID0gY2FwYWJpbGl0eS5yZXNvbHZlO1xuICAgICQkcmVzb2x2ZSh4KTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIShVU0VfTkFUSVZFICYmIHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JykoZnVuY3Rpb24oaXRlcil7XG4gICRQcm9taXNlLmFsbChpdGVyKVsnY2F0Y2gnXShlbXB0eSk7XG59KSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjEgUHJvbWlzZS5hbGwoaXRlcmFibGUpXG4gIGFsbDogZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKXtcbiAgICB2YXIgQyAgICAgICAgICA9IHRoaXNcbiAgICAgICwgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICAsIHJlc29sdmUgICAgPSBjYXBhYmlsaXR5LnJlc29sdmVcbiAgICAgICwgcmVqZWN0ICAgICA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciBhYnJ1cHQgPSBwZXJmb3JtKGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgdmFsdWVzICAgID0gW11cbiAgICAgICAgLCBpbmRleCAgICAgPSAwXG4gICAgICAgICwgcmVtYWluaW5nID0gMTtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24ocHJvbWlzZSl7XG4gICAgICAgIHZhciAkaW5kZXggICAgICAgID0gaW5kZXgrK1xuICAgICAgICAgICwgYWxyZWFkeUNhbGxlZCA9IGZhbHNlO1xuICAgICAgICB2YWx1ZXMucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICByZW1haW5pbmcrKztcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgICAgICAgIGlmKGFscmVhZHlDYWxsZWQpcmV0dXJuO1xuICAgICAgICAgIGFscmVhZHlDYWxsZWQgID0gdHJ1ZTtcbiAgICAgICAgICB2YWx1ZXNbJGluZGV4XSA9IHZhbHVlO1xuICAgICAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgIH0pO1xuICAgIGlmKGFicnVwdClyZWplY3QoYWJydXB0LmVycm9yKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9LFxuICAvLyAyNS40LjQuNCBQcm9taXNlLnJhY2UoaXRlcmFibGUpXG4gIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpe1xuICAgIHZhciBDICAgICAgICAgID0gdGhpc1xuICAgICAgLCBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICAgICwgcmVqZWN0ICAgICA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciBhYnJ1cHQgPSBwZXJmb3JtKGZ1bmN0aW9uKCl7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uKHByb21pc2Upe1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihjYXBhYmlsaXR5LnJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZihhYnJ1cHQpcmVqZWN0KGFicnVwdC5lcnJvcik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7IiwiLy8gMjYuMS4xIFJlZmxlY3QuYXBwbHkodGFyZ2V0LCB0aGlzQXJndW1lbnQsIGFyZ3VtZW50c0xpc3QpXG52YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCBhbk9iamVjdCAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIHJBcHBseSAgICA9IChyZXF1aXJlKCcuL19nbG9iYWwnKS5SZWZsZWN0IHx8IHt9KS5hcHBseVxuICAsIGZBcHBseSAgICA9IEZ1bmN0aW9uLmFwcGx5O1xuLy8gTVMgRWRnZSBhcmd1bWVudHNMaXN0IGFyZ3VtZW50IGlzIG9wdGlvbmFsXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJBcHBseShmdW5jdGlvbigpe30pO1xufSksICdSZWZsZWN0Jywge1xuICBhcHBseTogZnVuY3Rpb24gYXBwbHkodGFyZ2V0LCB0aGlzQXJndW1lbnQsIGFyZ3VtZW50c0xpc3Qpe1xuICAgIHZhciBUID0gYUZ1bmN0aW9uKHRhcmdldClcbiAgICAgICwgTCA9IGFuT2JqZWN0KGFyZ3VtZW50c0xpc3QpO1xuICAgIHJldHVybiByQXBwbHkgPyByQXBwbHkoVCwgdGhpc0FyZ3VtZW50LCBMKSA6IGZBcHBseS5jYWxsKFQsIHRoaXNBcmd1bWVudCwgTCk7XG4gIH1cbn0pOyIsIi8vIDI2LjEuMiBSZWZsZWN0LmNvbnN0cnVjdCh0YXJnZXQsIGFyZ3VtZW50c0xpc3QgWywgbmV3VGFyZ2V0XSlcbnZhciAkZXhwb3J0ICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBjcmVhdGUgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpXG4gICwgYUZ1bmN0aW9uICA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKVxuICAsIGFuT2JqZWN0ICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGlzT2JqZWN0ICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGZhaWxzICAgICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgYmluZCAgICAgICA9IHJlcXVpcmUoJy4vX2JpbmQnKVxuICAsIHJDb25zdHJ1Y3QgPSAocmVxdWlyZSgnLi9fZ2xvYmFsJykuUmVmbGVjdCB8fCB7fSkuY29uc3RydWN0O1xuXG4vLyBNUyBFZGdlIHN1cHBvcnRzIG9ubHkgMiBhcmd1bWVudHMgYW5kIGFyZ3VtZW50c0xpc3QgYXJndW1lbnQgaXMgb3B0aW9uYWxcbi8vIEZGIE5pZ2h0bHkgc2V0cyB0aGlyZCBhcmd1bWVudCBhcyBgbmV3LnRhcmdldGAsIGJ1dCBkb2VzIG5vdCBjcmVhdGUgYHRoaXNgIGZyb20gaXRcbnZhciBORVdfVEFSR0VUX0JVRyA9IGZhaWxzKGZ1bmN0aW9uKCl7XG4gIGZ1bmN0aW9uIEYoKXt9XG4gIHJldHVybiAhKHJDb25zdHJ1Y3QoZnVuY3Rpb24oKXt9LCBbXSwgRikgaW5zdGFuY2VvZiBGKTtcbn0pO1xudmFyIEFSR1NfQlVHID0gIWZhaWxzKGZ1bmN0aW9uKCl7XG4gIHJDb25zdHJ1Y3QoZnVuY3Rpb24oKXt9KTtcbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIChORVdfVEFSR0VUX0JVRyB8fCBBUkdTX0JVRyksICdSZWZsZWN0Jywge1xuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIGNvbnN0cnVjdChUYXJnZXQsIGFyZ3MgLyosIG5ld1RhcmdldCovKXtcbiAgICBhRnVuY3Rpb24oVGFyZ2V0KTtcbiAgICBhbk9iamVjdChhcmdzKTtcbiAgICB2YXIgbmV3VGFyZ2V0ID0gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyBUYXJnZXQgOiBhRnVuY3Rpb24oYXJndW1lbnRzWzJdKTtcbiAgICBpZihBUkdTX0JVRyAmJiAhTkVXX1RBUkdFVF9CVUcpcmV0dXJuIHJDb25zdHJ1Y3QoVGFyZ2V0LCBhcmdzLCBuZXdUYXJnZXQpO1xuICAgIGlmKFRhcmdldCA9PSBuZXdUYXJnZXQpe1xuICAgICAgLy8gdy9vIGFsdGVyZWQgbmV3VGFyZ2V0LCBvcHRpbWl6YXRpb24gZm9yIDAtNCBhcmd1bWVudHNcbiAgICAgIHN3aXRjaChhcmdzLmxlbmd0aCl7XG4gICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBUYXJnZXQ7XG4gICAgICAgIGNhc2UgMTogcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSk7XG4gICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgIGNhc2UgMzogcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgIGNhc2UgNDogcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gICAgICB9XG4gICAgICAvLyB3L28gYWx0ZXJlZCBuZXdUYXJnZXQsIGxvdCBvZiBhcmd1bWVudHMgY2FzZVxuICAgICAgdmFyICRhcmdzID0gW251bGxdO1xuICAgICAgJGFyZ3MucHVzaC5hcHBseSgkYXJncywgYXJncyk7XG4gICAgICByZXR1cm4gbmV3IChiaW5kLmFwcGx5KFRhcmdldCwgJGFyZ3MpKTtcbiAgICB9XG4gICAgLy8gd2l0aCBhbHRlcmVkIG5ld1RhcmdldCwgbm90IHN1cHBvcnQgYnVpbHQtaW4gY29uc3RydWN0b3JzXG4gICAgdmFyIHByb3RvICAgID0gbmV3VGFyZ2V0LnByb3RvdHlwZVxuICAgICAgLCBpbnN0YW5jZSA9IGNyZWF0ZShpc09iamVjdChwcm90bykgPyBwcm90byA6IE9iamVjdC5wcm90b3R5cGUpXG4gICAgICAsIHJlc3VsdCAgID0gRnVuY3Rpb24uYXBwbHkuY2FsbChUYXJnZXQsIGluc3RhbmNlLCBhcmdzKTtcbiAgICByZXR1cm4gaXNPYmplY3QocmVzdWx0KSA/IHJlc3VsdCA6IGluc3RhbmNlO1xuICB9XG59KTsiLCIvLyAyNi4xLjMgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5LCBhdHRyaWJ1dGVzKVxudmFyIGRQICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCAkZXhwb3J0ICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgYW5PYmplY3QgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG5cbi8vIE1TIEVkZ2UgaGFzIGJyb2tlbiBSZWZsZWN0LmRlZmluZVByb3BlcnR5IC0gdGhyb3dpbmcgaW5zdGVhZCBvZiByZXR1cm5pbmcgZmFsc2VcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICBSZWZsZWN0LmRlZmluZVByb3BlcnR5KGRQLmYoe30sIDEsIHt2YWx1ZTogMX0pLCAxLCB7dmFsdWU6IDJ9KTtcbn0pLCAnUmVmbGVjdCcsIHtcbiAgZGVmaW5lUHJvcGVydHk6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpe1xuICAgIGFuT2JqZWN0KHRhcmdldCk7XG4gICAgcHJvcGVydHlLZXkgPSB0b1ByaW1pdGl2ZShwcm9wZXJ0eUtleSwgdHJ1ZSk7XG4gICAgYW5PYmplY3QoYXR0cmlidXRlcyk7XG4gICAgdHJ5IHtcbiAgICAgIGRQLmYodGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufSk7IiwiLy8gMjYuMS40IFJlZmxlY3QuZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSlcbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgZ09QRCAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmZcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGRlbGV0ZVByb3BlcnR5OiBmdW5jdGlvbiBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5KXtcbiAgICB2YXIgZGVzYyA9IGdPUEQoYW5PYmplY3QodGFyZ2V0KSwgcHJvcGVydHlLZXkpO1xuICAgIHJldHVybiBkZXNjICYmICFkZXNjLmNvbmZpZ3VyYWJsZSA/IGZhbHNlIDogZGVsZXRlIHRhcmdldFtwcm9wZXJ0eUtleV07XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIDI2LjEuNSBSZWZsZWN0LmVudW1lcmF0ZSh0YXJnZXQpXG52YXIgJGV4cG9ydCAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgRW51bWVyYXRlID0gZnVuY3Rpb24oaXRlcmF0ZWQpe1xuICB0aGlzLl90ID0gYW5PYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB2YXIga2V5cyA9IHRoaXMuX2sgPSBbXSAgICAgICAvLyBrZXlzXG4gICAgLCBrZXk7XG4gIGZvcihrZXkgaW4gaXRlcmF0ZWQpa2V5cy5wdXNoKGtleSk7XG59O1xucmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKShFbnVtZXJhdGUsICdPYmplY3QnLCBmdW5jdGlvbigpe1xuICB2YXIgdGhhdCA9IHRoaXNcbiAgICAsIGtleXMgPSB0aGF0Ll9rXG4gICAgLCBrZXk7XG4gIGRvIHtcbiAgICBpZih0aGF0Ll9pID49IGtleXMubGVuZ3RoKXJldHVybiB7dmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZX07XG4gIH0gd2hpbGUoISgoa2V5ID0ga2V5c1t0aGF0Ll9pKytdKSBpbiB0aGF0Ll90KSk7XG4gIHJldHVybiB7dmFsdWU6IGtleSwgZG9uZTogZmFsc2V9O1xufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgZW51bWVyYXRlOiBmdW5jdGlvbiBlbnVtZXJhdGUodGFyZ2V0KXtcbiAgICByZXR1cm4gbmV3IEVudW1lcmF0ZSh0YXJnZXQpO1xuICB9XG59KTsiLCIvLyAyNi4xLjcgUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wZXJ0eUtleSlcbnZhciBnT1BEICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJylcbiAgLCAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3BlcnR5S2V5KXtcbiAgICByZXR1cm4gZ09QRC5mKGFuT2JqZWN0KHRhcmdldCksIHByb3BlcnR5S2V5KTtcbiAgfVxufSk7IiwiLy8gMjYuMS44IFJlZmxlY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KVxudmFyICRleHBvcnQgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBnZXRQcm90byA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgZ2V0UHJvdG90eXBlT2Y6IGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKHRhcmdldCl7XG4gICAgcmV0dXJuIGdldFByb3RvKGFuT2JqZWN0KHRhcmdldCkpO1xuICB9XG59KTsiLCIvLyAyNi4xLjYgUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wZXJ0eUtleSBbLCByZWNlaXZlcl0pXG52YXIgZ09QRCAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpXG4gICwgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGlzT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBhbk9iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG5mdW5jdGlvbiBnZXQodGFyZ2V0LCBwcm9wZXJ0eUtleS8qLCByZWNlaXZlciovKXtcbiAgdmFyIHJlY2VpdmVyID0gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB0YXJnZXQgOiBhcmd1bWVudHNbMl1cbiAgICAsIGRlc2MsIHByb3RvO1xuICBpZihhbk9iamVjdCh0YXJnZXQpID09PSByZWNlaXZlcilyZXR1cm4gdGFyZ2V0W3Byb3BlcnR5S2V5XTtcbiAgaWYoZGVzYyA9IGdPUEQuZih0YXJnZXQsIHByb3BlcnR5S2V5KSlyZXR1cm4gaGFzKGRlc2MsICd2YWx1ZScpXG4gICAgPyBkZXNjLnZhbHVlXG4gICAgOiBkZXNjLmdldCAhPT0gdW5kZWZpbmVkXG4gICAgICA/IGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpXG4gICAgICA6IHVuZGVmaW5lZDtcbiAgaWYoaXNPYmplY3QocHJvdG8gPSBnZXRQcm90b3R5cGVPZih0YXJnZXQpKSlyZXR1cm4gZ2V0KHByb3RvLCBwcm9wZXJ0eUtleSwgcmVjZWl2ZXIpO1xufVxuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7Z2V0OiBnZXR9KTsiLCIvLyAyNi4xLjkgUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wZXJ0eUtleSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgaGFzOiBmdW5jdGlvbiBoYXModGFyZ2V0LCBwcm9wZXJ0eUtleSl7XG4gICAgcmV0dXJuIHByb3BlcnR5S2V5IGluIHRhcmdldDtcbiAgfVxufSk7IiwiLy8gMjYuMS4xMCBSZWZsZWN0LmlzRXh0ZW5zaWJsZSh0YXJnZXQpXG52YXIgJGV4cG9ydCAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgYW5PYmplY3QgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgJGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGU7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgaXNFeHRlbnNpYmxlOiBmdW5jdGlvbiBpc0V4dGVuc2libGUodGFyZ2V0KXtcbiAgICBhbk9iamVjdCh0YXJnZXQpO1xuICAgIHJldHVybiAkaXNFeHRlbnNpYmxlID8gJGlzRXh0ZW5zaWJsZSh0YXJnZXQpIDogdHJ1ZTtcbiAgfVxufSk7IiwiLy8gMjYuMS4xMSBSZWZsZWN0Lm93bktleXModGFyZ2V0KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge293bktleXM6IHJlcXVpcmUoJy4vX293bi1rZXlzJyl9KTsiLCIvLyAyNi4xLjEyIFJlZmxlY3QucHJldmVudEV4dGVuc2lvbnModGFyZ2V0KVxudmFyICRleHBvcnQgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgYW5PYmplY3QgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCAkcHJldmVudEV4dGVuc2lvbnMgPSBPYmplY3QucHJldmVudEV4dGVuc2lvbnM7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgcHJldmVudEV4dGVuc2lvbnM6IGZ1bmN0aW9uIHByZXZlbnRFeHRlbnNpb25zKHRhcmdldCl7XG4gICAgYW5PYmplY3QodGFyZ2V0KTtcbiAgICB0cnkge1xuICAgICAgaWYoJHByZXZlbnRFeHRlbnNpb25zKSRwcmV2ZW50RXh0ZW5zaW9ucyh0YXJnZXQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn0pOyIsIi8vIDI2LjEuMTQgUmVmbGVjdC5zZXRQcm90b3R5cGVPZih0YXJnZXQsIHByb3RvKVxudmFyICRleHBvcnQgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBzZXRQcm90byA9IHJlcXVpcmUoJy4vX3NldC1wcm90bycpO1xuXG5pZihzZXRQcm90bykkZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIHNldFByb3RvdHlwZU9mOiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZih0YXJnZXQsIHByb3RvKXtcbiAgICBzZXRQcm90by5jaGVjayh0YXJnZXQsIHByb3RvKTtcbiAgICB0cnkge1xuICAgICAgc2V0UHJvdG8uc2V0KHRhcmdldCwgcHJvdG8pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn0pOyIsIi8vIDI2LjEuMTMgUmVmbGVjdC5zZXQodGFyZ2V0LCBwcm9wZXJ0eUtleSwgViBbLCByZWNlaXZlcl0pXG52YXIgZFAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsIGdPUEQgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKVxuICAsIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBjcmVhdGVEZXNjICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKVxuICAsIGFuT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBpc09iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG5mdW5jdGlvbiBzZXQodGFyZ2V0LCBwcm9wZXJ0eUtleSwgVi8qLCByZWNlaXZlciovKXtcbiAgdmFyIHJlY2VpdmVyID0gYXJndW1lbnRzLmxlbmd0aCA8IDQgPyB0YXJnZXQgOiBhcmd1bWVudHNbM11cbiAgICAsIG93bkRlc2MgID0gZ09QRC5mKGFuT2JqZWN0KHRhcmdldCksIHByb3BlcnR5S2V5KVxuICAgICwgZXhpc3RpbmdEZXNjcmlwdG9yLCBwcm90bztcbiAgaWYoIW93bkRlc2Mpe1xuICAgIGlmKGlzT2JqZWN0KHByb3RvID0gZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSkpe1xuICAgICAgcmV0dXJuIHNldChwcm90bywgcHJvcGVydHlLZXksIFYsIHJlY2VpdmVyKTtcbiAgICB9XG4gICAgb3duRGVzYyA9IGNyZWF0ZURlc2MoMCk7XG4gIH1cbiAgaWYoaGFzKG93bkRlc2MsICd2YWx1ZScpKXtcbiAgICBpZihvd25EZXNjLndyaXRhYmxlID09PSBmYWxzZSB8fCAhaXNPYmplY3QocmVjZWl2ZXIpKXJldHVybiBmYWxzZTtcbiAgICBleGlzdGluZ0Rlc2NyaXB0b3IgPSBnT1BELmYocmVjZWl2ZXIsIHByb3BlcnR5S2V5KSB8fCBjcmVhdGVEZXNjKDApO1xuICAgIGV4aXN0aW5nRGVzY3JpcHRvci52YWx1ZSA9IFY7XG4gICAgZFAuZihyZWNlaXZlciwgcHJvcGVydHlLZXksIGV4aXN0aW5nRGVzY3JpcHRvcik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIG93bkRlc2Muc2V0ID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IChvd25EZXNjLnNldC5jYWxsKHJlY2VpdmVyLCBWKSwgdHJ1ZSk7XG59XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtzZXQ6IHNldH0pOyIsInZhciBnbG9iYWwgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgaW5oZXJpdElmUmVxdWlyZWQgPSByZXF1aXJlKCcuL19pbmhlcml0LWlmLXJlcXVpcmVkJylcbiAgLCBkUCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBnT1BOICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZlxuICAsIGlzUmVnRXhwICAgICAgICAgID0gcmVxdWlyZSgnLi9faXMtcmVnZXhwJylcbiAgLCAkZmxhZ3MgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2ZsYWdzJylcbiAgLCAkUmVnRXhwICAgICAgICAgICA9IGdsb2JhbC5SZWdFeHBcbiAgLCBCYXNlICAgICAgICAgICAgICA9ICRSZWdFeHBcbiAgLCBwcm90byAgICAgICAgICAgICA9ICRSZWdFeHAucHJvdG90eXBlXG4gICwgcmUxICAgICAgICAgICAgICAgPSAvYS9nXG4gICwgcmUyICAgICAgICAgICAgICAgPSAvYS9nXG4gIC8vIFwibmV3XCIgY3JlYXRlcyBhIG5ldyBvYmplY3QsIG9sZCB3ZWJraXQgYnVnZ3kgaGVyZVxuICAsIENPUlJFQ1RfTkVXICAgICAgID0gbmV3ICRSZWdFeHAocmUxKSAhPT0gcmUxO1xuXG5pZihyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICghQ09SUkVDVF9ORVcgfHwgcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZTJbcmVxdWlyZSgnLi9fd2tzJykoJ21hdGNoJyldID0gZmFsc2U7XG4gIC8vIFJlZ0V4cCBjb25zdHJ1Y3RvciBjYW4gYWx0ZXIgZmxhZ3MgYW5kIElzUmVnRXhwIHdvcmtzIGNvcnJlY3Qgd2l0aCBAQG1hdGNoXG4gIHJldHVybiAkUmVnRXhwKHJlMSkgIT0gcmUxIHx8ICRSZWdFeHAocmUyKSA9PSByZTIgfHwgJFJlZ0V4cChyZTEsICdpJykgIT0gJy9hL2knO1xufSkpKXtcbiAgJFJlZ0V4cCA9IGZ1bmN0aW9uIFJlZ0V4cChwLCBmKXtcbiAgICB2YXIgdGlSRSA9IHRoaXMgaW5zdGFuY2VvZiAkUmVnRXhwXG4gICAgICAsIHBpUkUgPSBpc1JlZ0V4cChwKVxuICAgICAgLCBmaVUgID0gZiA9PT0gdW5kZWZpbmVkO1xuICAgIHJldHVybiAhdGlSRSAmJiBwaVJFICYmIHAuY29uc3RydWN0b3IgPT09ICRSZWdFeHAgJiYgZmlVID8gcFxuICAgICAgOiBpbmhlcml0SWZSZXF1aXJlZChDT1JSRUNUX05FV1xuICAgICAgICA/IG5ldyBCYXNlKHBpUkUgJiYgIWZpVSA/IHAuc291cmNlIDogcCwgZilcbiAgICAgICAgOiBCYXNlKChwaVJFID0gcCBpbnN0YW5jZW9mICRSZWdFeHApID8gcC5zb3VyY2UgOiBwLCBwaVJFICYmIGZpVSA/ICRmbGFncy5jYWxsKHApIDogZilcbiAgICAgICwgdGlSRSA/IHRoaXMgOiBwcm90bywgJFJlZ0V4cCk7XG4gIH07XG4gIHZhciBwcm94eSA9IGZ1bmN0aW9uKGtleSl7XG4gICAga2V5IGluICRSZWdFeHAgfHwgZFAoJFJlZ0V4cCwga2V5LCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiBCYXNlW2tleV07IH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKGl0KXsgQmFzZVtrZXldID0gaXQ7IH1cbiAgICB9KTtcbiAgfTtcbiAgZm9yKHZhciBrZXlzID0gZ09QTihCYXNlKSwgaSA9IDA7IGtleXMubGVuZ3RoID4gaTsgKXByb3h5KGtleXNbaSsrXSk7XG4gIHByb3RvLmNvbnN0cnVjdG9yID0gJFJlZ0V4cDtcbiAgJFJlZ0V4cC5wcm90b3R5cGUgPSBwcm90bztcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShnbG9iYWwsICdSZWdFeHAnLCAkUmVnRXhwKTtcbn1cblxucmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKSgnUmVnRXhwJyk7IiwiLy8gMjEuMi41LjMgZ2V0IFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3MoKVxuaWYocmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAvLi9nLmZsYWdzICE9ICdnJylyZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mKFJlZ0V4cC5wcm90b3R5cGUsICdmbGFncycsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IHJlcXVpcmUoJy4vX2ZsYWdzJylcbn0pOyIsIi8vIEBAbWF0Y2ggbG9naWNcbnJlcXVpcmUoJy4vX2ZpeC1yZS13a3MnKSgnbWF0Y2gnLCAxLCBmdW5jdGlvbihkZWZpbmVkLCBNQVRDSCwgJG1hdGNoKXtcbiAgLy8gMjEuMS4zLjExIFN0cmluZy5wcm90b3R5cGUubWF0Y2gocmVnZXhwKVxuICByZXR1cm4gW2Z1bmN0aW9uIG1hdGNoKHJlZ2V4cCl7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBPICA9IGRlZmluZWQodGhpcylcbiAgICAgICwgZm4gPSByZWdleHAgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogcmVnZXhwW01BVENIXTtcbiAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZCA/IGZuLmNhbGwocmVnZXhwLCBPKSA6IG5ldyBSZWdFeHAocmVnZXhwKVtNQVRDSF0oU3RyaW5nKE8pKTtcbiAgfSwgJG1hdGNoXTtcbn0pOyIsIi8vIEBAcmVwbGFjZSBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdyZXBsYWNlJywgMiwgZnVuY3Rpb24oZGVmaW5lZCwgUkVQTEFDRSwgJHJlcGxhY2Upe1xuICAvLyAyMS4xLjMuMTQgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlKHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpXG4gIHJldHVybiBbZnVuY3Rpb24gcmVwbGFjZShzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKXtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIE8gID0gZGVmaW5lZCh0aGlzKVxuICAgICAgLCBmbiA9IHNlYXJjaFZhbHVlID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHNlYXJjaFZhbHVlW1JFUExBQ0VdO1xuICAgIHJldHVybiBmbiAhPT0gdW5kZWZpbmVkXG4gICAgICA/IGZuLmNhbGwoc2VhcmNoVmFsdWUsIE8sIHJlcGxhY2VWYWx1ZSlcbiAgICAgIDogJHJlcGxhY2UuY2FsbChTdHJpbmcoTyksIHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpO1xuICB9LCAkcmVwbGFjZV07XG59KTsiLCIvLyBAQHNlYXJjaCBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdzZWFyY2gnLCAxLCBmdW5jdGlvbihkZWZpbmVkLCBTRUFSQ0gsICRzZWFyY2gpe1xuICAvLyAyMS4xLjMuMTUgU3RyaW5nLnByb3RvdHlwZS5zZWFyY2gocmVnZXhwKVxuICByZXR1cm4gW2Z1bmN0aW9uIHNlYXJjaChyZWdleHApe1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgTyAgPSBkZWZpbmVkKHRoaXMpXG4gICAgICAsIGZuID0gcmVnZXhwID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHJlZ2V4cFtTRUFSQ0hdO1xuICAgIHJldHVybiBmbiAhPT0gdW5kZWZpbmVkID8gZm4uY2FsbChyZWdleHAsIE8pIDogbmV3IFJlZ0V4cChyZWdleHApW1NFQVJDSF0oU3RyaW5nKE8pKTtcbiAgfSwgJHNlYXJjaF07XG59KTsiLCIvLyBAQHNwbGl0IGxvZ2ljXG5yZXF1aXJlKCcuL19maXgtcmUtd2tzJykoJ3NwbGl0JywgMiwgZnVuY3Rpb24oZGVmaW5lZCwgU1BMSVQsICRzcGxpdCl7XG4gICd1c2Ugc3RyaWN0JztcbiAgdmFyIGlzUmVnRXhwICAgPSByZXF1aXJlKCcuL19pcy1yZWdleHAnKVxuICAgICwgX3NwbGl0ICAgICA9ICRzcGxpdFxuICAgICwgJHB1c2ggICAgICA9IFtdLnB1c2hcbiAgICAsICRTUExJVCAgICAgPSAnc3BsaXQnXG4gICAgLCBMRU5HVEggICAgID0gJ2xlbmd0aCdcbiAgICAsIExBU1RfSU5ERVggPSAnbGFzdEluZGV4JztcbiAgaWYoXG4gICAgJ2FiYmMnWyRTUExJVF0oLyhiKSovKVsxXSA9PSAnYycgfHxcbiAgICAndGVzdCdbJFNQTElUXSgvKD86KS8sIC0xKVtMRU5HVEhdICE9IDQgfHxcbiAgICAnYWInWyRTUExJVF0oLyg/OmFiKSovKVtMRU5HVEhdICE9IDIgfHxcbiAgICAnLidbJFNQTElUXSgvKC4/KSguPykvKVtMRU5HVEhdICE9IDQgfHxcbiAgICAnLidbJFNQTElUXSgvKCkoKS8pW0xFTkdUSF0gPiAxIHx8XG4gICAgJydbJFNQTElUXSgvLj8vKVtMRU5HVEhdXG4gICl7XG4gICAgdmFyIE5QQ0cgPSAvKCk/Py8uZXhlYygnJylbMV0gPT09IHVuZGVmaW5lZDsgLy8gbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXBcbiAgICAvLyBiYXNlZCBvbiBlczUtc2hpbSBpbXBsZW1lbnRhdGlvbiwgbmVlZCB0byByZXdvcmsgaXRcbiAgICAkc3BsaXQgPSBmdW5jdGlvbihzZXBhcmF0b3IsIGxpbWl0KXtcbiAgICAgIHZhciBzdHJpbmcgPSBTdHJpbmcodGhpcyk7XG4gICAgICBpZihzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCAmJiBsaW1pdCA9PT0gMClyZXR1cm4gW107XG4gICAgICAvLyBJZiBgc2VwYXJhdG9yYCBpcyBub3QgYSByZWdleCwgdXNlIG5hdGl2ZSBzcGxpdFxuICAgICAgaWYoIWlzUmVnRXhwKHNlcGFyYXRvcikpcmV0dXJuIF9zcGxpdC5jYWxsKHN0cmluZywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgICB2YXIgZmxhZ3MgPSAoc2VwYXJhdG9yLmlnbm9yZUNhc2UgPyAnaScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5tdWx0aWxpbmUgPyAnbScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci51bmljb2RlID8gJ3UnIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3Iuc3RpY2t5ID8gJ3knIDogJycpO1xuICAgICAgdmFyIGxhc3RMYXN0SW5kZXggPSAwO1xuICAgICAgdmFyIHNwbGl0TGltaXQgPSBsaW1pdCA9PT0gdW5kZWZpbmVkID8gNDI5NDk2NzI5NSA6IGxpbWl0ID4+PiAwO1xuICAgICAgLy8gTWFrZSBgZ2xvYmFsYCBhbmQgYXZvaWQgYGxhc3RJbmRleGAgaXNzdWVzIGJ5IHdvcmtpbmcgd2l0aCBhIGNvcHlcbiAgICAgIHZhciBzZXBhcmF0b3JDb3B5ID0gbmV3IFJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLCBmbGFncyArICdnJyk7XG4gICAgICB2YXIgc2VwYXJhdG9yMiwgbWF0Y2gsIGxhc3RJbmRleCwgbGFzdExlbmd0aCwgaTtcbiAgICAgIC8vIERvZXNuJ3QgbmVlZCBmbGFncyBneSwgYnV0IHRoZXkgZG9uJ3QgaHVydFxuICAgICAgaWYoIU5QQ0cpc2VwYXJhdG9yMiA9IG5ldyBSZWdFeHAoJ14nICsgc2VwYXJhdG9yQ29weS5zb3VyY2UgKyAnJCg/IVxcXFxzKScsIGZsYWdzKTtcbiAgICAgIHdoaWxlKG1hdGNoID0gc2VwYXJhdG9yQ29weS5leGVjKHN0cmluZykpe1xuICAgICAgICAvLyBgc2VwYXJhdG9yQ29weS5sYXN0SW5kZXhgIGlzIG5vdCByZWxpYWJsZSBjcm9zcy1icm93c2VyXG4gICAgICAgIGxhc3RJbmRleCA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF1bTEVOR1RIXTtcbiAgICAgICAgaWYobGFzdEluZGV4ID4gbGFzdExhc3RJbmRleCl7XG4gICAgICAgICAgb3V0cHV0LnB1c2goc3RyaW5nLnNsaWNlKGxhc3RMYXN0SW5kZXgsIG1hdGNoLmluZGV4KSk7XG4gICAgICAgICAgLy8gRml4IGJyb3dzZXJzIHdob3NlIGBleGVjYCBtZXRob2RzIGRvbid0IGNvbnNpc3RlbnRseSByZXR1cm4gYHVuZGVmaW5lZGAgZm9yIE5QQ0dcbiAgICAgICAgICBpZighTlBDRyAmJiBtYXRjaFtMRU5HVEhdID4gMSltYXRjaFswXS5yZXBsYWNlKHNlcGFyYXRvcjIsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBmb3IoaSA9IDE7IGkgPCBhcmd1bWVudHNbTEVOR1RIXSAtIDI7IGkrKylpZihhcmd1bWVudHNbaV0gPT09IHVuZGVmaW5lZCltYXRjaFtpXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZihtYXRjaFtMRU5HVEhdID4gMSAmJiBtYXRjaC5pbmRleCA8IHN0cmluZ1tMRU5HVEhdKSRwdXNoLmFwcGx5KG91dHB1dCwgbWF0Y2guc2xpY2UoMSkpO1xuICAgICAgICAgIGxhc3RMZW5ndGggPSBtYXRjaFswXVtMRU5HVEhdO1xuICAgICAgICAgIGxhc3RMYXN0SW5kZXggPSBsYXN0SW5kZXg7XG4gICAgICAgICAgaWYob3V0cHV0W0xFTkdUSF0gPj0gc3BsaXRMaW1pdClicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZihzZXBhcmF0b3JDb3B5W0xBU1RfSU5ERVhdID09PSBtYXRjaC5pbmRleClzZXBhcmF0b3JDb3B5W0xBU1RfSU5ERVhdKys7IC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3BcbiAgICAgIH1cbiAgICAgIGlmKGxhc3RMYXN0SW5kZXggPT09IHN0cmluZ1tMRU5HVEhdKXtcbiAgICAgICAgaWYobGFzdExlbmd0aCB8fCAhc2VwYXJhdG9yQ29weS50ZXN0KCcnKSlvdXRwdXQucHVzaCgnJyk7XG4gICAgICB9IGVsc2Ugb3V0cHV0LnB1c2goc3RyaW5nLnNsaWNlKGxhc3RMYXN0SW5kZXgpKTtcbiAgICAgIHJldHVybiBvdXRwdXRbTEVOR1RIXSA+IHNwbGl0TGltaXQgPyBvdXRwdXQuc2xpY2UoMCwgc3BsaXRMaW1pdCkgOiBvdXRwdXQ7XG4gICAgfTtcbiAgLy8gQ2hha3JhLCBWOFxuICB9IGVsc2UgaWYoJzAnWyRTUExJVF0odW5kZWZpbmVkLCAwKVtMRU5HVEhdKXtcbiAgICAkc3BsaXQgPSBmdW5jdGlvbihzZXBhcmF0b3IsIGxpbWl0KXtcbiAgICAgIHJldHVybiBzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCAmJiBsaW1pdCA9PT0gMCA/IFtdIDogX3NwbGl0LmNhbGwodGhpcywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfTtcbiAgfVxuICAvLyAyMS4xLjMuMTcgU3RyaW5nLnByb3RvdHlwZS5zcGxpdChzZXBhcmF0b3IsIGxpbWl0KVxuICByZXR1cm4gW2Z1bmN0aW9uIHNwbGl0KHNlcGFyYXRvciwgbGltaXQpe1xuICAgIHZhciBPICA9IGRlZmluZWQodGhpcylcbiAgICAgICwgZm4gPSBzZXBhcmF0b3IgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogc2VwYXJhdG9yW1NQTElUXTtcbiAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZCA/IGZuLmNhbGwoc2VwYXJhdG9yLCBPLCBsaW1pdCkgOiAkc3BsaXQuY2FsbChTdHJpbmcoTyksIHNlcGFyYXRvciwgbGltaXQpO1xuICB9LCAkc3BsaXRdO1xufSk7IiwiJ3VzZSBzdHJpY3QnO1xucmVxdWlyZSgnLi9lczYucmVnZXhwLmZsYWdzJyk7XG52YXIgYW5PYmplY3QgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsICRmbGFncyAgICAgID0gcmVxdWlyZSgnLi9fZmxhZ3MnKVxuICAsIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKVxuICAsIFRPX1NUUklORyAgID0gJ3RvU3RyaW5nJ1xuICAsICR0b1N0cmluZyAgID0gLy4vW1RPX1NUUklOR107XG5cbnZhciBkZWZpbmUgPSBmdW5jdGlvbihmbil7XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoUmVnRXhwLnByb3RvdHlwZSwgVE9fU1RSSU5HLCBmbiwgdHJ1ZSk7XG59O1xuXG4vLyAyMS4yLjUuMTQgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZygpXG5pZihyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7IHJldHVybiAkdG9TdHJpbmcuY2FsbCh7c291cmNlOiAnYScsIGZsYWdzOiAnYid9KSAhPSAnL2EvYic7IH0pKXtcbiAgZGVmaW5lKGZ1bmN0aW9uIHRvU3RyaW5nKCl7XG4gICAgdmFyIFIgPSBhbk9iamVjdCh0aGlzKTtcbiAgICByZXR1cm4gJy8nLmNvbmNhdChSLnNvdXJjZSwgJy8nLFxuICAgICAgJ2ZsYWdzJyBpbiBSID8gUi5mbGFncyA6ICFERVNDUklQVE9SUyAmJiBSIGluc3RhbmNlb2YgUmVnRXhwID8gJGZsYWdzLmNhbGwoUikgOiB1bmRlZmluZWQpO1xuICB9KTtcbi8vIEZGNDQtIFJlZ0V4cCN0b1N0cmluZyBoYXMgYSB3cm9uZyBuYW1lXG59IGVsc2UgaWYoJHRvU3RyaW5nLm5hbWUgIT0gVE9fU1RSSU5HKXtcbiAgZGVmaW5lKGZ1bmN0aW9uIHRvU3RyaW5nKCl7XG4gICAgcmV0dXJuICR0b1N0cmluZy5jYWxsKHRoaXMpO1xuICB9KTtcbn0iLCIndXNlIHN0cmljdCc7XG52YXIgc3Ryb25nID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi1zdHJvbmcnKTtcblxuLy8gMjMuMiBTZXQgT2JqZWN0c1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoJ1NldCcsIGZ1bmN0aW9uKGdldCl7XG4gIHJldHVybiBmdW5jdGlvbiBTZXQoKXsgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7IH07XG59LCB7XG4gIC8vIDIzLjIuMy4xIFNldC5wcm90b3R5cGUuYWRkKHZhbHVlKVxuICBhZGQ6IGZ1bmN0aW9uIGFkZCh2YWx1ZSl7XG4gICAgcmV0dXJuIHN0cm9uZy5kZWYodGhpcywgdmFsdWUgPSB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSwgdmFsdWUpO1xuICB9XG59LCBzdHJvbmcpOyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjIgU3RyaW5nLnByb3RvdHlwZS5hbmNob3IobmFtZSlcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2FuY2hvcicsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gYW5jaG9yKG5hbWUpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdhJywgJ25hbWUnLCBuYW1lKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMyBTdHJpbmcucHJvdG90eXBlLmJpZygpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdiaWcnLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGJpZygpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdiaWcnLCAnJywgJycpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy40IFN0cmluZy5wcm90b3R5cGUuYmxpbmsoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnYmxpbmsnLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGJsaW5rKCl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2JsaW5rJywgJycsICcnKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuNSBTdHJpbmcucHJvdG90eXBlLmJvbGQoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnYm9sZCcsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gYm9sZCgpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdiJywgJycsICcnKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRhdCAgICAgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKShmYWxzZSk7XG4kZXhwb3J0KCRleHBvcnQuUCwgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4zLjMgU3RyaW5nLnByb3RvdHlwZS5jb2RlUG9pbnRBdChwb3MpXG4gIGNvZGVQb2ludEF0OiBmdW5jdGlvbiBjb2RlUG9pbnRBdChwb3Mpe1xuICAgIHJldHVybiAkYXQodGhpcywgcG9zKTtcbiAgfVxufSk7IiwiLy8gMjEuMS4zLjYgU3RyaW5nLnByb3RvdHlwZS5lbmRzV2l0aChzZWFyY2hTdHJpbmcgWywgZW5kUG9zaXRpb25dKVxuJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9MZW5ndGggID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBjb250ZXh0ICAgPSByZXF1aXJlKCcuL19zdHJpbmctY29udGV4dCcpXG4gICwgRU5EU19XSVRIID0gJ2VuZHNXaXRoJ1xuICAsICRlbmRzV2l0aCA9ICcnW0VORFNfV0lUSF07XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMtaXMtcmVnZXhwJykoRU5EU19XSVRIKSwgJ1N0cmluZycsIHtcbiAgZW5kc1dpdGg6IGZ1bmN0aW9uIGVuZHNXaXRoKHNlYXJjaFN0cmluZyAvKiwgZW5kUG9zaXRpb24gPSBAbGVuZ3RoICovKXtcbiAgICB2YXIgdGhhdCA9IGNvbnRleHQodGhpcywgc2VhcmNoU3RyaW5nLCBFTkRTX1dJVEgpXG4gICAgICAsIGVuZFBvc2l0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWRcbiAgICAgICwgbGVuICAgID0gdG9MZW5ndGgodGhhdC5sZW5ndGgpXG4gICAgICAsIGVuZCAgICA9IGVuZFBvc2l0aW9uID09PSB1bmRlZmluZWQgPyBsZW4gOiBNYXRoLm1pbih0b0xlbmd0aChlbmRQb3NpdGlvbiksIGxlbilcbiAgICAgICwgc2VhcmNoID0gU3RyaW5nKHNlYXJjaFN0cmluZyk7XG4gICAgcmV0dXJuICRlbmRzV2l0aFxuICAgICAgPyAkZW5kc1dpdGguY2FsbCh0aGF0LCBzZWFyY2gsIGVuZClcbiAgICAgIDogdGhhdC5zbGljZShlbmQgLSBzZWFyY2gubGVuZ3RoLCBlbmQpID09PSBzZWFyY2g7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjYgU3RyaW5nLnByb3RvdHlwZS5maXhlZCgpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdmaXhlZCcsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gZml4ZWQoKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAndHQnLCAnJywgJycpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy43IFN0cmluZy5wcm90b3R5cGUuZm9udGNvbG9yKGNvbG9yKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnZm9udGNvbG9yJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBmb250Y29sb3IoY29sb3Ipe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdmb250JywgJ2NvbG9yJywgY29sb3IpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy44IFN0cmluZy5wcm90b3R5cGUuZm9udHNpemUoc2l6ZSlcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2ZvbnRzaXplJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBmb250c2l6ZShzaXplKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnZm9udCcsICdzaXplJywgc2l6ZSk7XG4gIH1cbn0pOyIsInZhciAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9JbmRleCAgICAgICAgPSByZXF1aXJlKCcuL190by1pbmRleCcpXG4gICwgZnJvbUNoYXJDb2RlICAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlXG4gICwgJGZyb21Db2RlUG9pbnQgPSBTdHJpbmcuZnJvbUNvZGVQb2ludDtcblxuLy8gbGVuZ3RoIHNob3VsZCBiZSAxLCBvbGQgRkYgcHJvYmxlbVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoISEkZnJvbUNvZGVQb2ludCAmJiAkZnJvbUNvZGVQb2ludC5sZW5ndGggIT0gMSksICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMi4yIFN0cmluZy5mcm9tQ29kZVBvaW50KC4uLmNvZGVQb2ludHMpXG4gIGZyb21Db2RlUG9pbnQ6IGZ1bmN0aW9uIGZyb21Db2RlUG9pbnQoeCl7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB2YXIgcmVzICA9IFtdXG4gICAgICAsIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAsIGkgICAgPSAwXG4gICAgICAsIGNvZGU7XG4gICAgd2hpbGUoYUxlbiA+IGkpe1xuICAgICAgY29kZSA9ICthcmd1bWVudHNbaSsrXTtcbiAgICAgIGlmKHRvSW5kZXgoY29kZSwgMHgxMGZmZmYpICE9PSBjb2RlKXRocm93IFJhbmdlRXJyb3IoY29kZSArICcgaXMgbm90IGEgdmFsaWQgY29kZSBwb2ludCcpO1xuICAgICAgcmVzLnB1c2goY29kZSA8IDB4MTAwMDBcbiAgICAgICAgPyBmcm9tQ2hhckNvZGUoY29kZSlcbiAgICAgICAgOiBmcm9tQ2hhckNvZGUoKChjb2RlIC09IDB4MTAwMDApID4+IDEwKSArIDB4ZDgwMCwgY29kZSAlIDB4NDAwICsgMHhkYzAwKVxuICAgICAgKTtcbiAgICB9IHJldHVybiByZXMuam9pbignJyk7XG4gIH1cbn0pOyIsIi8vIDIxLjEuMy43IFN0cmluZy5wcm90b3R5cGUuaW5jbHVkZXMoc2VhcmNoU3RyaW5nLCBwb3NpdGlvbiA9IDApXG4ndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGNvbnRleHQgID0gcmVxdWlyZSgnLi9fc3RyaW5nLWNvbnRleHQnKVxuICAsIElOQ0xVREVTID0gJ2luY2x1ZGVzJztcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscy1pcy1yZWdleHAnKShJTkNMVURFUyksICdTdHJpbmcnLCB7XG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhzZWFyY2hTdHJpbmcgLyosIHBvc2l0aW9uID0gMCAqLyl7XG4gICAgcmV0dXJuICEhfmNvbnRleHQodGhpcywgc2VhcmNoU3RyaW5nLCBJTkNMVURFUylcbiAgICAgIC5pbmRleE9mKHNlYXJjaFN0cmluZywgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy45IFN0cmluZy5wcm90b3R5cGUuaXRhbGljcygpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdpdGFsaWNzJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBpdGFsaWNzKCl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2knLCAnJywgJycpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGF0ICA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKHRydWUpO1xuXG4vLyAyMS4xLjMuMjcgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKFN0cmluZywgJ1N0cmluZycsIGZ1bmN0aW9uKGl0ZXJhdGVkKXtcbiAgdGhpcy5fdCA9IFN0cmluZyhpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuLy8gMjEuMS41LjIuMSAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24oKXtcbiAgdmFyIE8gICAgID0gdGhpcy5fdFxuICAgICwgaW5kZXggPSB0aGlzLl9pXG4gICAgLCBwb2ludDtcbiAgaWYoaW5kZXggPj0gTy5sZW5ndGgpcmV0dXJuIHt2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlfTtcbiAgcG9pbnQgPSAkYXQoTywgaW5kZXgpO1xuICB0aGlzLl9pICs9IHBvaW50Lmxlbmd0aDtcbiAgcmV0dXJuIHt2YWx1ZTogcG9pbnQsIGRvbmU6IGZhbHNlfTtcbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjEwIFN0cmluZy5wcm90b3R5cGUubGluayh1cmwpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdsaW5rJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBsaW5rKHVybCl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2EnLCAnaHJlZicsIHVybCk7XG4gIH1cbn0pOyIsInZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIHRvTGVuZ3RoICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4yLjQgU3RyaW5nLnJhdyhjYWxsU2l0ZSwgLi4uc3Vic3RpdHV0aW9ucylcbiAgcmF3OiBmdW5jdGlvbiByYXcoY2FsbFNpdGUpe1xuICAgIHZhciB0cGwgID0gdG9JT2JqZWN0KGNhbGxTaXRlLnJhdylcbiAgICAgICwgbGVuICA9IHRvTGVuZ3RoKHRwbC5sZW5ndGgpXG4gICAgICAsIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAsIHJlcyAgPSBbXVxuICAgICAgLCBpICAgID0gMDtcbiAgICB3aGlsZShsZW4gPiBpKXtcbiAgICAgIHJlcy5wdXNoKFN0cmluZyh0cGxbaSsrXSkpO1xuICAgICAgaWYoaSA8IGFMZW4pcmVzLnB1c2goU3RyaW5nKGFyZ3VtZW50c1tpXSkpO1xuICAgIH0gcmV0dXJuIHJlcy5qb2luKCcnKTtcbiAgfVxufSk7IiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMy4xMyBTdHJpbmcucHJvdG90eXBlLnJlcGVhdChjb3VudClcbiAgcmVwZWF0OiByZXF1aXJlKCcuL19zdHJpbmctcmVwZWF0Jylcbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjExIFN0cmluZy5wcm90b3R5cGUuc21hbGwoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnc21hbGwnLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHNtYWxsKCl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3NtYWxsJywgJycsICcnKTtcbiAgfVxufSk7IiwiLy8gMjEuMS4zLjE4IFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcgWywgcG9zaXRpb24gXSlcbid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9MZW5ndGggICAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGNvbnRleHQgICAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLWNvbnRleHQnKVxuICAsIFNUQVJUU19XSVRIID0gJ3N0YXJ0c1dpdGgnXG4gICwgJHN0YXJ0c1dpdGggPSAnJ1tTVEFSVFNfV0lUSF07XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMtaXMtcmVnZXhwJykoU1RBUlRTX1dJVEgpLCAnU3RyaW5nJywge1xuICBzdGFydHNXaXRoOiBmdW5jdGlvbiBzdGFydHNXaXRoKHNlYXJjaFN0cmluZyAvKiwgcG9zaXRpb24gPSAwICovKXtcbiAgICB2YXIgdGhhdCAgID0gY29udGV4dCh0aGlzLCBzZWFyY2hTdHJpbmcsIFNUQVJUU19XSVRIKVxuICAgICAgLCBpbmRleCAgPSB0b0xlbmd0aChNYXRoLm1pbihhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgdGhhdC5sZW5ndGgpKVxuICAgICAgLCBzZWFyY2ggPSBTdHJpbmcoc2VhcmNoU3RyaW5nKTtcbiAgICByZXR1cm4gJHN0YXJ0c1dpdGhcbiAgICAgID8gJHN0YXJ0c1dpdGguY2FsbCh0aGF0LCBzZWFyY2gsIGluZGV4KVxuICAgICAgOiB0aGF0LnNsaWNlKGluZGV4LCBpbmRleCArIHNlYXJjaC5sZW5ndGgpID09PSBzZWFyY2g7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjEyIFN0cmluZy5wcm90b3R5cGUuc3RyaWtlKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ3N0cmlrZScsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gc3RyaWtlKCl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3N0cmlrZScsICcnLCAnJyk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjEzIFN0cmluZy5wcm90b3R5cGUuc3ViKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ3N1YicsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gc3ViKCl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3N1YicsICcnLCAnJyk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjE0IFN0cmluZy5wcm90b3R5cGUuc3VwKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ3N1cCcsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gc3VwKCl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3N1cCcsICcnLCAnJyk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIDIxLjEuMy4yNSBTdHJpbmcucHJvdG90eXBlLnRyaW0oKVxucmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKSgndHJpbScsIGZ1bmN0aW9uKCR0cmltKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHRyaW0oKXtcbiAgICByZXR1cm4gJHRyaW0odGhpcywgMyk7XG4gIH07XG59KTsiLCIndXNlIHN0cmljdCc7XG4vLyBFQ01BU2NyaXB0IDYgc3ltYm9scyBzaGltXG52YXIgZ2xvYmFsICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGhhcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBERVNDUklQVE9SUyAgICA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgcmVkZWZpbmUgICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgTUVUQSAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhJykuS0VZXG4gICwgJGZhaWxzICAgICAgICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgc2hhcmVkICAgICAgICAgPSByZXF1aXJlKCcuL19zaGFyZWQnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIHVpZCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdWlkJylcbiAgLCB3a3MgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3drcycpXG4gICwgd2tzRXh0ICAgICAgICAgPSByZXF1aXJlKCcuL193a3MtZXh0JylcbiAgLCB3a3NEZWZpbmUgICAgICA9IHJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKVxuICAsIGtleU9mICAgICAgICAgID0gcmVxdWlyZSgnLi9fa2V5b2YnKVxuICAsIGVudW1LZXlzICAgICAgID0gcmVxdWlyZSgnLi9fZW51bS1rZXlzJylcbiAgLCBpc0FycmF5ICAgICAgICA9IHJlcXVpcmUoJy4vX2lzLWFycmF5JylcbiAgLCBhbk9iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgdG9JT2JqZWN0ICAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCB0b1ByaW1pdGl2ZSAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgY3JlYXRlRGVzYyAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgLCBfY3JlYXRlICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKVxuICAsIGdPUE5FeHQgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4tZXh0JylcbiAgLCAkR09QRCAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJylcbiAgLCAkRFAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgJGtleXMgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpXG4gICwgZ09QRCAgICAgICAgICAgPSAkR09QRC5mXG4gICwgZFAgICAgICAgICAgICAgPSAkRFAuZlxuICAsIGdPUE4gICAgICAgICAgID0gZ09QTkV4dC5mXG4gICwgJFN5bWJvbCAgICAgICAgPSBnbG9iYWwuU3ltYm9sXG4gICwgJEpTT04gICAgICAgICAgPSBnbG9iYWwuSlNPTlxuICAsIF9zdHJpbmdpZnkgICAgID0gJEpTT04gJiYgJEpTT04uc3RyaW5naWZ5XG4gICwgUFJPVE9UWVBFICAgICAgPSAncHJvdG90eXBlJ1xuICAsIEhJRERFTiAgICAgICAgID0gd2tzKCdfaGlkZGVuJylcbiAgLCBUT19QUklNSVRJVkUgICA9IHdrcygndG9QcmltaXRpdmUnKVxuICAsIGlzRW51bSAgICAgICAgID0ge30ucHJvcGVydHlJc0VudW1lcmFibGVcbiAgLCBTeW1ib2xSZWdpc3RyeSA9IHNoYXJlZCgnc3ltYm9sLXJlZ2lzdHJ5JylcbiAgLCBBbGxTeW1ib2xzICAgICA9IHNoYXJlZCgnc3ltYm9scycpXG4gICwgT1BTeW1ib2xzICAgICAgPSBzaGFyZWQoJ29wLXN5bWJvbHMnKVxuICAsIE9iamVjdFByb3RvICAgID0gT2JqZWN0W1BST1RPVFlQRV1cbiAgLCBVU0VfTkFUSVZFICAgICA9IHR5cGVvZiAkU3ltYm9sID09ICdmdW5jdGlvbidcbiAgLCBRT2JqZWN0ICAgICAgICA9IGdsb2JhbC5RT2JqZWN0O1xuLy8gRG9uJ3QgdXNlIHNldHRlcnMgaW4gUXQgU2NyaXB0LCBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTczXG52YXIgc2V0dGVyID0gIVFPYmplY3QgfHwgIVFPYmplY3RbUFJPVE9UWVBFXSB8fCAhUU9iamVjdFtQUk9UT1RZUEVdLmZpbmRDaGlsZDtcblxuLy8gZmFsbGJhY2sgZm9yIG9sZCBBbmRyb2lkLCBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9Njg3XG52YXIgc2V0U3ltYm9sRGVzYyA9IERFU0NSSVBUT1JTICYmICRmYWlscyhmdW5jdGlvbigpe1xuICByZXR1cm4gX2NyZWF0ZShkUCh7fSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gZFAodGhpcywgJ2EnLCB7dmFsdWU6IDd9KS5hOyB9XG4gIH0pKS5hICE9IDc7XG59KSA/IGZ1bmN0aW9uKGl0LCBrZXksIEQpe1xuICB2YXIgcHJvdG9EZXNjID0gZ09QRChPYmplY3RQcm90bywga2V5KTtcbiAgaWYocHJvdG9EZXNjKWRlbGV0ZSBPYmplY3RQcm90b1trZXldO1xuICBkUChpdCwga2V5LCBEKTtcbiAgaWYocHJvdG9EZXNjICYmIGl0ICE9PSBPYmplY3RQcm90bylkUChPYmplY3RQcm90bywga2V5LCBwcm90b0Rlc2MpO1xufSA6IGRQO1xuXG52YXIgd3JhcCA9IGZ1bmN0aW9uKHRhZyl7XG4gIHZhciBzeW0gPSBBbGxTeW1ib2xzW3RhZ10gPSBfY3JlYXRlKCRTeW1ib2xbUFJPVE9UWVBFXSk7XG4gIHN5bS5fayA9IHRhZztcbiAgcmV0dXJuIHN5bTtcbn07XG5cbnZhciBpc1N5bWJvbCA9IFVTRV9OQVRJVkUgJiYgdHlwZW9mICRTeW1ib2wuaXRlcmF0b3IgPT0gJ3N5bWJvbCcgPyBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG59IDogZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgaW5zdGFuY2VvZiAkU3ltYm9sO1xufTtcblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIEQpe1xuICBpZihpdCA9PT0gT2JqZWN0UHJvdG8pJGRlZmluZVByb3BlcnR5KE9QU3ltYm9scywga2V5LCBEKTtcbiAgYW5PYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBhbk9iamVjdChEKTtcbiAgaWYoaGFzKEFsbFN5bWJvbHMsIGtleSkpe1xuICAgIGlmKCFELmVudW1lcmFibGUpe1xuICAgICAgaWYoIWhhcyhpdCwgSElEREVOKSlkUChpdCwgSElEREVOLCBjcmVhdGVEZXNjKDEsIHt9KSk7XG4gICAgICBpdFtISURERU5dW2tleV0gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZihoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKWl0W0hJRERFTl1ba2V5XSA9IGZhbHNlO1xuICAgICAgRCA9IF9jcmVhdGUoRCwge2VudW1lcmFibGU6IGNyZWF0ZURlc2MoMCwgZmFsc2UpfSk7XG4gICAgfSByZXR1cm4gc2V0U3ltYm9sRGVzYyhpdCwga2V5LCBEKTtcbiAgfSByZXR1cm4gZFAoaXQsIGtleSwgRCk7XG59O1xudmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhpdCwgUCl7XG4gIGFuT2JqZWN0KGl0KTtcbiAgdmFyIGtleXMgPSBlbnVtS2V5cyhQID0gdG9JT2JqZWN0KFApKVxuICAgICwgaSAgICA9IDBcbiAgICAsIGwgPSBrZXlzLmxlbmd0aFxuICAgICwga2V5O1xuICB3aGlsZShsID4gaSkkZGVmaW5lUHJvcGVydHkoaXQsIGtleSA9IGtleXNbaSsrXSwgUFtrZXldKTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciAkY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGl0LCBQKXtcbiAgcmV0dXJuIFAgPT09IHVuZGVmaW5lZCA/IF9jcmVhdGUoaXQpIDogJGRlZmluZVByb3BlcnRpZXMoX2NyZWF0ZShpdCksIFApO1xufTtcbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShrZXkpe1xuICB2YXIgRSA9IGlzRW51bS5jYWxsKHRoaXMsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpO1xuICBpZih0aGlzID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSlyZXR1cm4gZmFsc2U7XG4gIHJldHVybiBFIHx8ICFoYXModGhpcywga2V5KSB8fCAhaGFzKEFsbFN5bWJvbHMsIGtleSkgfHwgaGFzKHRoaXMsIEhJRERFTikgJiYgdGhpc1tISURERU5dW2tleV0gPyBFIDogdHJ1ZTtcbn07XG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KXtcbiAgaXQgID0gdG9JT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgaWYoaXQgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKXJldHVybjtcbiAgdmFyIEQgPSBnT1BEKGl0LCBrZXkpO1xuICBpZihEICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICEoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkpRC5lbnVtZXJhYmxlID0gdHJ1ZTtcbiAgcmV0dXJuIEQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCl7XG4gIHZhciBuYW1lcyAgPSBnT1BOKHRvSU9iamVjdChpdCkpXG4gICAgLCByZXN1bHQgPSBbXVxuICAgICwgaSAgICAgID0gMFxuICAgICwga2V5O1xuICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKXtcbiAgICBpZighaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIGtleSAhPSBISURERU4gJiYga2V5ICE9IE1FVEEpcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KXtcbiAgdmFyIElTX09QICA9IGl0ID09PSBPYmplY3RQcm90b1xuICAgICwgbmFtZXMgID0gZ09QTihJU19PUCA/IE9QU3ltYm9scyA6IHRvSU9iamVjdChpdCkpXG4gICAgLCByZXN1bHQgPSBbXVxuICAgICwgaSAgICAgID0gMFxuICAgICwga2V5O1xuICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKXtcbiAgICBpZihoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYgKElTX09QID8gaGFzKE9iamVjdFByb3RvLCBrZXkpIDogdHJ1ZSkpcmVzdWx0LnB1c2goQWxsU3ltYm9sc1trZXldKTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gMTkuNC4xLjEgU3ltYm9sKFtkZXNjcmlwdGlvbl0pXG5pZighVVNFX05BVElWRSl7XG4gICRTeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2woKXtcbiAgICBpZih0aGlzIGluc3RhbmNlb2YgJFN5bWJvbCl0aHJvdyBUeXBlRXJyb3IoJ1N5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvciEnKTtcbiAgICB2YXIgdGFnID0gdWlkKGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgICB2YXIgJHNldCA9IGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgIGlmKHRoaXMgPT09IE9iamVjdFByb3RvKSRzZXQuY2FsbChPUFN5bWJvbHMsIHZhbHVlKTtcbiAgICAgIGlmKGhhcyh0aGlzLCBISURERU4pICYmIGhhcyh0aGlzW0hJRERFTl0sIHRhZykpdGhpc1tISURERU5dW3RhZ10gPSBmYWxzZTtcbiAgICAgIHNldFN5bWJvbERlc2ModGhpcywgdGFnLCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG4gICAgfTtcbiAgICBpZihERVNDUklQVE9SUyAmJiBzZXR0ZXIpc2V0U3ltYm9sRGVzYyhPYmplY3RQcm90bywgdGFnLCB7Y29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6ICRzZXR9KTtcbiAgICByZXR1cm4gd3JhcCh0YWcpO1xuICB9O1xuICByZWRlZmluZSgkU3ltYm9sW1BST1RPVFlQRV0sICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCl7XG4gICAgcmV0dXJuIHRoaXMuX2s7XG4gIH0pO1xuXG4gICRHT1BELmYgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAkRFAuZiAgID0gJGRlZmluZVByb3BlcnR5O1xuICByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmYgPSBnT1BORXh0LmYgPSAkZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpLmYgID0gJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuICByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpLmYgPSAkZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4gIGlmKERFU0NSSVBUT1JTICYmICFyZXF1aXJlKCcuL19saWJyYXJ5Jykpe1xuICAgIHJlZGVmaW5lKE9iamVjdFByb3RvLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAkcHJvcGVydHlJc0VudW1lcmFibGUsIHRydWUpO1xuICB9XG5cbiAgd2tzRXh0LmYgPSBmdW5jdGlvbihuYW1lKXtcbiAgICByZXR1cm4gd3JhcCh3a3MobmFtZSkpO1xuICB9XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHtTeW1ib2w6ICRTeW1ib2x9KTtcblxuZm9yKHZhciBzeW1ib2xzID0gKFxuICAvLyAxOS40LjIuMiwgMTkuNC4yLjMsIDE5LjQuMi40LCAxOS40LjIuNiwgMTkuNC4yLjgsIDE5LjQuMi45LCAxOS40LjIuMTAsIDE5LjQuMi4xMSwgMTkuNC4yLjEyLCAxOS40LjIuMTMsIDE5LjQuMi4xNFxuICAnaGFzSW5zdGFuY2UsaXNDb25jYXRTcHJlYWRhYmxlLGl0ZXJhdG9yLG1hdGNoLHJlcGxhY2Usc2VhcmNoLHNwZWNpZXMsc3BsaXQsdG9QcmltaXRpdmUsdG9TdHJpbmdUYWcsdW5zY29wYWJsZXMnXG4pLnNwbGl0KCcsJyksIGkgPSAwOyBzeW1ib2xzLmxlbmd0aCA+IGk7ICl3a3Moc3ltYm9sc1tpKytdKTtcblxuZm9yKHZhciBzeW1ib2xzID0gJGtleXMod2tzLnN0b3JlKSwgaSA9IDA7IHN5bWJvbHMubGVuZ3RoID4gaTsgKXdrc0RlZmluZShzeW1ib2xzW2krK10pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnU3ltYm9sJywge1xuICAvLyAxOS40LjIuMSBTeW1ib2wuZm9yKGtleSlcbiAgJ2Zvcic6IGZ1bmN0aW9uKGtleSl7XG4gICAgcmV0dXJuIGhhcyhTeW1ib2xSZWdpc3RyeSwga2V5ICs9ICcnKVxuICAgICAgPyBTeW1ib2xSZWdpc3RyeVtrZXldXG4gICAgICA6IFN5bWJvbFJlZ2lzdHJ5W2tleV0gPSAkU3ltYm9sKGtleSk7XG4gIH0sXG4gIC8vIDE5LjQuMi41IFN5bWJvbC5rZXlGb3Ioc3ltKVxuICBrZXlGb3I6IGZ1bmN0aW9uIGtleUZvcihrZXkpe1xuICAgIGlmKGlzU3ltYm9sKGtleSkpcmV0dXJuIGtleU9mKFN5bWJvbFJlZ2lzdHJ5LCBrZXkpO1xuICAgIHRocm93IFR5cGVFcnJvcihrZXkgKyAnIGlzIG5vdCBhIHN5bWJvbCEnKTtcbiAgfSxcbiAgdXNlU2V0dGVyOiBmdW5jdGlvbigpeyBzZXR0ZXIgPSB0cnVlOyB9LFxuICB1c2VTaW1wbGU6IGZ1bmN0aW9uKCl7IHNldHRlciA9IGZhbHNlOyB9XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ09iamVjdCcsIHtcbiAgLy8gMTkuMS4yLjIgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuICBjcmVhdGU6ICRjcmVhdGUsXG4gIC8vIDE5LjEuMi40IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxuICAvLyAxOS4xLjIuMyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKVxuICBkZWZpbmVQcm9wZXJ0aWVzOiAkZGVmaW5lUHJvcGVydGllcyxcbiAgLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gIC8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG4gIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICAvLyAxOS4xLjIuOCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pXG4gIGdldE93blByb3BlcnR5U3ltYm9sczogJGdldE93blByb3BlcnR5U3ltYm9sc1xufSk7XG5cbi8vIDI0LjMuMiBKU09OLnN0cmluZ2lmeSh2YWx1ZSBbLCByZXBsYWNlciBbLCBzcGFjZV1dKVxuJEpTT04gJiYgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoIVVTRV9OQVRJVkUgfHwgJGZhaWxzKGZ1bmN0aW9uKCl7XG4gIHZhciBTID0gJFN5bWJvbCgpO1xuICAvLyBNUyBFZGdlIGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyB7fVxuICAvLyBXZWJLaXQgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIG51bGxcbiAgLy8gVjggdGhyb3dzIG9uIGJveGVkIHN5bWJvbHNcbiAgcmV0dXJuIF9zdHJpbmdpZnkoW1NdKSAhPSAnW251bGxdJyB8fCBfc3RyaW5naWZ5KHthOiBTfSkgIT0gJ3t9JyB8fCBfc3RyaW5naWZ5KE9iamVjdChTKSkgIT0gJ3t9Jztcbn0pKSwgJ0pTT04nLCB7XG4gIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KGl0KXtcbiAgICBpZihpdCA9PT0gdW5kZWZpbmVkIHx8IGlzU3ltYm9sKGl0KSlyZXR1cm47IC8vIElFOCByZXR1cm5zIHN0cmluZyBvbiB1bmRlZmluZWRcbiAgICB2YXIgYXJncyA9IFtpdF1cbiAgICAgICwgaSAgICA9IDFcbiAgICAgICwgcmVwbGFjZXIsICRyZXBsYWNlcjtcbiAgICB3aGlsZShhcmd1bWVudHMubGVuZ3RoID4gaSlhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgIHJlcGxhY2VyID0gYXJnc1sxXTtcbiAgICBpZih0eXBlb2YgcmVwbGFjZXIgPT0gJ2Z1bmN0aW9uJykkcmVwbGFjZXIgPSByZXBsYWNlcjtcbiAgICBpZigkcmVwbGFjZXIgfHwgIWlzQXJyYXkocmVwbGFjZXIpKXJlcGxhY2VyID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSl7XG4gICAgICBpZigkcmVwbGFjZXIpdmFsdWUgPSAkcmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgIGlmKCFpc1N5bWJvbCh2YWx1ZSkpcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgYXJnc1sxXSA9IHJlcGxhY2VyO1xuICAgIHJldHVybiBfc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmdzKTtcbiAgfVxufSk7XG5cbi8vIDE5LjQuMy40IFN5bWJvbC5wcm90b3R5cGVbQEB0b1ByaW1pdGl2ZV0oaGludClcbiRTeW1ib2xbUFJPVE9UWVBFXVtUT19QUklNSVRJVkVdIHx8IHJlcXVpcmUoJy4vX2hpZGUnKSgkU3ltYm9sW1BST1RPVFlQRV0sIFRPX1BSSU1JVElWRSwgJFN5bWJvbFtQUk9UT1RZUEVdLnZhbHVlT2YpO1xuLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoJFN5bWJvbCwgJ1N5bWJvbCcpO1xuLy8gMjAuMi4xLjkgTWF0aFtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoTWF0aCwgJ01hdGgnLCB0cnVlKTtcbi8vIDI0LjMuMyBKU09OW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhnbG9iYWwuSlNPTiwgJ0pTT04nLCB0cnVlKTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkdHlwZWQgICAgICAgPSByZXF1aXJlKCcuL190eXBlZCcpXG4gICwgYnVmZmVyICAgICAgID0gcmVxdWlyZSgnLi9fdHlwZWQtYnVmZmVyJylcbiAgLCBhbk9iamVjdCAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIHRvSW5kZXggICAgICA9IHJlcXVpcmUoJy4vX3RvLWluZGV4JylcbiAgLCB0b0xlbmd0aCAgICAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGlzT2JqZWN0ICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgQXJyYXlCdWZmZXIgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuQXJyYXlCdWZmZXJcbiAgLCBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJylcbiAgLCAkQXJyYXlCdWZmZXIgPSBidWZmZXIuQXJyYXlCdWZmZXJcbiAgLCAkRGF0YVZpZXcgICAgPSBidWZmZXIuRGF0YVZpZXdcbiAgLCAkaXNWaWV3ICAgICAgPSAkdHlwZWQuQUJWICYmIEFycmF5QnVmZmVyLmlzVmlld1xuICAsICRzbGljZSAgICAgICA9ICRBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2VcbiAgLCBWSUVXICAgICAgICAgPSAkdHlwZWQuVklFV1xuICAsIEFSUkFZX0JVRkZFUiA9ICdBcnJheUJ1ZmZlcic7XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogKEFycmF5QnVmZmVyICE9PSAkQXJyYXlCdWZmZXIpLCB7QXJyYXlCdWZmZXI6ICRBcnJheUJ1ZmZlcn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEkdHlwZWQuQ09OU1RSLCBBUlJBWV9CVUZGRVIsIHtcbiAgLy8gMjQuMS4zLjEgQXJyYXlCdWZmZXIuaXNWaWV3KGFyZylcbiAgaXNWaWV3OiBmdW5jdGlvbiBpc1ZpZXcoaXQpe1xuICAgIHJldHVybiAkaXNWaWV3ICYmICRpc1ZpZXcoaXQpIHx8IGlzT2JqZWN0KGl0KSAmJiBWSUVXIGluIGl0O1xuICB9XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LlUgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiAhbmV3ICRBcnJheUJ1ZmZlcigyKS5zbGljZSgxLCB1bmRlZmluZWQpLmJ5dGVMZW5ndGg7XG59KSwgQVJSQVlfQlVGRkVSLCB7XG4gIC8vIDI0LjEuNC4zIEFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZShzdGFydCwgZW5kKVxuICBzbGljZTogZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCl7XG4gICAgaWYoJHNsaWNlICE9PSB1bmRlZmluZWQgJiYgZW5kID09PSB1bmRlZmluZWQpcmV0dXJuICRzbGljZS5jYWxsKGFuT2JqZWN0KHRoaXMpLCBzdGFydCk7IC8vIEZGIGZpeFxuICAgIHZhciBsZW4gICAgPSBhbk9iamVjdCh0aGlzKS5ieXRlTGVuZ3RoXG4gICAgICAsIGZpcnN0ICA9IHRvSW5kZXgoc3RhcnQsIGxlbilcbiAgICAgICwgZmluYWwgID0gdG9JbmRleChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IGVuZCwgbGVuKVxuICAgICAgLCByZXN1bHQgPSBuZXcgKHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCAkQXJyYXlCdWZmZXIpKSh0b0xlbmd0aChmaW5hbCAtIGZpcnN0KSlcbiAgICAgICwgdmlld1MgID0gbmV3ICREYXRhVmlldyh0aGlzKVxuICAgICAgLCB2aWV3VCAgPSBuZXcgJERhdGFWaWV3KHJlc3VsdClcbiAgICAgICwgaW5kZXggID0gMDtcbiAgICB3aGlsZShmaXJzdCA8IGZpbmFsKXtcbiAgICAgIHZpZXdULnNldFVpbnQ4KGluZGV4KyssIHZpZXdTLmdldFVpbnQ4KGZpcnN0KyspKTtcbiAgICB9IHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuXG5yZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKEFSUkFZX0JVRkZFUik7IiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3R5cGVkJykuQUJWLCB7XG4gIERhdGFWaWV3OiByZXF1aXJlKCcuL190eXBlZC1idWZmZXInKS5EYXRhVmlld1xufSk7IiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnRmxvYXQzMicsIDQsIGZ1bmN0aW9uKGluaXQpe1xuICByZXR1cm4gZnVuY3Rpb24gRmxvYXQzMkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCl7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pOyIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0Zsb2F0NjQnLCA4LCBmdW5jdGlvbihpbml0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIEZsb2F0NjRBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpe1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTsiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdJbnQxNicsIDIsIGZ1bmN0aW9uKGluaXQpe1xuICByZXR1cm4gZnVuY3Rpb24gSW50MTZBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpe1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTsiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdJbnQzMicsIDQsIGZ1bmN0aW9uKGluaXQpe1xuICByZXR1cm4gZnVuY3Rpb24gSW50MzJBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpe1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTsiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdJbnQ4JywgMSwgZnVuY3Rpb24oaW5pdCl7XG4gIHJldHVybiBmdW5jdGlvbiBJbnQ4QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKXtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7IiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnVWludDE2JywgMiwgZnVuY3Rpb24oaW5pdCl7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50MTZBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpe1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTsiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdVaW50MzInLCA0LCBmdW5jdGlvbihpbml0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIFVpbnQzMkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCl7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pOyIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ1VpbnQ4JywgMSwgZnVuY3Rpb24oaW5pdCl7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50OEFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCl7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pOyIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ1VpbnQ4JywgMSwgZnVuY3Rpb24oaW5pdCl7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50OENsYW1wZWRBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpe1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59LCB0cnVlKTsiLCIndXNlIHN0cmljdCc7XG52YXIgZWFjaCAgICAgICAgID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDApXG4gICwgcmVkZWZpbmUgICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKVxuICAsIG1ldGEgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGEnKVxuICAsIGFzc2lnbiAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1hc3NpZ24nKVxuICAsIHdlYWsgICAgICAgICA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24td2VhaycpXG4gICwgaXNPYmplY3QgICAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBnZXRXZWFrICAgICAgPSBtZXRhLmdldFdlYWtcbiAgLCBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlXG4gICwgdW5jYXVnaHRGcm96ZW5TdG9yZSA9IHdlYWsudWZzdG9yZVxuICAsIHRtcCAgICAgICAgICA9IHt9XG4gICwgSW50ZXJuYWxNYXA7XG5cbnZhciB3cmFwcGVyID0gZnVuY3Rpb24oZ2V0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIFdlYWtNYXAoKXtcbiAgICByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgfTtcbn07XG5cbnZhciBtZXRob2RzID0ge1xuICAvLyAyMy4zLjMuMyBXZWFrTWFwLnByb3RvdHlwZS5nZXQoa2V5KVxuICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpe1xuICAgIGlmKGlzT2JqZWN0KGtleSkpe1xuICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrKGtleSk7XG4gICAgICBpZihkYXRhID09PSB0cnVlKXJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHRoaXMpLmdldChrZXkpO1xuICAgICAgcmV0dXJuIGRhdGEgPyBkYXRhW3RoaXMuX2ldIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfSxcbiAgLy8gMjMuMy4zLjUgV2Vha01hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXG4gIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpe1xuICAgIHJldHVybiB3ZWFrLmRlZih0aGlzLCBrZXksIHZhbHVlKTtcbiAgfVxufTtcblxuLy8gMjMuMyBXZWFrTWFwIE9iamVjdHNcbnZhciAkV2Vha01hcCA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKCdXZWFrTWFwJywgd3JhcHBlciwgbWV0aG9kcywgd2VhaywgdHJ1ZSwgdHJ1ZSk7XG5cbi8vIElFMTEgV2Vha01hcCBmcm96ZW4ga2V5cyBmaXhcbmlmKG5ldyAkV2Vha01hcCgpLnNldCgoT2JqZWN0LmZyZWV6ZSB8fCBPYmplY3QpKHRtcCksIDcpLmdldCh0bXApICE9IDcpe1xuICBJbnRlcm5hbE1hcCA9IHdlYWsuZ2V0Q29uc3RydWN0b3Iod3JhcHBlcik7XG4gIGFzc2lnbihJbnRlcm5hbE1hcC5wcm90b3R5cGUsIG1ldGhvZHMpO1xuICBtZXRhLk5FRUQgPSB0cnVlO1xuICBlYWNoKFsnZGVsZXRlJywgJ2hhcycsICdnZXQnLCAnc2V0J10sIGZ1bmN0aW9uKGtleSl7XG4gICAgdmFyIHByb3RvICA9ICRXZWFrTWFwLnByb3RvdHlwZVxuICAgICAgLCBtZXRob2QgPSBwcm90b1trZXldO1xuICAgIHJlZGVmaW5lKHByb3RvLCBrZXksIGZ1bmN0aW9uKGEsIGIpe1xuICAgICAgLy8gc3RvcmUgZnJvemVuIG9iamVjdHMgb24gaW50ZXJuYWwgd2Vha21hcCBzaGltXG4gICAgICBpZihpc09iamVjdChhKSAmJiAhaXNFeHRlbnNpYmxlKGEpKXtcbiAgICAgICAgaWYoIXRoaXMuX2YpdGhpcy5fZiA9IG5ldyBJbnRlcm5hbE1hcDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX2Zba2V5XShhLCBiKTtcbiAgICAgICAgcmV0dXJuIGtleSA9PSAnc2V0JyA/IHRoaXMgOiByZXN1bHQ7XG4gICAgICAvLyBzdG9yZSBhbGwgdGhlIHJlc3Qgb24gbmF0aXZlIHdlYWttYXBcbiAgICAgIH0gcmV0dXJuIG1ldGhvZC5jYWxsKHRoaXMsIGEsIGIpO1xuICAgIH0pO1xuICB9KTtcbn0iLCIndXNlIHN0cmljdCc7XG52YXIgd2VhayA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24td2VhaycpO1xuXG4vLyAyMy40IFdlYWtTZXQgT2JqZWN0c1xucmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKCdXZWFrU2V0JywgZnVuY3Rpb24oZ2V0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIFdlYWtTZXQoKXsgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7IH07XG59LCB7XG4gIC8vIDIzLjQuMy4xIFdlYWtTZXQucHJvdG90eXBlLmFkZCh2YWx1ZSlcbiAgYWRkOiBmdW5jdGlvbiBhZGQodmFsdWUpe1xuICAgIHJldHVybiB3ZWFrLmRlZih0aGlzLCB2YWx1ZSwgdHJ1ZSk7XG4gIH1cbn0sIHdlYWssIGZhbHNlLCB0cnVlKTsiLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9BcnJheS5wcm90b3R5cGUuaW5jbHVkZXNcbnZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRpbmNsdWRlcyA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykodHJ1ZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnQXJyYXknLCB7XG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhlbCAvKiwgZnJvbUluZGV4ID0gMCAqLyl7XG4gICAgcmV0dXJuICRpbmNsdWRlcyh0aGlzLCBlbCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcblxucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoJ2luY2x1ZGVzJyk7IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3J3YWxkcm9uL3RjMzktbm90ZXMvYmxvYi9tYXN0ZXIvZXM2LzIwMTQtMDkvc2VwdC0yNS5tZCM1MTAtZ2xvYmFsYXNhcC1mb3ItZW5xdWV1aW5nLWEtbWljcm90YXNrXG52YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBtaWNyb3Rhc2sgPSByZXF1aXJlKCcuL19taWNyb3Rhc2snKSgpXG4gICwgcHJvY2VzcyAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykucHJvY2Vzc1xuICAsIGlzTm9kZSAgICA9IHJlcXVpcmUoJy4vX2NvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJztcblxuJGV4cG9ydCgkZXhwb3J0LkcsIHtcbiAgYXNhcDogZnVuY3Rpb24gYXNhcChmbil7XG4gICAgdmFyIGRvbWFpbiA9IGlzTm9kZSAmJiBwcm9jZXNzLmRvbWFpbjtcbiAgICBtaWNyb3Rhc2soZG9tYWluID8gZG9tYWluLmJpbmQoZm4pIDogZm4pO1xuICB9XG59KTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vbGpoYXJiL3Byb3Bvc2FsLWlzLWVycm9yXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgY29mICAgICA9IHJlcXVpcmUoJy4vX2NvZicpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ0Vycm9yJywge1xuICBpc0Vycm9yOiBmdW5jdGlvbiBpc0Vycm9yKGl0KXtcbiAgICByZXR1cm4gY29mKGl0KSA9PT0gJ0Vycm9yJztcbiAgfVxufSk7IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyICRleHBvcnQgID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5SLCAnTWFwJywge3RvSlNPTjogcmVxdWlyZSgnLi9fY29sbGVjdGlvbi10by1qc29uJykoJ01hcCcpfSk7IiwiLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vQnJlbmRhbkVpY2gvNDI5NGQ1YzIxMmE2ZDIyNTQ3MDNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgaWFkZGg6IGZ1bmN0aW9uIGlhZGRoKHgwLCB4MSwgeTAsIHkxKXtcbiAgICB2YXIgJHgwID0geDAgPj4+IDBcbiAgICAgICwgJHgxID0geDEgPj4+IDBcbiAgICAgICwgJHkwID0geTAgPj4+IDA7XG4gICAgcmV0dXJuICR4MSArICh5MSA+Pj4gMCkgKyAoKCR4MCAmICR5MCB8ICgkeDAgfCAkeTApICYgfigkeDAgKyAkeTAgPj4+IDApKSA+Pj4gMzEpIHwgMDtcbiAgfVxufSk7IiwiLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vQnJlbmRhbkVpY2gvNDI5NGQ1YzIxMmE2ZDIyNTQ3MDNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgaW11bGg6IGZ1bmN0aW9uIGltdWxoKHUsIHYpe1xuICAgIHZhciBVSU5UMTYgPSAweGZmZmZcbiAgICAgICwgJHUgPSArdVxuICAgICAgLCAkdiA9ICt2XG4gICAgICAsIHUwID0gJHUgJiBVSU5UMTZcbiAgICAgICwgdjAgPSAkdiAmIFVJTlQxNlxuICAgICAgLCB1MSA9ICR1ID4+IDE2XG4gICAgICAsIHYxID0gJHYgPj4gMTZcbiAgICAgICwgdCAgPSAodTEgKiB2MCA+Pj4gMCkgKyAodTAgKiB2MCA+Pj4gMTYpO1xuICAgIHJldHVybiB1MSAqIHYxICsgKHQgPj4gMTYpICsgKCh1MCAqIHYxID4+PiAwKSArICh0ICYgVUlOVDE2KSA+PiAxNik7XG4gIH1cbn0pOyIsIi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL0JyZW5kYW5FaWNoLzQyOTRkNWMyMTJhNmQyMjU0NzAzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGlzdWJoOiBmdW5jdGlvbiBpc3ViaCh4MCwgeDEsIHkwLCB5MSl7XG4gICAgdmFyICR4MCA9IHgwID4+PiAwXG4gICAgICAsICR4MSA9IHgxID4+PiAwXG4gICAgICAsICR5MCA9IHkwID4+PiAwO1xuICAgIHJldHVybiAkeDEgLSAoeTEgPj4+IDApIC0gKCh+JHgwICYgJHkwIHwgfigkeDAgXiAkeTApICYgJHgwIC0gJHkwID4+PiAwKSA+Pj4gMzEpIHwgMDtcbiAgfVxufSk7IiwiLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vQnJlbmRhbkVpY2gvNDI5NGQ1YzIxMmE2ZDIyNTQ3MDNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgdW11bGg6IGZ1bmN0aW9uIHVtdWxoKHUsIHYpe1xuICAgIHZhciBVSU5UMTYgPSAweGZmZmZcbiAgICAgICwgJHUgPSArdVxuICAgICAgLCAkdiA9ICt2XG4gICAgICAsIHUwID0gJHUgJiBVSU5UMTZcbiAgICAgICwgdjAgPSAkdiAmIFVJTlQxNlxuICAgICAgLCB1MSA9ICR1ID4+PiAxNlxuICAgICAgLCB2MSA9ICR2ID4+PiAxNlxuICAgICAgLCB0ICA9ICh1MSAqIHYwID4+PiAwKSArICh1MCAqIHYwID4+PiAxNik7XG4gICAgcmV0dXJuIHUxICogdjEgKyAodCA+Pj4gMTYpICsgKCh1MCAqIHYxID4+PiAwKSArICh0ICYgVUlOVDE2KSA+Pj4gMTYpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b09iamVjdCAgICAgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIGFGdW5jdGlvbiAgICAgICA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKVxuICAsICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xuXG4vLyBCLjIuMi4yIE9iamVjdC5wcm90b3R5cGUuX19kZWZpbmVHZXR0ZXJfXyhQLCBnZXR0ZXIpXG5yZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICRleHBvcnQoJGV4cG9ydC5QICsgcmVxdWlyZSgnLi9fb2JqZWN0LWZvcmNlZC1wYW0nKSwgJ09iamVjdCcsIHtcbiAgX19kZWZpbmVHZXR0ZXJfXzogZnVuY3Rpb24gX19kZWZpbmVHZXR0ZXJfXyhQLCBnZXR0ZXIpe1xuICAgICRkZWZpbmVQcm9wZXJ0eS5mKHRvT2JqZWN0KHRoaXMpLCBQLCB7Z2V0OiBhRnVuY3Rpb24oZ2V0dGVyKSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvT2JqZWN0ICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgYUZ1bmN0aW9uICAgICAgID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgJGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG5cbi8vIEIuMi4yLjMgT2JqZWN0LnByb3RvdHlwZS5fX2RlZmluZVNldHRlcl9fKFAsIHNldHRlcilcbnJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgJGV4cG9ydCgkZXhwb3J0LlAgKyByZXF1aXJlKCcuL19vYmplY3QtZm9yY2VkLXBhbScpLCAnT2JqZWN0Jywge1xuICBfX2RlZmluZVNldHRlcl9fOiBmdW5jdGlvbiBfX2RlZmluZVNldHRlcl9fKFAsIHNldHRlcil7XG4gICAgJGRlZmluZVByb3BlcnR5LmYodG9PYmplY3QodGhpcyksIFAsIHtzZXQ6IGFGdW5jdGlvbihzZXR0ZXIpLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9KTtcbiAgfVxufSk7IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JqZWN0LXZhbHVlcy1lbnRyaWVzXG52YXIgJGV4cG9ydCAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRlbnRyaWVzID0gcmVxdWlyZSgnLi9fb2JqZWN0LXRvLWFycmF5JykodHJ1ZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge1xuICBlbnRyaWVzOiBmdW5jdGlvbiBlbnRyaWVzKGl0KXtcbiAgICByZXR1cm4gJGVudHJpZXMoaXQpO1xuICB9XG59KTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yc1xudmFyICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBvd25LZXlzICAgICAgICA9IHJlcXVpcmUoJy4vX293bi1rZXlzJylcbiAgLCB0b0lPYmplY3QgICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIGdPUEQgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKVxuICAsIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fY3JlYXRlLXByb3BlcnR5Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge1xuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iamVjdCl7XG4gICAgdmFyIE8gICAgICAgPSB0b0lPYmplY3Qob2JqZWN0KVxuICAgICAgLCBnZXREZXNjID0gZ09QRC5mXG4gICAgICAsIGtleXMgICAgPSBvd25LZXlzKE8pXG4gICAgICAsIHJlc3VsdCAgPSB7fVxuICAgICAgLCBpICAgICAgID0gMFxuICAgICAgLCBrZXk7XG4gICAgd2hpbGUoa2V5cy5sZW5ndGggPiBpKWNyZWF0ZVByb3BlcnR5KHJlc3VsdCwga2V5ID0ga2V5c1tpKytdLCBnZXREZXNjKE8sIGtleSkpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvT2JqZWN0ICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgdG9QcmltaXRpdmUgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBnZXRQcm90b3R5cGVPZiAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmY7XG5cbi8vIEIuMi4yLjQgT2JqZWN0LnByb3RvdHlwZS5fX2xvb2t1cEdldHRlcl9fKFApXG5yZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICRleHBvcnQoJGV4cG9ydC5QICsgcmVxdWlyZSgnLi9fb2JqZWN0LWZvcmNlZC1wYW0nKSwgJ09iamVjdCcsIHtcbiAgX19sb29rdXBHZXR0ZXJfXzogZnVuY3Rpb24gX19sb29rdXBHZXR0ZXJfXyhQKXtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpXG4gICAgICAsIEsgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKVxuICAgICAgLCBEO1xuICAgIGRvIHtcbiAgICAgIGlmKEQgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgSykpcmV0dXJuIEQuZ2V0O1xuICAgIH0gd2hpbGUoTyA9IGdldFByb3RvdHlwZU9mKE8pKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9PYmplY3QgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCB0b1ByaW1pdGl2ZSAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGdldFByb3RvdHlwZU9mICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZjtcblxuLy8gQi4yLjIuNSBPYmplY3QucHJvdG90eXBlLl9fbG9va3VwU2V0dGVyX18oUClcbnJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgJGV4cG9ydCgkZXhwb3J0LlAgKyByZXF1aXJlKCcuL19vYmplY3QtZm9yY2VkLXBhbScpLCAnT2JqZWN0Jywge1xuICBfX2xvb2t1cFNldHRlcl9fOiBmdW5jdGlvbiBfX2xvb2t1cFNldHRlcl9fKFApe1xuICAgIHZhciBPID0gdG9PYmplY3QodGhpcylcbiAgICAgICwgSyA9IHRvUHJpbWl0aXZlKFAsIHRydWUpXG4gICAgICAsIEQ7XG4gICAgZG8ge1xuICAgICAgaWYoRCA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBLKSlyZXR1cm4gRC5zZXQ7XG4gICAgfSB3aGlsZShPID0gZ2V0UHJvdG90eXBlT2YoTykpO1xuICB9XG59KTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1vYmplY3QtdmFsdWVzLWVudHJpZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkdmFsdWVzID0gcmVxdWlyZSgnLi9fb2JqZWN0LXRvLWFycmF5JykoZmFsc2UpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtcbiAgdmFsdWVzOiBmdW5jdGlvbiB2YWx1ZXMoaXQpe1xuICAgIHJldHVybiAkdmFsdWVzKGl0KTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3plbnBhcnNpbmcvZXMtb2JzZXJ2YWJsZVxudmFyICRleHBvcnQgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBnbG9iYWwgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgY29yZSAgICAgICAgPSByZXF1aXJlKCcuL19jb3JlJylcbiAgLCBtaWNyb3Rhc2sgICA9IHJlcXVpcmUoJy4vX21pY3JvdGFzaycpKClcbiAgLCBPQlNFUlZBQkxFICA9IHJlcXVpcmUoJy4vX3drcycpKCdvYnNlcnZhYmxlJylcbiAgLCBhRnVuY3Rpb24gICA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKVxuICAsIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBhbkluc3RhbmNlICA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJylcbiAgLCByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpXG4gICwgaGlkZSAgICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCBmb3JPZiAgICAgICA9IHJlcXVpcmUoJy4vX2Zvci1vZicpXG4gICwgUkVUVVJOICAgICAgPSBmb3JPZi5SRVRVUk47XG5cbnZhciBnZXRNZXRob2QgPSBmdW5jdGlvbihmbil7XG4gIHJldHVybiBmbiA9PSBudWxsID8gdW5kZWZpbmVkIDogYUZ1bmN0aW9uKGZuKTtcbn07XG5cbnZhciBjbGVhbnVwU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24oc3Vic2NyaXB0aW9uKXtcbiAgdmFyIGNsZWFudXAgPSBzdWJzY3JpcHRpb24uX2M7XG4gIGlmKGNsZWFudXApe1xuICAgIHN1YnNjcmlwdGlvbi5fYyA9IHVuZGVmaW5lZDtcbiAgICBjbGVhbnVwKCk7XG4gIH1cbn07XG5cbnZhciBzdWJzY3JpcHRpb25DbG9zZWQgPSBmdW5jdGlvbihzdWJzY3JpcHRpb24pe1xuICByZXR1cm4gc3Vic2NyaXB0aW9uLl9vID09PSB1bmRlZmluZWQ7XG59O1xuXG52YXIgY2xvc2VTdWJzY3JpcHRpb24gPSBmdW5jdGlvbihzdWJzY3JpcHRpb24pe1xuICBpZighc3Vic2NyaXB0aW9uQ2xvc2VkKHN1YnNjcmlwdGlvbikpe1xuICAgIHN1YnNjcmlwdGlvbi5fbyA9IHVuZGVmaW5lZDtcbiAgICBjbGVhbnVwU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gIH1cbn07XG5cbnZhciBTdWJzY3JpcHRpb24gPSBmdW5jdGlvbihvYnNlcnZlciwgc3Vic2NyaWJlcil7XG4gIGFuT2JqZWN0KG9ic2VydmVyKTtcbiAgdGhpcy5fYyA9IHVuZGVmaW5lZDtcbiAgdGhpcy5fbyA9IG9ic2VydmVyO1xuICBvYnNlcnZlciA9IG5ldyBTdWJzY3JpcHRpb25PYnNlcnZlcih0aGlzKTtcbiAgdHJ5IHtcbiAgICB2YXIgY2xlYW51cCAgICAgID0gc3Vic2NyaWJlcihvYnNlcnZlcilcbiAgICAgICwgc3Vic2NyaXB0aW9uID0gY2xlYW51cDtcbiAgICBpZihjbGVhbnVwICE9IG51bGwpe1xuICAgICAgaWYodHlwZW9mIGNsZWFudXAudW5zdWJzY3JpYmUgPT09ICdmdW5jdGlvbicpY2xlYW51cCA9IGZ1bmN0aW9uKCl7IHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpOyB9O1xuICAgICAgZWxzZSBhRnVuY3Rpb24oY2xlYW51cCk7XG4gICAgICB0aGlzLl9jID0gY2xlYW51cDtcbiAgICB9XG4gIH0gY2F0Y2goZSl7XG4gICAgb2JzZXJ2ZXIuZXJyb3IoZSk7XG4gICAgcmV0dXJuO1xuICB9IGlmKHN1YnNjcmlwdGlvbkNsb3NlZCh0aGlzKSljbGVhbnVwU3Vic2NyaXB0aW9uKHRoaXMpO1xufTtcblxuU3Vic2NyaXB0aW9uLnByb3RvdHlwZSA9IHJlZGVmaW5lQWxsKHt9LCB7XG4gIHVuc3Vic2NyaWJlOiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpeyBjbG9zZVN1YnNjcmlwdGlvbih0aGlzKTsgfVxufSk7XG5cbnZhciBTdWJzY3JpcHRpb25PYnNlcnZlciA9IGZ1bmN0aW9uKHN1YnNjcmlwdGlvbil7XG4gIHRoaXMuX3MgPSBzdWJzY3JpcHRpb247XG59O1xuXG5TdWJzY3JpcHRpb25PYnNlcnZlci5wcm90b3R5cGUgPSByZWRlZmluZUFsbCh7fSwge1xuICBuZXh0OiBmdW5jdGlvbiBuZXh0KHZhbHVlKXtcbiAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhpcy5fcztcbiAgICBpZighc3Vic2NyaXB0aW9uQ2xvc2VkKHN1YnNjcmlwdGlvbikpe1xuICAgICAgdmFyIG9ic2VydmVyID0gc3Vic2NyaXB0aW9uLl9vO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG0gPSBnZXRNZXRob2Qob2JzZXJ2ZXIubmV4dCk7XG4gICAgICAgIGlmKG0pcmV0dXJuIG0uY2FsbChvYnNlcnZlciwgdmFsdWUpO1xuICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjbG9zZVN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGVycm9yOiBmdW5jdGlvbiBlcnJvcih2YWx1ZSl7XG4gICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMuX3M7XG4gICAgaWYoc3Vic2NyaXB0aW9uQ2xvc2VkKHN1YnNjcmlwdGlvbikpdGhyb3cgdmFsdWU7XG4gICAgdmFyIG9ic2VydmVyID0gc3Vic2NyaXB0aW9uLl9vO1xuICAgIHN1YnNjcmlwdGlvbi5fbyA9IHVuZGVmaW5lZDtcbiAgICB0cnkge1xuICAgICAgdmFyIG0gPSBnZXRNZXRob2Qob2JzZXJ2ZXIuZXJyb3IpO1xuICAgICAgaWYoIW0pdGhyb3cgdmFsdWU7XG4gICAgICB2YWx1ZSA9IG0uY2FsbChvYnNlcnZlciwgdmFsdWUpO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICB0cnkge1xuICAgICAgICBjbGVhbnVwU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0gY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcbiAgY29tcGxldGU6IGZ1bmN0aW9uIGNvbXBsZXRlKHZhbHVlKXtcbiAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhpcy5fcztcbiAgICBpZighc3Vic2NyaXB0aW9uQ2xvc2VkKHN1YnNjcmlwdGlvbikpe1xuICAgICAgdmFyIG9ic2VydmVyID0gc3Vic2NyaXB0aW9uLl9vO1xuICAgICAgc3Vic2NyaXB0aW9uLl9vID0gdW5kZWZpbmVkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG0gPSBnZXRNZXRob2Qob2JzZXJ2ZXIuY29tcGxldGUpO1xuICAgICAgICB2YWx1ZSA9IG0gPyBtLmNhbGwob2JzZXJ2ZXIsIHZhbHVlKSA6IHVuZGVmaW5lZDtcbiAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH0gY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxufSk7XG5cbnZhciAkT2JzZXJ2YWJsZSA9IGZ1bmN0aW9uIE9ic2VydmFibGUoc3Vic2NyaWJlcil7XG4gIGFuSW5zdGFuY2UodGhpcywgJE9ic2VydmFibGUsICdPYnNlcnZhYmxlJywgJ19mJykuX2YgPSBhRnVuY3Rpb24oc3Vic2NyaWJlcik7XG59O1xuXG5yZWRlZmluZUFsbCgkT2JzZXJ2YWJsZS5wcm90b3R5cGUsIHtcbiAgc3Vic2NyaWJlOiBmdW5jdGlvbiBzdWJzY3JpYmUob2JzZXJ2ZXIpe1xuICAgIHJldHVybiBuZXcgU3Vic2NyaXB0aW9uKG9ic2VydmVyLCB0aGlzLl9mKTtcbiAgfSxcbiAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChmbil7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgKGNvcmUuUHJvbWlzZSB8fCBnbG9iYWwuUHJvbWlzZSkoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICAgIGFGdW5jdGlvbihmbik7XG4gICAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhhdC5zdWJzY3JpYmUoe1xuICAgICAgICBuZXh0IDogZnVuY3Rpb24odmFsdWUpe1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZm4odmFsdWUpO1xuICAgICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiByZWplY3QsXG4gICAgICAgIGNvbXBsZXRlOiByZXNvbHZlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufSk7XG5cbnJlZGVmaW5lQWxsKCRPYnNlcnZhYmxlLCB7XG4gIGZyb206IGZ1bmN0aW9uIGZyb20oeCl7XG4gICAgdmFyIEMgPSB0eXBlb2YgdGhpcyA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiAkT2JzZXJ2YWJsZTtcbiAgICB2YXIgbWV0aG9kID0gZ2V0TWV0aG9kKGFuT2JqZWN0KHgpW09CU0VSVkFCTEVdKTtcbiAgICBpZihtZXRob2Qpe1xuICAgICAgdmFyIG9ic2VydmFibGUgPSBhbk9iamVjdChtZXRob2QuY2FsbCh4KSk7XG4gICAgICByZXR1cm4gb2JzZXJ2YWJsZS5jb25zdHJ1Y3RvciA9PT0gQyA/IG9ic2VydmFibGUgOiBuZXcgQyhmdW5jdGlvbihvYnNlcnZlcil7XG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlLnN1YnNjcmliZShvYnNlcnZlcik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDKGZ1bmN0aW9uKG9ic2VydmVyKXtcbiAgICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgICBtaWNyb3Rhc2soZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoIWRvbmUpe1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZihmb3JPZih4LCBmYWxzZSwgZnVuY3Rpb24oaXQpe1xuICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KGl0KTtcbiAgICAgICAgICAgICAgaWYoZG9uZSlyZXR1cm4gUkVUVVJOO1xuICAgICAgICAgICAgfSkgPT09IFJFVFVSTilyZXR1cm47XG4gICAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIGlmKGRvbmUpdGhyb3cgZTtcbiAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKXsgZG9uZSA9IHRydWU7IH07XG4gICAgfSk7XG4gIH0sXG4gIG9mOiBmdW5jdGlvbiBvZigpe1xuICAgIGZvcih2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoLCBpdGVtcyA9IEFycmF5KGwpOyBpIDwgbDspaXRlbXNbaV0gPSBhcmd1bWVudHNbaSsrXTtcbiAgICByZXR1cm4gbmV3ICh0eXBlb2YgdGhpcyA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiAkT2JzZXJ2YWJsZSkoZnVuY3Rpb24ob2JzZXJ2ZXIpe1xuICAgICAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgICAgIG1pY3JvdGFzayhmdW5jdGlvbigpe1xuICAgICAgICBpZighZG9uZSl7XG4gICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgKytpKXtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQoaXRlbXNbaV0pO1xuICAgICAgICAgICAgaWYoZG9uZSlyZXR1cm47XG4gICAgICAgICAgfSBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpeyBkb25lID0gdHJ1ZTsgfTtcbiAgICB9KTtcbiAgfVxufSk7XG5cbmhpZGUoJE9ic2VydmFibGUucHJvdG90eXBlLCBPQlNFUlZBQkxFLCBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfSk7XG5cbiRleHBvcnQoJGV4cG9ydC5HLCB7T2JzZXJ2YWJsZTogJE9ic2VydmFibGV9KTtcblxucmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKSgnT2JzZXJ2YWJsZScpOyIsInZhciBtZXRhZGF0YSAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIHRvTWV0YUtleSAgICAgICAgICAgICAgICAgPSBtZXRhZGF0YS5rZXlcbiAgLCBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhID0gbWV0YWRhdGEuc2V0O1xuXG5tZXRhZGF0YS5leHAoe2RlZmluZU1ldGFkYXRhOiBmdW5jdGlvbiBkZWZpbmVNZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSwgdGFyZ2V0LCB0YXJnZXRLZXkpe1xuICBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlLCBhbk9iamVjdCh0YXJnZXQpLCB0b01ldGFLZXkodGFyZ2V0S2V5KSk7XG59fSk7IiwidmFyIG1ldGFkYXRhICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpXG4gICwgYW5PYmplY3QgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgdG9NZXRhS2V5ICAgICAgICAgICAgICA9IG1ldGFkYXRhLmtleVxuICAsIGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAgPSBtZXRhZGF0YS5tYXBcbiAgLCBzdG9yZSAgICAgICAgICAgICAgICAgID0gbWV0YWRhdGEuc3RvcmU7XG5cbm1ldGFkYXRhLmV4cCh7ZGVsZXRlTWV0YWRhdGE6IGZ1bmN0aW9uIGRlbGV0ZU1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQgLyosIHRhcmdldEtleSAqLyl7XG4gIHZhciB0YXJnZXRLZXkgICA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1syXSlcbiAgICAsIG1ldGFkYXRhTWFwID0gZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcChhbk9iamVjdCh0YXJnZXQpLCB0YXJnZXRLZXksIGZhbHNlKTtcbiAgaWYobWV0YWRhdGFNYXAgPT09IHVuZGVmaW5lZCB8fCAhbWV0YWRhdGFNYXBbJ2RlbGV0ZSddKG1ldGFkYXRhS2V5KSlyZXR1cm4gZmFsc2U7XG4gIGlmKG1ldGFkYXRhTWFwLnNpemUpcmV0dXJuIHRydWU7XG4gIHZhciB0YXJnZXRNZXRhZGF0YSA9IHN0b3JlLmdldCh0YXJnZXQpO1xuICB0YXJnZXRNZXRhZGF0YVsnZGVsZXRlJ10odGFyZ2V0S2V5KTtcbiAgcmV0dXJuICEhdGFyZ2V0TWV0YWRhdGEuc2l6ZSB8fCBzdG9yZVsnZGVsZXRlJ10odGFyZ2V0KTtcbn19KTsiLCJ2YXIgU2V0ICAgICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL2VzNi5zZXQnKVxuICAsIGZyb20gICAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYXJyYXktZnJvbS1pdGVyYWJsZScpXG4gICwgbWV0YWRhdGEgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpXG4gICwgYW5PYmplY3QgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGdldFByb3RvdHlwZU9mICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgb3JkaW5hcnlPd25NZXRhZGF0YUtleXMgPSBtZXRhZGF0YS5rZXlzXG4gICwgdG9NZXRhS2V5ICAgICAgICAgICAgICAgPSBtZXRhZGF0YS5rZXk7XG5cbnZhciBvcmRpbmFyeU1ldGFkYXRhS2V5cyA9IGZ1bmN0aW9uKE8sIFApe1xuICB2YXIgb0tleXMgID0gb3JkaW5hcnlPd25NZXRhZGF0YUtleXMoTywgUClcbiAgICAsIHBhcmVudCA9IGdldFByb3RvdHlwZU9mKE8pO1xuICBpZihwYXJlbnQgPT09IG51bGwpcmV0dXJuIG9LZXlzO1xuICB2YXIgcEtleXMgID0gb3JkaW5hcnlNZXRhZGF0YUtleXMocGFyZW50LCBQKTtcbiAgcmV0dXJuIHBLZXlzLmxlbmd0aCA/IG9LZXlzLmxlbmd0aCA/IGZyb20obmV3IFNldChvS2V5cy5jb25jYXQocEtleXMpKSkgOiBwS2V5cyA6IG9LZXlzO1xufTtcblxubWV0YWRhdGEuZXhwKHtnZXRNZXRhZGF0YUtleXM6IGZ1bmN0aW9uIGdldE1ldGFkYXRhS2V5cyh0YXJnZXQgLyosIHRhcmdldEtleSAqLyl7XG4gIHJldHVybiBvcmRpbmFyeU1ldGFkYXRhS2V5cyhhbk9iamVjdCh0YXJnZXQpLCBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMV0pKTtcbn19KTsiLCJ2YXIgbWV0YWRhdGEgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJylcbiAgLCBhbk9iamVjdCAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBnZXRQcm90b3R5cGVPZiAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgb3JkaW5hcnlIYXNPd25NZXRhZGF0YSA9IG1ldGFkYXRhLmhhc1xuICAsIG9yZGluYXJ5R2V0T3duTWV0YWRhdGEgPSBtZXRhZGF0YS5nZXRcbiAgLCB0b01ldGFLZXkgICAgICAgICAgICAgID0gbWV0YWRhdGEua2V5O1xuXG52YXIgb3JkaW5hcnlHZXRNZXRhZGF0YSA9IGZ1bmN0aW9uKE1ldGFkYXRhS2V5LCBPLCBQKXtcbiAgdmFyIGhhc093biA9IG9yZGluYXJ5SGFzT3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApO1xuICBpZihoYXNPd24pcmV0dXJuIG9yZGluYXJ5R2V0T3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApO1xuICB2YXIgcGFyZW50ID0gZ2V0UHJvdG90eXBlT2YoTyk7XG4gIHJldHVybiBwYXJlbnQgIT09IG51bGwgPyBvcmRpbmFyeUdldE1ldGFkYXRhKE1ldGFkYXRhS2V5LCBwYXJlbnQsIFApIDogdW5kZWZpbmVkO1xufTtcblxubWV0YWRhdGEuZXhwKHtnZXRNZXRhZGF0YTogZnVuY3Rpb24gZ2V0TWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCAvKiwgdGFyZ2V0S2V5ICovKXtcbiAgcmV0dXJuIG9yZGluYXJ5R2V0TWV0YWRhdGEobWV0YWRhdGFLZXksIGFuT2JqZWN0KHRhcmdldCksIGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1syXSkpO1xufX0pOyIsInZhciBtZXRhZGF0YSAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJylcbiAgLCBhbk9iamVjdCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgb3JkaW5hcnlPd25NZXRhZGF0YUtleXMgPSBtZXRhZGF0YS5rZXlzXG4gICwgdG9NZXRhS2V5ICAgICAgICAgICAgICAgPSBtZXRhZGF0YS5rZXk7XG5cbm1ldGFkYXRhLmV4cCh7Z2V0T3duTWV0YWRhdGFLZXlzOiBmdW5jdGlvbiBnZXRPd25NZXRhZGF0YUtleXModGFyZ2V0IC8qLCB0YXJnZXRLZXkgKi8pe1xuICByZXR1cm4gb3JkaW5hcnlPd25NZXRhZGF0YUtleXMoYW5PYmplY3QodGFyZ2V0KSwgYXJndW1lbnRzLmxlbmd0aCA8IDIgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzFdKSk7XG59fSk7IiwidmFyIG1ldGFkYXRhICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpXG4gICwgYW5PYmplY3QgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgb3JkaW5hcnlHZXRPd25NZXRhZGF0YSA9IG1ldGFkYXRhLmdldFxuICAsIHRvTWV0YUtleSAgICAgICAgICAgICAgPSBtZXRhZGF0YS5rZXk7XG5cbm1ldGFkYXRhLmV4cCh7Z2V0T3duTWV0YWRhdGE6IGZ1bmN0aW9uIGdldE93bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQgLyosIHRhcmdldEtleSAqLyl7XG4gIHJldHVybiBvcmRpbmFyeUdldE93bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCBhbk9iamVjdCh0YXJnZXQpXG4gICAgLCBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMl0pKTtcbn19KTsiLCJ2YXIgbWV0YWRhdGEgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJylcbiAgLCBhbk9iamVjdCAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBnZXRQcm90b3R5cGVPZiAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgb3JkaW5hcnlIYXNPd25NZXRhZGF0YSA9IG1ldGFkYXRhLmhhc1xuICAsIHRvTWV0YUtleSAgICAgICAgICAgICAgPSBtZXRhZGF0YS5rZXk7XG5cbnZhciBvcmRpbmFyeUhhc01ldGFkYXRhID0gZnVuY3Rpb24oTWV0YWRhdGFLZXksIE8sIFApe1xuICB2YXIgaGFzT3duID0gb3JkaW5hcnlIYXNPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCk7XG4gIGlmKGhhc093bilyZXR1cm4gdHJ1ZTtcbiAgdmFyIHBhcmVudCA9IGdldFByb3RvdHlwZU9mKE8pO1xuICByZXR1cm4gcGFyZW50ICE9PSBudWxsID8gb3JkaW5hcnlIYXNNZXRhZGF0YShNZXRhZGF0YUtleSwgcGFyZW50LCBQKSA6IGZhbHNlO1xufTtcblxubWV0YWRhdGEuZXhwKHtoYXNNZXRhZGF0YTogZnVuY3Rpb24gaGFzTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCAvKiwgdGFyZ2V0S2V5ICovKXtcbiAgcmV0dXJuIG9yZGluYXJ5SGFzTWV0YWRhdGEobWV0YWRhdGFLZXksIGFuT2JqZWN0KHRhcmdldCksIGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1syXSkpO1xufX0pOyIsInZhciBtZXRhZGF0YSAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIG9yZGluYXJ5SGFzT3duTWV0YWRhdGEgPSBtZXRhZGF0YS5oYXNcbiAgLCB0b01ldGFLZXkgICAgICAgICAgICAgID0gbWV0YWRhdGEua2V5O1xuXG5tZXRhZGF0YS5leHAoe2hhc093bk1ldGFkYXRhOiBmdW5jdGlvbiBoYXNPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0IC8qLCB0YXJnZXRLZXkgKi8pe1xuICByZXR1cm4gb3JkaW5hcnlIYXNPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgYW5PYmplY3QodGFyZ2V0KVxuICAgICwgYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzJdKSk7XG59fSk7IiwidmFyIG1ldGFkYXRhICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpXG4gICwgYW5PYmplY3QgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgYUZ1bmN0aW9uICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKVxuICAsIHRvTWV0YUtleSAgICAgICAgICAgICAgICAgPSBtZXRhZGF0YS5rZXlcbiAgLCBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhID0gbWV0YWRhdGEuc2V0O1xuXG5tZXRhZGF0YS5leHAoe21ldGFkYXRhOiBmdW5jdGlvbiBtZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSl7XG4gIHJldHVybiBmdW5jdGlvbiBkZWNvcmF0b3IodGFyZ2V0LCB0YXJnZXRLZXkpe1xuICAgIG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEoXG4gICAgICBtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSxcbiAgICAgICh0YXJnZXRLZXkgIT09IHVuZGVmaW5lZCA/IGFuT2JqZWN0IDogYUZ1bmN0aW9uKSh0YXJnZXQpLFxuICAgICAgdG9NZXRhS2V5KHRhcmdldEtleSlcbiAgICApO1xuICB9O1xufX0pOyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuUiwgJ1NldCcsIHt0b0pTT046IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tdG8tanNvbicpKCdTZXQnKX0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL1N0cmluZy5wcm90b3R5cGUuYXRcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkYXQgICAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykodHJ1ZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICBhdDogZnVuY3Rpb24gYXQocG9zKXtcbiAgICByZXR1cm4gJGF0KHRoaXMsIHBvcyk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vU3RyaW5nLnByb3RvdHlwZS5tYXRjaEFsbC9cbnZhciAkZXhwb3J0ICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgZGVmaW5lZCAgICAgPSByZXF1aXJlKCcuL19kZWZpbmVkJylcbiAgLCB0b0xlbmd0aCAgICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgaXNSZWdFeHAgICAgPSByZXF1aXJlKCcuL19pcy1yZWdleHAnKVxuICAsIGdldEZsYWdzICAgID0gcmVxdWlyZSgnLi9fZmxhZ3MnKVxuICAsIFJlZ0V4cFByb3RvID0gUmVnRXhwLnByb3RvdHlwZTtcblxudmFyICRSZWdFeHBTdHJpbmdJdGVyYXRvciA9IGZ1bmN0aW9uKHJlZ2V4cCwgc3RyaW5nKXtcbiAgdGhpcy5fciA9IHJlZ2V4cDtcbiAgdGhpcy5fcyA9IHN0cmluZztcbn07XG5cbnJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJykoJFJlZ0V4cFN0cmluZ0l0ZXJhdG9yLCAnUmVnRXhwIFN0cmluZycsIGZ1bmN0aW9uIG5leHQoKXtcbiAgdmFyIG1hdGNoID0gdGhpcy5fci5leGVjKHRoaXMuX3MpO1xuICByZXR1cm4ge3ZhbHVlOiBtYXRjaCwgZG9uZTogbWF0Y2ggPT09IG51bGx9O1xufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICBtYXRjaEFsbDogZnVuY3Rpb24gbWF0Y2hBbGwocmVnZXhwKXtcbiAgICBkZWZpbmVkKHRoaXMpO1xuICAgIGlmKCFpc1JlZ0V4cChyZWdleHApKXRocm93IFR5cGVFcnJvcihyZWdleHAgKyAnIGlzIG5vdCBhIHJlZ2V4cCEnKTtcbiAgICB2YXIgUyAgICAgPSBTdHJpbmcodGhpcylcbiAgICAgICwgZmxhZ3MgPSAnZmxhZ3MnIGluIFJlZ0V4cFByb3RvID8gU3RyaW5nKHJlZ2V4cC5mbGFncykgOiBnZXRGbGFncy5jYWxsKHJlZ2V4cClcbiAgICAgICwgcnggICAgPSBuZXcgUmVnRXhwKHJlZ2V4cC5zb3VyY2UsIH5mbGFncy5pbmRleE9mKCdnJykgPyBmbGFncyA6ICdnJyArIGZsYWdzKTtcbiAgICByeC5sYXN0SW5kZXggPSB0b0xlbmd0aChyZWdleHAubGFzdEluZGV4KTtcbiAgICByZXR1cm4gbmV3ICRSZWdFeHBTdHJpbmdJdGVyYXRvcihyeCwgUyk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXN0cmluZy1wYWQtc3RhcnQtZW5kXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHBhZCAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy1wYWQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIHBhZEVuZDogZnVuY3Rpb24gcGFkRW5kKG1heExlbmd0aCAvKiwgZmlsbFN0cmluZyA9ICcgJyAqLyl7XG4gICAgcmV0dXJuICRwYWQodGhpcywgbWF4TGVuZ3RoLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgZmFsc2UpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1zdHJpbmctcGFkLXN0YXJ0LWVuZFxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRwYWQgICAgPSByZXF1aXJlKCcuL19zdHJpbmctcGFkJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICBwYWRTdGFydDogZnVuY3Rpb24gcGFkU3RhcnQobWF4TGVuZ3RoIC8qLCBmaWxsU3RyaW5nID0gJyAnICovKXtcbiAgICByZXR1cm4gJHBhZCh0aGlzLCBtYXhMZW5ndGgsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCB0cnVlKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3NlYm1hcmtiYWdlL2VjbWFzY3JpcHQtc3RyaW5nLWxlZnQtcmlnaHQtdHJpbVxucmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKSgndHJpbUxlZnQnLCBmdW5jdGlvbigkdHJpbSl7XG4gIHJldHVybiBmdW5jdGlvbiB0cmltTGVmdCgpe1xuICAgIHJldHVybiAkdHJpbSh0aGlzLCAxKTtcbiAgfTtcbn0sICd0cmltU3RhcnQnKTsiLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vc2VibWFya2JhZ2UvZWNtYXNjcmlwdC1zdHJpbmctbGVmdC1yaWdodC10cmltXG5yZXF1aXJlKCcuL19zdHJpbmctdHJpbScpKCd0cmltUmlnaHQnLCBmdW5jdGlvbigkdHJpbSl7XG4gIHJldHVybiBmdW5jdGlvbiB0cmltUmlnaHQoKXtcbiAgICByZXR1cm4gJHRyaW0odGhpcywgMik7XG4gIH07XG59LCAndHJpbUVuZCcpOyIsInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnYXN5bmNJdGVyYXRvcicpOyIsInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnb2JzZXJ2YWJsZScpOyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9samhhcmIvcHJvcG9zYWwtZ2xvYmFsXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1N5c3RlbScsIHtnbG9iYWw6IHJlcXVpcmUoJy4vX2dsb2JhbCcpfSk7IiwidmFyICRpdGVyYXRvcnMgICAgPSByZXF1aXJlKCcuL2VzNi5hcnJheS5pdGVyYXRvcicpXG4gICwgcmVkZWZpbmUgICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCBnbG9iYWwgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBoaWRlICAgICAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgSXRlcmF0b3JzICAgICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgd2tzICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3drcycpXG4gICwgSVRFUkFUT1IgICAgICA9IHdrcygnaXRlcmF0b3InKVxuICAsIFRPX1NUUklOR19UQUcgPSB3a3MoJ3RvU3RyaW5nVGFnJylcbiAgLCBBcnJheVZhbHVlcyAgID0gSXRlcmF0b3JzLkFycmF5O1xuXG5mb3IodmFyIGNvbGxlY3Rpb25zID0gWydOb2RlTGlzdCcsICdET01Ub2tlbkxpc3QnLCAnTWVkaWFMaXN0JywgJ1N0eWxlU2hlZXRMaXN0JywgJ0NTU1J1bGVMaXN0J10sIGkgPSAwOyBpIDwgNTsgaSsrKXtcbiAgdmFyIE5BTUUgICAgICAgPSBjb2xsZWN0aW9uc1tpXVxuICAgICwgQ29sbGVjdGlvbiA9IGdsb2JhbFtOQU1FXVxuICAgICwgcHJvdG8gICAgICA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGVcbiAgICAsIGtleTtcbiAgaWYocHJvdG8pe1xuICAgIGlmKCFwcm90b1tJVEVSQVRPUl0paGlkZShwcm90bywgSVRFUkFUT1IsIEFycmF5VmFsdWVzKTtcbiAgICBpZighcHJvdG9bVE9fU1RSSU5HX1RBR10paGlkZShwcm90bywgVE9fU1RSSU5HX1RBRywgTkFNRSk7XG4gICAgSXRlcmF0b3JzW05BTUVdID0gQXJyYXlWYWx1ZXM7XG4gICAgZm9yKGtleSBpbiAkaXRlcmF0b3JzKWlmKCFwcm90b1trZXldKXJlZGVmaW5lKHByb3RvLCBrZXksICRpdGVyYXRvcnNba2V5XSwgdHJ1ZSk7XG4gIH1cbn0iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHRhc2sgICA9IHJlcXVpcmUoJy4vX3Rhc2snKTtcbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5CLCB7XG4gIHNldEltbWVkaWF0ZTogICAkdGFzay5zZXQsXG4gIGNsZWFySW1tZWRpYXRlOiAkdGFzay5jbGVhclxufSk7IiwiLy8gaWU5LSBzZXRUaW1lb3V0ICYgc2V0SW50ZXJ2YWwgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIGZpeFxudmFyIGdsb2JhbCAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsICRleHBvcnQgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGludm9rZSAgICAgPSByZXF1aXJlKCcuL19pbnZva2UnKVxuICAsIHBhcnRpYWwgICAgPSByZXF1aXJlKCcuL19wYXJ0aWFsJylcbiAgLCBuYXZpZ2F0b3IgID0gZ2xvYmFsLm5hdmlnYXRvclxuICAsIE1TSUUgICAgICAgPSAhIW5hdmlnYXRvciAmJiAvTVNJRSAuXFwuLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpOyAvLyA8LSBkaXJ0eSBpZTktIGNoZWNrXG52YXIgd3JhcCA9IGZ1bmN0aW9uKHNldCl7XG4gIHJldHVybiBNU0lFID8gZnVuY3Rpb24oZm4sIHRpbWUgLyosIC4uLmFyZ3MgKi8pe1xuICAgIHJldHVybiBzZXQoaW52b2tlKFxuICAgICAgcGFydGlhbCxcbiAgICAgIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSxcbiAgICAgIHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nID8gZm4gOiBGdW5jdGlvbihmbilcbiAgICApLCB0aW1lKTtcbiAgfSA6IHNldDtcbn07XG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuQiArICRleHBvcnQuRiAqIE1TSUUsIHtcbiAgc2V0VGltZW91dDogIHdyYXAoZ2xvYmFsLnNldFRpbWVvdXQpLFxuICBzZXRJbnRlcnZhbDogd3JhcChnbG9iYWwuc2V0SW50ZXJ2YWwpXG59KTsiLCJyZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN5bWJvbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0aWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmtleXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktbmFtZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmZyZWV6ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3Quc2VhbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QucHJldmVudC1leHRlbnNpb25zJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1mcm96ZW4nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmlzLXNlYWxlZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZXh0ZW5zaWJsZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5pcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmJpbmQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZnVuY3Rpb24ubmFtZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5mdW5jdGlvbi5oYXMtaW5zdGFuY2UnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucGFyc2UtaW50Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnBhcnNlLWZsb2F0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5jb25zdHJ1Y3RvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIudG8tZml4ZWQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLnRvLXByZWNpc2lvbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuZXBzaWxvbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuaXMtZmluaXRlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5pcy1pbnRlZ2VyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5pcy1uYW4nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmlzLXNhZmUtaW50ZWdlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIubWF4LXNhZmUtaW50ZWdlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIubWluLXNhZmUtaW50ZWdlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIucGFyc2UtZmxvYXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWludCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmFjb3NoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguYXNpbmgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5hdGFuaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmNicnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5jbHozMicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmNvc2gnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5leHBtMScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmZyb3VuZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmh5cG90Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguaW11bCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmxvZzEwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGgubG9nMXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5sb2cyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguc2lnbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLnNpbmgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC50YW5oJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGgudHJ1bmMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmZyb20tY29kZS1wb2ludCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcucmF3Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy50cmltJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuY29kZS1wb2ludC1hdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuZW5kcy13aXRoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5pbmNsdWRlcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcucmVwZWF0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5zdGFydHMtd2l0aCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuYW5jaG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5iaWcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmJsaW5rJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5ib2xkJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5maXhlZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuZm9udGNvbG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5mb250c2l6ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRhbGljcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcubGluaycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuc21hbGwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnN0cmlrZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuc3ViJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5zdXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZGF0ZS5ub3cnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZGF0ZS50by1qc29uJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmRhdGUudG8taXNvLXN0cmluZycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5kYXRlLnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5kYXRlLnRvLXByaW1pdGl2ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5pcy1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5mcm9tJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5Lm9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmpvaW4nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuc2xpY2UnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuc29ydCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5mb3ItZWFjaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5tYXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZmlsdGVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnNvbWUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZXZlcnknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkucmVkdWNlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZS1yaWdodCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5pbmRleC1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5sYXN0LWluZGV4LW9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmNvcHktd2l0aGluJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZpbGwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZmluZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5maW5kLWluZGV4Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnNwZWNpZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLmNvbnN0cnVjdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLmZsYWdzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5tYXRjaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAucmVwbGFjZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAuc2VhcmNoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5zcGxpdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5wcm9taXNlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hcCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zZXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYud2Vhay1tYXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYud2Vhay1zZXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuYXJyYXktYnVmZmVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmRhdGEtdmlldycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5pbnQ4LWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQ4LWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQ4LWNsYW1wZWQtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuaW50MTYtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQudWludDE2LWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmludDMyLWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQzMi1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDMyLWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmZsb2F0NjQtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5hcHBseScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmNvbnN0cnVjdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmRlZmluZS1wcm9wZXJ0eScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmRlbGV0ZS1wcm9wZXJ0eScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmVudW1lcmF0ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC1wcm90b3R5cGUtb2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5oYXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5pcy1leHRlbnNpYmxlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3Qub3duLWtleXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5wcmV2ZW50LWV4dGVuc2lvbnMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5zZXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5zZXQtcHJvdG90eXBlLW9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LmFycmF5LmluY2x1ZGVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy5hdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcucGFkLXN0YXJ0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy5wYWQtZW5kJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy50cmltLWxlZnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLnRyaW0tcmlnaHQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLm1hdGNoLWFsbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3ltYm9sLm9ic2VydmFibGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcnMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0LnZhbHVlcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QuZW50cmllcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QuZGVmaW5lLWdldHRlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QuZGVmaW5lLXNldHRlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QubG9va3VwLWdldHRlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QubG9va3VwLXNldHRlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXAudG8tanNvbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zZXQudG8tanNvbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zeXN0ZW0uZ2xvYmFsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LmVycm9yLmlzLWVycm9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguaWFkZGgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5pc3ViaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLmltdWxoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGgudW11bGgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5kZWZpbmUtbWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5kZWxldGUtbWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtbWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtbWV0YWRhdGEta2V5cycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1vd24tbWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtb3duLW1ldGFkYXRhLWtleXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5oYXMtbWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5oYXMtb3duLW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QubWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuYXNhcCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYnNlcnZhYmxlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvd2ViLnRpbWVycycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL3dlYi5pbW1lZGlhdGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbW9kdWxlcy9fY29yZScpOyIsIlxuLyoqXG4gKiBFeHBvc2UgYEVtaXR0ZXJgLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBFbWl0dGVyYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xufTtcblxuLyoqXG4gKiBNaXhpbiB0aGUgZW1pdHRlciBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIG1peGluKG9iaikge1xuICBmb3IgKHZhciBrZXkgaW4gRW1pdHRlci5wcm90b3R5cGUpIHtcbiAgICBvYmpba2V5XSA9IEVtaXR0ZXIucHJvdG90eXBlW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBMaXN0ZW4gb24gdGhlIGdpdmVuIGBldmVudGAgd2l0aCBgZm5gLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9uID1cbkVtaXR0ZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gICh0aGlzLl9jYWxsYmFja3NbZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XSB8fCBbXSlcbiAgICAucHVzaChmbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcbiAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXG4gIGZ1bmN0aW9uIG9uKCkge1xuICAgIHNlbGYub2ZmKGV2ZW50LCBvbik7XG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIG9uLmZuID0gZm47XG4gIHRoaXMub24oZXZlbnQsIG9uKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXG4gKiByZWdpc3RlcmVkIGNhbGxiYWNrcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vZmYgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cbiAgLy8gYWxsXG4gIGlmICgwID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNwZWNpZmljIGV2ZW50XG4gIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdO1xuICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XG5cbiAgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xuICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyByZW1vdmUgc3BlY2lmaWMgaGFuZGxlclxuICB2YXIgY2I7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgY2IgPSBjYWxsYmFja3NbaV07XG4gICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtNaXhlZH0gLi4uXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCl7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcbiAgICAsIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG5cbiAgaWYgKGNhbGxiYWNrcykge1xuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHVybiBhcnJheSBvZiBjYWxsYmFja3MgZm9yIGBldmVudGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gIHJldHVybiB0aGlzLl9jYWxsYmFja3NbZXZlbnRdIHx8IFtdO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG4gIHJldHVybiAhISB0aGlzLmxpc3RlbmVycyhldmVudCkubGVuZ3RoO1xufTtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBodHRwczovL3Jhdy5naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL21hc3Rlci9MSUNFTlNFIGZpbGUuIEFuXG4gKiBhZGRpdGlvbmFsIGdyYW50IG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW5cbiAqIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4hKGZ1bmN0aW9uKGdsb2JhbCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIHZhciBpbk1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCI7XG4gIHZhciBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZTtcbiAgaWYgKHJ1bnRpbWUpIHtcbiAgICBpZiAoaW5Nb2R1bGUpIHtcbiAgICAgIC8vIElmIHJlZ2VuZXJhdG9yUnVudGltZSBpcyBkZWZpbmVkIGdsb2JhbGx5IGFuZCB3ZSdyZSBpbiBhIG1vZHVsZSxcbiAgICAgIC8vIG1ha2UgdGhlIGV4cG9ydHMgb2JqZWN0IGlkZW50aWNhbCB0byByZWdlbmVyYXRvclJ1bnRpbWUuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJ1bnRpbWU7XG4gICAgfVxuICAgIC8vIERvbid0IGJvdGhlciBldmFsdWF0aW5nIHRoZSByZXN0IG9mIHRoaXMgZmlsZSBpZiB0aGUgcnVudGltZSB3YXNcbiAgICAvLyBhbHJlYWR5IGRlZmluZWQgZ2xvYmFsbHkuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRGVmaW5lIHRoZSBydW50aW1lIGdsb2JhbGx5IChhcyBleHBlY3RlZCBieSBnZW5lcmF0ZWQgY29kZSkgYXMgZWl0aGVyXG4gIC8vIG1vZHVsZS5leHBvcnRzIChpZiB3ZSdyZSBpbiBhIG1vZHVsZSkgb3IgYSBuZXcsIGVtcHR5IG9iamVjdC5cbiAgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWUgPSBpbk1vZHVsZSA/IG1vZHVsZS5leHBvcnRzIDoge307XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgcnVudGltZS53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGVbdG9TdHJpbmdUYWdTeW1ib2xdID1cbiAgICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBwcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3JcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuICBydW50aW1lLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgIGlmICghKHRvU3RyaW5nVGFnU3ltYm9sIGluIGdlbkZ1bikpIHtcbiAgICAgICAgZ2VuRnVuW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgcnVudGltZS5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uIElmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCBob3dldmVyLCB0aGVcbiAgICAgICAgICAvLyByZXN1bHQgZm9yIHRoaXMgaXRlcmF0aW9uIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGUgc2FtZVxuICAgICAgICAgIC8vIHJlYXNvbi4gTm90ZSB0aGF0IHJlamVjdGlvbnMgb2YgeWllbGRlZCBQcm9taXNlcyBhcmUgbm90XG4gICAgICAgICAgLy8gdGhyb3duIGJhY2sgaW50byB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBhcyBpcyB0aGUgY2FzZVxuICAgICAgICAgIC8vIHdoZW4gYW4gYXdhaXRlZCBQcm9taXNlIGlzIHJlamVjdGVkLiBUaGlzIGRpZmZlcmVuY2UgaW5cbiAgICAgICAgICAvLyBiZWhhdmlvciBiZXR3ZWVuIHlpZWxkIGFuZCBhd2FpdCBpcyBpbXBvcnRhbnQsIGJlY2F1c2UgaXRcbiAgICAgICAgICAvLyBhbGxvd3MgdGhlIGNvbnN1bWVyIHRvIGRlY2lkZSB3aGF0IHRvIGRvIHdpdGggdGhlIHlpZWxkZWRcbiAgICAgICAgICAvLyByZWplY3Rpb24gKHN3YWxsb3cgaXQgYW5kIGNvbnRpbnVlLCBtYW51YWxseSAudGhyb3cgaXQgYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGdlbmVyYXRvciwgYWJhbmRvbiBpdGVyYXRpb24sIHdoYXRldmVyKS4gV2l0aFxuICAgICAgICAgIC8vIGF3YWl0LCBieSBjb250cmFzdCwgdGhlcmUgaXMgbm8gb3Bwb3J0dW5pdHkgdG8gZXhhbWluZSB0aGVcbiAgICAgICAgICAvLyByZWplY3Rpb24gcmVhc29uIG91dHNpZGUgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgc28gdGhlXG4gICAgICAgICAgLy8gb25seSBvcHRpb24gaXMgdG8gdGhyb3cgaXQgZnJvbSB0aGUgYXdhaXQgZXhwcmVzc2lvbiwgYW5kXG4gICAgICAgICAgLy8gbGV0IHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24gaGFuZGxlIHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgcHJvY2Vzcy5kb21haW4pIHtcbiAgICAgIGludm9rZSA9IHByb2Nlc3MuZG9tYWluLmJpbmQoaW52b2tlKTtcbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gIHJ1bnRpbWUuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIHJ1bnRpbWUuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KVxuICAgICk7XG5cbiAgICByZXR1cm4gcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXG4gICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuXG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG5cbiAgICBpZiAoISBpbmZvKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAvLyBBc3NpZ24gdGhlIHJlc3VsdCBvZiB0aGUgZmluaXNoZWQgZGVsZWdhdGUgdG8gdGhlIHRlbXBvcmFyeVxuICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuXG4gICAgICAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuXG4gICAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcbiAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcbiAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXG4gICAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcbiAgICAgIC8vIFwicmV0dXJuXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXG4gICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuXG4gICAgLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIEdwW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yXCI7XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIHJ1bnRpbWUua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBydW50aW1lLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG5cbiAgICAgICAgaWYgKGNhdWdodCkge1xuICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhIGNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xufSkoXG4gIC8vIEFtb25nIHRoZSB2YXJpb3VzIHRyaWNrcyBmb3Igb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWxcbiAgLy8gb2JqZWN0LCB0aGlzIHNlZW1zIHRvIGJlIHRoZSBtb3N0IHJlbGlhYmxlIHRlY2huaXF1ZSB0aGF0IGRvZXMgbm90XG4gIC8vIHVzZSBpbmRpcmVjdCBldmFsICh3aGljaCB2aW9sYXRlcyBDb250ZW50IFNlY3VyaXR5IFBvbGljeSkuXG4gIHR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwgOlxuICB0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiID8gd2luZG93IDpcbiAgdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgPyBzZWxmIDogdGhpc1xuKTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIEF0dHJpYnV0ZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXR0cmlidXRlKCkge1xuICAgIH1cbiAgICBBdHRyaWJ1dGUuUVVBTElGSUVSX1BST1BFUlRZID0gXCJxdWFsaWZpZXJcIjtcbiAgICBBdHRyaWJ1dGUuVkFMVUUgPSBcInZhbHVlXCI7XG4gICAgcmV0dXJuIEF0dHJpYnV0ZTtcbn0oKSk7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBBdHRyaWJ1dGU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUF0dHJpYnV0ZS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgQ29tbWFuZF8xID0gcmVxdWlyZShcIi4vQ29tbWFuZFwiKTtcbnZhciBBdHRyaWJ1dGVDcmVhdGVkTm90aWZpY2F0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXR0cmlidXRlQ3JlYXRlZE5vdGlmaWNhdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBdHRyaWJ1dGVDcmVhdGVkTm90aWZpY2F0aW9uKHBtSWQsIGF0dHJpYnV0ZUlkLCBwcm9wZXJ0eU5hbWUsIG5ld1ZhbHVlLCBxdWFsaWZpZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMucG1JZCA9IHBtSWQ7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlSWQgPSBhdHRyaWJ1dGVJZDtcbiAgICAgICAgdGhpcy5wcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWU7XG4gICAgICAgIHRoaXMubmV3VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgdGhpcy5xdWFsaWZpZXIgPSBxdWFsaWZpZXI7XG4gICAgICAgIHRoaXMuaWQgPSAnQXR0cmlidXRlQ3JlYXRlZCc7XG4gICAgICAgIHRoaXMuY2xhc3NOYW1lID0gXCJvcmcub3BlbmRvbHBoaW4uY29yZS5jb21tLkF0dHJpYnV0ZUNyZWF0ZWROb3RpZmljYXRpb25cIjtcbiAgICB9XG4gICAgcmV0dXJuIEF0dHJpYnV0ZUNyZWF0ZWROb3RpZmljYXRpb247XG59KENvbW1hbmRfMVtcImRlZmF1bHRcIl0pKTtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IEF0dHJpYnV0ZUNyZWF0ZWROb3RpZmljYXRpb247XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUF0dHJpYnV0ZUNyZWF0ZWROb3RpZmljYXRpb24uanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIENvbW1hbmRfMSA9IHJlcXVpcmUoJy4vQ29tbWFuZCcpO1xudmFyIENoYW5nZUF0dHJpYnV0ZU1ldGFkYXRhQ29tbWFuZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENoYW5nZUF0dHJpYnV0ZU1ldGFkYXRhQ29tbWFuZCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDaGFuZ2VBdHRyaWJ1dGVNZXRhZGF0YUNvbW1hbmQoYXR0cmlidXRlSWQsIG1ldGFkYXRhTmFtZSwgdmFsdWUpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlSWQgPSBhdHRyaWJ1dGVJZDtcbiAgICAgICAgdGhpcy5tZXRhZGF0YU5hbWUgPSBtZXRhZGF0YU5hbWU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5pZCA9ICdDaGFuZ2VBdHRyaWJ1dGVNZXRhZGF0YSc7XG4gICAgICAgIHRoaXMuY2xhc3NOYW1lID0gXCJvcmcub3BlbmRvbHBoaW4uY29yZS5jb21tLkNoYW5nZUF0dHJpYnV0ZU1ldGFkYXRhQ29tbWFuZFwiO1xuICAgIH1cbiAgICByZXR1cm4gQ2hhbmdlQXR0cmlidXRlTWV0YWRhdGFDb21tYW5kO1xufShDb21tYW5kXzFbXCJkZWZhdWx0XCJdKSk7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBDaGFuZ2VBdHRyaWJ1dGVNZXRhZGF0YUNvbW1hbmQ7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNoYW5nZUF0dHJpYnV0ZU1ldGFkYXRhQ29tbWFuZC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIEV2ZW50QnVzXzEgPSByZXF1aXJlKCcuL0V2ZW50QnVzJyk7XG52YXIgQ2xpZW50QXR0cmlidXRlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDbGllbnRBdHRyaWJ1dGUocHJvcGVydHlOYW1lLCBxdWFsaWZpZXIsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMucHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lO1xuICAgICAgICB0aGlzLmlkID0gXCJcIiArIChDbGllbnRBdHRyaWJ1dGUuY2xpZW50QXR0cmlidXRlSW5zdGFuY2VDb3VudCsrKSArIFwiQ1wiO1xuICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlQnVzID0gbmV3IEV2ZW50QnVzXzFbXCJkZWZhdWx0XCJdKCk7XG4gICAgICAgIHRoaXMucXVhbGlmaWVyQ2hhbmdlQnVzID0gbmV3IEV2ZW50QnVzXzFbXCJkZWZhdWx0XCJdKCk7XG4gICAgICAgIHRoaXMuc2V0VmFsdWUodmFsdWUpO1xuICAgICAgICB0aGlzLnNldFF1YWxpZmllcihxdWFsaWZpZXIpO1xuICAgIH1cbiAgICAvKiogYSBjb3B5IGNvbnN0cnVjdG9yIHdpdGggbmV3IGlkIGFuZCBubyBwcmVzZW50YXRpb24gbW9kZWwgKi9cbiAgICBDbGllbnRBdHRyaWJ1dGUucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgQ2xpZW50QXR0cmlidXRlKHRoaXMucHJvcGVydHlOYW1lLCB0aGlzLmdldFF1YWxpZmllcigpLCB0aGlzLmdldFZhbHVlKCkpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgQ2xpZW50QXR0cmlidXRlLnByb3RvdHlwZS5zZXRQcmVzZW50YXRpb25Nb2RlbCA9IGZ1bmN0aW9uIChwcmVzZW50YXRpb25Nb2RlbCkge1xuICAgICAgICBpZiAodGhpcy5wcmVzZW50YXRpb25Nb2RlbCkge1xuICAgICAgICAgICAgYWxlcnQoXCJZb3UgY2FuIG5vdCBzZXQgYSBwcmVzZW50YXRpb24gbW9kZWwgZm9yIGFuIGF0dHJpYnV0ZSB0aGF0IGlzIGFscmVhZHkgYm91bmQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJlc2VudGF0aW9uTW9kZWwgPSBwcmVzZW50YXRpb25Nb2RlbDtcbiAgICB9O1xuICAgIENsaWVudEF0dHJpYnV0ZS5wcm90b3R5cGUuZ2V0UHJlc2VudGF0aW9uTW9kZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZXNlbnRhdGlvbk1vZGVsO1xuICAgIH07XG4gICAgQ2xpZW50QXR0cmlidXRlLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfTtcbiAgICBDbGllbnRBdHRyaWJ1dGUucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XG4gICAgICAgIHZhciB2ZXJpZmllZFZhbHVlID0gQ2xpZW50QXR0cmlidXRlLmNoZWNrVmFsdWUobmV3VmFsdWUpO1xuICAgICAgICBpZiAodGhpcy52YWx1ZSA9PSB2ZXJpZmllZFZhbHVlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmVyaWZpZWRWYWx1ZTtcbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZUJ1cy50cmlnZ2VyKHsgJ29sZFZhbHVlJzogb2xkVmFsdWUsICduZXdWYWx1ZSc6IHZlcmlmaWVkVmFsdWUgfSk7XG4gICAgfTtcbiAgICBDbGllbnRBdHRyaWJ1dGUucHJvdG90eXBlLnNldFF1YWxpZmllciA9IGZ1bmN0aW9uIChuZXdRdWFsaWZpZXIpIHtcbiAgICAgICAgaWYgKHRoaXMucXVhbGlmaWVyID09IG5ld1F1YWxpZmllcilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIG9sZFF1YWxpZmllciA9IHRoaXMucXVhbGlmaWVyO1xuICAgICAgICB0aGlzLnF1YWxpZmllciA9IG5ld1F1YWxpZmllcjtcbiAgICAgICAgdGhpcy5xdWFsaWZpZXJDaGFuZ2VCdXMudHJpZ2dlcih7ICdvbGRWYWx1ZSc6IG9sZFF1YWxpZmllciwgJ25ld1ZhbHVlJzogbmV3UXVhbGlmaWVyIH0pO1xuICAgIH07XG4gICAgQ2xpZW50QXR0cmlidXRlLnByb3RvdHlwZS5nZXRRdWFsaWZpZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1YWxpZmllcjtcbiAgICB9O1xuICAgIENsaWVudEF0dHJpYnV0ZS5jaGVja1ZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHZhbHVlID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgU3RyaW5nIHx8IHJlc3VsdCBpbnN0YW5jZW9mIEJvb2xlYW4gfHwgcmVzdWx0IGluc3RhbmNlb2YgTnVtYmVyKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB2YWx1ZS52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIENsaWVudEF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJBbiBBdHRyaWJ1dGUgbWF5IG5vdCBpdHNlbGYgY29udGFpbiBhbiBhdHRyaWJ1dGUgYXMgYSB2YWx1ZS4gQXNzdW1pbmcgeW91IGZvcmdvdCB0byBjYWxsIHZhbHVlLlwiKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuY2hlY2tWYWx1ZSh2YWx1ZS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9rID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLlNVUFBPUlRFRF9WQUxVRV9UWVBFUy5pbmRleE9mKHR5cGVvZiByZXN1bHQpID4gLTEgfHwgcmVzdWx0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgb2sgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF0dHJpYnV0ZSB2YWx1ZXMgb2YgdGhpcyB0eXBlIGFyZSBub3QgYWxsb3dlZDogXCIgKyB0eXBlb2YgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBDbGllbnRBdHRyaWJ1dGUucHJvdG90eXBlLm9uVmFsdWVDaGFuZ2UgPSBmdW5jdGlvbiAoZXZlbnRIYW5kbGVyKSB7XG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2VCdXMub25FdmVudChldmVudEhhbmRsZXIpO1xuICAgICAgICBldmVudEhhbmRsZXIoeyBcIm9sZFZhbHVlXCI6IHRoaXMudmFsdWUsIFwibmV3VmFsdWVcIjogdGhpcy52YWx1ZSB9KTtcbiAgICB9O1xuICAgIENsaWVudEF0dHJpYnV0ZS5wcm90b3R5cGUub25RdWFsaWZpZXJDaGFuZ2UgPSBmdW5jdGlvbiAoZXZlbnRIYW5kbGVyKSB7XG4gICAgICAgIHRoaXMucXVhbGlmaWVyQ2hhbmdlQnVzLm9uRXZlbnQoZXZlbnRIYW5kbGVyKTtcbiAgICB9O1xuICAgIENsaWVudEF0dHJpYnV0ZS5wcm90b3R5cGUuc3luY1dpdGggPSBmdW5jdGlvbiAoc291cmNlQXR0cmlidXRlKSB7XG4gICAgICAgIGlmIChzb3VyY2VBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0UXVhbGlmaWVyKHNvdXJjZUF0dHJpYnV0ZS5nZXRRdWFsaWZpZXIoKSk7IC8vIHNlcXVlbmNlIGlzIGltcG9ydGFudFxuICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZShzb3VyY2VBdHRyaWJ1dGUudmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDbGllbnRBdHRyaWJ1dGUuU1VQUE9SVEVEX1ZBTFVFX1RZUEVTID0gW1wic3RyaW5nXCIsIFwibnVtYmVyXCIsIFwiYm9vbGVhblwiXTtcbiAgICBDbGllbnRBdHRyaWJ1dGUuY2xpZW50QXR0cmlidXRlSW5zdGFuY2VDb3VudCA9IDA7XG4gICAgcmV0dXJuIENsaWVudEF0dHJpYnV0ZTtcbn0oKSk7XG5leHBvcnRzLkNsaWVudEF0dHJpYnV0ZSA9IENsaWVudEF0dHJpYnV0ZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2xpZW50QXR0cmlidXRlLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgQ2xpZW50QXR0cmlidXRlXzEgPSByZXF1aXJlKFwiLi9DbGllbnRBdHRyaWJ1dGVcIik7XG52YXIgQ2xpZW50UHJlc2VudGF0aW9uTW9kZWxfMSA9IHJlcXVpcmUoXCIuL0NsaWVudFByZXNlbnRhdGlvbk1vZGVsXCIpO1xudmFyIENvZGVjXzEgPSByZXF1aXJlKFwiLi9Db2RlY1wiKTtcbnZhciBDb21tYW5kQmF0Y2hlcl8xID0gcmVxdWlyZShcIi4vQ29tbWFuZEJhdGNoZXJcIik7XG52YXIgQ2xpZW50Q29ubmVjdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDbGllbnRDb25uZWN0b3IodHJhbnNtaXR0ZXIsIGNsaWVudERvbHBoaW4sIHNsYWNrTVMsIG1heEJhdGNoU2l6ZSkge1xuICAgICAgICBpZiAoc2xhY2tNUyA9PT0gdm9pZCAwKSB7IHNsYWNrTVMgPSAwOyB9XG4gICAgICAgIGlmIChtYXhCYXRjaFNpemUgPT09IHZvaWQgMCkgeyBtYXhCYXRjaFNpemUgPSA1MDsgfVxuICAgICAgICB0aGlzLmNvbW1hbmRRdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLmN1cnJlbnRseVNlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wdXNoRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLndhaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50cmFuc21pdHRlciA9IHRyYW5zbWl0dGVyO1xuICAgICAgICB0aGlzLmNsaWVudERvbHBoaW4gPSBjbGllbnREb2xwaGluO1xuICAgICAgICB0aGlzLnNsYWNrTVMgPSBzbGFja01TO1xuICAgICAgICB0aGlzLmNvZGVjID0gbmV3IENvZGVjXzFbXCJkZWZhdWx0XCJdKCk7XG4gICAgICAgIHRoaXMuY29tbWFuZEJhdGNoZXIgPSBuZXcgQ29tbWFuZEJhdGNoZXJfMS5CbGluZENvbW1hbmRCYXRjaGVyKHRydWUsIG1heEJhdGNoU2l6ZSk7XG4gICAgfVxuICAgIENsaWVudENvbm5lY3Rvci5wcm90b3R5cGUuc2V0Q29tbWFuZEJhdGNoZXIgPSBmdW5jdGlvbiAobmV3QmF0Y2hlcikge1xuICAgICAgICB0aGlzLmNvbW1hbmRCYXRjaGVyID0gbmV3QmF0Y2hlcjtcbiAgICB9O1xuICAgIENsaWVudENvbm5lY3Rvci5wcm90b3R5cGUuc2V0UHVzaEVuYWJsZWQgPSBmdW5jdGlvbiAoZW5hYmxlZCkge1xuICAgICAgICB0aGlzLnB1c2hFbmFibGVkID0gZW5hYmxlZDtcbiAgICB9O1xuICAgIENsaWVudENvbm5lY3Rvci5wcm90b3R5cGUuc2V0UHVzaExpc3RlbmVyID0gZnVuY3Rpb24gKG5ld0xpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMucHVzaExpc3RlbmVyID0gbmV3TGlzdGVuZXI7XG4gICAgfTtcbiAgICBDbGllbnRDb25uZWN0b3IucHJvdG90eXBlLnNldFJlbGVhc2VDb21tYW5kID0gZnVuY3Rpb24gKG5ld0NvbW1hbmQpIHtcbiAgICAgICAgdGhpcy5yZWxlYXNlQ29tbWFuZCA9IG5ld0NvbW1hbmQ7XG4gICAgfTtcbiAgICBDbGllbnRDb25uZWN0b3IucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKHN1Y2Nlc3NIYW5kbGVyKSB7XG4gICAgICAgIHRoaXMudHJhbnNtaXR0ZXIucmVzZXQoc3VjY2Vzc0hhbmRsZXIpO1xuICAgIH07XG4gICAgQ2xpZW50Q29ubmVjdG9yLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKGNvbW1hbmQsIG9uRmluaXNoZWQpIHtcbiAgICAgICAgdGhpcy5jb21tYW5kUXVldWUucHVzaCh7IGNvbW1hbmQ6IGNvbW1hbmQsIGhhbmRsZXI6IG9uRmluaXNoZWQgfSk7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRseVNlbmRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMucmVsZWFzZSgpOyAvLyB0aGVyZSBpcyBub3QgcG9pbnQgaW4gcmVsZWFzaW5nIGlmIHdlIGRvIG5vdCBzZW5kIGF0bVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZG9TZW5kTmV4dCgpO1xuICAgIH07XG4gICAgQ2xpZW50Q29ubmVjdG9yLnByb3RvdHlwZS5kb1NlbmROZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5jb21tYW5kUXVldWUubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHVzaEVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVucXVldWVQdXNoQ29tbWFuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50bHlTZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VycmVudGx5U2VuZGluZyA9IHRydWU7XG4gICAgICAgIHZhciBjbWRzQW5kSGFuZGxlcnMgPSB0aGlzLmNvbW1hbmRCYXRjaGVyLmJhdGNoKHRoaXMuY29tbWFuZFF1ZXVlKTtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gY21kc0FuZEhhbmRsZXJzW2NtZHNBbmRIYW5kbGVycy5sZW5ndGggLSAxXS5oYW5kbGVyO1xuICAgICAgICB2YXIgY29tbWFuZHMgPSBjbWRzQW5kSGFuZGxlcnMubWFwKGZ1bmN0aW9uIChjYWgpIHsgcmV0dXJuIGNhaC5jb21tYW5kOyB9KTtcbiAgICAgICAgdGhpcy50cmFuc21pdHRlci50cmFuc21pdChjb21tYW5kcywgZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwic2VydmVyIHJlc3BvbnNlOiBbXCIgKyByZXNwb25zZS5tYXAoaXQgPT4gaXQuaWQpLmpvaW4oXCIsIFwiKSArIFwiXSBcIik7XG4gICAgICAgICAgICB2YXIgdG91Y2hlZFBNcyA9IFtdO1xuICAgICAgICAgICAgcmVzcG9uc2UuZm9yRWFjaChmdW5jdGlvbiAoY29tbWFuZCkge1xuICAgICAgICAgICAgICAgIHZhciB0b3VjaGVkID0gX3RoaXMuaGFuZGxlKGNvbW1hbmQpO1xuICAgICAgICAgICAgICAgIGlmICh0b3VjaGVkKVxuICAgICAgICAgICAgICAgICAgICB0b3VjaGVkUE1zLnB1c2godG91Y2hlZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLm9uRmluaXNoZWQodG91Y2hlZFBNcyk7IC8vIHRvZG86IG1ha2UgdGhlbSB1bmlxdWU/XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZWN1cnNpdmUgY2FsbDogZmV0Y2ggdGhlIG5leHQgaW4gbGluZSBidXQgYWxsb3cgYSBiaXQgb2Ygc2xhY2sgc3VjaCB0aGF0XG4gICAgICAgICAgICAvLyBkb2N1bWVudCBldmVudHMgY2FuIGZpcmUsIHJlbmRlcmluZyBpcyBkb25lIGFuZCBjb21tYW5kcyBjYW4gYmF0Y2ggdXBcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZG9TZW5kTmV4dCgpOyB9LCBfdGhpcy5zbGFja01TKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDbGllbnRDb25uZWN0b3IucHJvdG90eXBlLmhhbmRsZSA9IGZ1bmN0aW9uIChjb21tYW5kKSB7XG4gICAgICAgIGlmIChjb21tYW5kLmlkID09IFwiRGF0YVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVEYXRhQ29tbWFuZChjb21tYW5kKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb21tYW5kLmlkID09IFwiRGVsZXRlUHJlc2VudGF0aW9uTW9kZWxcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlRGVsZXRlUHJlc2VudGF0aW9uTW9kZWxDb21tYW5kKGNvbW1hbmQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbW1hbmQuaWQgPT0gXCJEZWxldGVBbGxQcmVzZW50YXRpb25Nb2RlbHNPZlR5cGVcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlRGVsZXRlQWxsUHJlc2VudGF0aW9uTW9kZWxPZlR5cGVDb21tYW5kKGNvbW1hbmQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbW1hbmQuaWQgPT0gXCJDcmVhdGVQcmVzZW50YXRpb25Nb2RlbFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVDcmVhdGVQcmVzZW50YXRpb25Nb2RlbENvbW1hbmQoY29tbWFuZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29tbWFuZC5pZCA9PSBcIlZhbHVlQ2hhbmdlZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVWYWx1ZUNoYW5nZWRDb21tYW5kKGNvbW1hbmQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbW1hbmQuaWQgPT0gXCJTd2l0Y2hQcmVzZW50YXRpb25Nb2RlbFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVTd2l0Y2hQcmVzZW50YXRpb25Nb2RlbENvbW1hbmQoY29tbWFuZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29tbWFuZC5pZCA9PSBcIkluaXRpYWxpemVBdHRyaWJ1dGVcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlSW5pdGlhbGl6ZUF0dHJpYnV0ZUNvbW1hbmQoY29tbWFuZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29tbWFuZC5pZCA9PSBcIkF0dHJpYnV0ZU1ldGFkYXRhQ2hhbmdlZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVBdHRyaWJ1dGVNZXRhZGF0YUNoYW5nZWRDb21tYW5kKGNvbW1hbmQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbW1hbmQuaWQgPT0gXCJDYWxsTmFtZWRBY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlQ2FsbE5hbWVkQWN0aW9uQ29tbWFuZChjb21tYW5kKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ2Fubm90IGhhbmRsZSwgdW5rbm93biBjb21tYW5kIFwiICsgY29tbWFuZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBDbGllbnRDb25uZWN0b3IucHJvdG90eXBlLmhhbmRsZURhdGFDb21tYW5kID0gZnVuY3Rpb24gKHNlcnZlckNvbW1hbmQpIHtcbiAgICAgICAgcmV0dXJuIHNlcnZlckNvbW1hbmQuZGF0YTtcbiAgICB9O1xuICAgIENsaWVudENvbm5lY3Rvci5wcm90b3R5cGUuaGFuZGxlRGVsZXRlUHJlc2VudGF0aW9uTW9kZWxDb21tYW5kID0gZnVuY3Rpb24gKHNlcnZlckNvbW1hbmQpIHtcbiAgICAgICAgdmFyIG1vZGVsID0gdGhpcy5jbGllbnREb2xwaGluLmZpbmRQcmVzZW50YXRpb25Nb2RlbEJ5SWQoc2VydmVyQ29tbWFuZC5wbUlkKTtcbiAgICAgICAgaWYgKCFtb2RlbClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB0aGlzLmNsaWVudERvbHBoaW4uZ2V0Q2xpZW50TW9kZWxTdG9yZSgpLmRlbGV0ZVByZXNlbnRhdGlvbk1vZGVsKG1vZGVsLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgIH07XG4gICAgQ2xpZW50Q29ubmVjdG9yLnByb3RvdHlwZS5oYW5kbGVEZWxldGVBbGxQcmVzZW50YXRpb25Nb2RlbE9mVHlwZUNvbW1hbmQgPSBmdW5jdGlvbiAoc2VydmVyQ29tbWFuZCkge1xuICAgICAgICB0aGlzLmNsaWVudERvbHBoaW4uZGVsZXRlQWxsUHJlc2VudGF0aW9uTW9kZWxPZlR5cGUoc2VydmVyQ29tbWFuZC5wbVR5cGUpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIENsaWVudENvbm5lY3Rvci5wcm90b3R5cGUuaGFuZGxlQ3JlYXRlUHJlc2VudGF0aW9uTW9kZWxDb21tYW5kID0gZnVuY3Rpb24gKHNlcnZlckNvbW1hbmQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuY2xpZW50RG9scGhpbi5nZXRDbGllbnRNb2RlbFN0b3JlKCkuY29udGFpbnNQcmVzZW50YXRpb25Nb2RlbChzZXJ2ZXJDb21tYW5kLnBtSWQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGVyZSBhbHJlYWR5IGlzIGEgcHJlc2VudGF0aW9uIG1vZGVsIHdpdGggaWQgXCIgKyBzZXJ2ZXJDb21tYW5kLnBtSWQgKyBcIiAga25vd24gdG8gdGhlIGNsaWVudC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBbXTtcbiAgICAgICAgc2VydmVyQ29tbWFuZC5hdHRyaWJ1dGVzLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICAgIHZhciBjbGllbnRBdHRyaWJ1dGUgPSBfdGhpcy5jbGllbnREb2xwaGluLmF0dHJpYnV0ZShhdHRyLnByb3BlcnR5TmFtZSwgYXR0ci5xdWFsaWZpZXIsIGF0dHIudmFsdWUpO1xuICAgICAgICAgICAgaWYgKGF0dHIuaWQgJiYgYXR0ci5pZC5tYXRjaChcIi4qUyRcIikpIHtcbiAgICAgICAgICAgICAgICBjbGllbnRBdHRyaWJ1dGUuaWQgPSBhdHRyLmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXR0cmlidXRlcy5wdXNoKGNsaWVudEF0dHJpYnV0ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgY2xpZW50UG0gPSBuZXcgQ2xpZW50UHJlc2VudGF0aW9uTW9kZWxfMS5DbGllbnRQcmVzZW50YXRpb25Nb2RlbChzZXJ2ZXJDb21tYW5kLnBtSWQsIHNlcnZlckNvbW1hbmQucG1UeXBlKTtcbiAgICAgICAgY2xpZW50UG0uYWRkQXR0cmlidXRlcyhhdHRyaWJ1dGVzKTtcbiAgICAgICAgaWYgKHNlcnZlckNvbW1hbmQuY2xpZW50U2lkZU9ubHkpIHtcbiAgICAgICAgICAgIGNsaWVudFBtLmNsaWVudFNpZGVPbmx5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsaWVudERvbHBoaW4uZ2V0Q2xpZW50TW9kZWxTdG9yZSgpLmFkZChjbGllbnRQbSk7XG4gICAgICAgIHRoaXMuY2xpZW50RG9scGhpbi51cGRhdGVQcmVzZW50YXRpb25Nb2RlbFF1YWxpZmllcihjbGllbnRQbSk7XG4gICAgICAgIHJldHVybiBjbGllbnRQbTtcbiAgICB9O1xuICAgIENsaWVudENvbm5lY3Rvci5wcm90b3R5cGUuaGFuZGxlVmFsdWVDaGFuZ2VkQ29tbWFuZCA9IGZ1bmN0aW9uIChzZXJ2ZXJDb21tYW5kKSB7XG4gICAgICAgIHZhciBjbGllbnRBdHRyaWJ1dGUgPSB0aGlzLmNsaWVudERvbHBoaW4uZ2V0Q2xpZW50TW9kZWxTdG9yZSgpLmZpbmRBdHRyaWJ1dGVCeUlkKHNlcnZlckNvbW1hbmQuYXR0cmlidXRlSWQpO1xuICAgICAgICBpZiAoIWNsaWVudEF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJhdHRyaWJ1dGUgd2l0aCBpZCBcIiArIHNlcnZlckNvbW1hbmQuYXR0cmlidXRlSWQgKyBcIiBub3QgZm91bmQsIGNhbm5vdCB1cGRhdGUgb2xkIHZhbHVlIFwiICsgc2VydmVyQ29tbWFuZC5vbGRWYWx1ZSArIFwiIHRvIG5ldyB2YWx1ZSBcIiArIHNlcnZlckNvbW1hbmQubmV3VmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsaWVudEF0dHJpYnV0ZS5nZXRWYWx1ZSgpID09IHNlcnZlckNvbW1hbmQubmV3VmFsdWUpIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJub3RoaW5nIHRvIGRvLiBuZXcgdmFsdWUgPT0gb2xkIHZhbHVlXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmVsb3cgd2FzIHRoZSBjb2RlIHRoYXQgd291bGQgZW5mb3JjZSB0aGF0IHZhbHVlIGNoYW5nZXMgb25seSBhcHBlYXIgd2hlbiB0aGUgcHJvcGVyIG9sZFZhbHVlIGlzIGdpdmVuLlxuICAgICAgICAvLyBXaGlsZSB0aGF0IHNlZW1lZCBhcHByb3ByaWF0ZSBhdCBmaXJzdCwgdGhlcmUgYXJlIGFjdHVhbGx5IHZhbGlkIGNvbW1hbmQgc2VxdWVuY2VzIHdoZXJlIHRoZSBvbGRWYWx1ZSBpcyBub3QgcHJvcGVybHkgc2V0LlxuICAgICAgICAvLyBXZSBsZWF2ZSB0aGUgY29tbWVudGVkIGNvZGUgaW4gdGhlIGNvZGViYXNlIHRvIGFsbG93IGZvciBsb2dnaW5nL2RlYnVnZ2luZyBzdWNoIGNhc2VzLlxuICAgICAgICAvLyAgICAgICAgICAgIGlmKGNsaWVudEF0dHJpYnV0ZS5nZXRWYWx1ZSgpICE9IHNlcnZlckNvbW1hbmQub2xkVmFsdWUpIHtcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJhdHRyaWJ1dGUgd2l0aCBpZCBcIitzZXJ2ZXJDb21tYW5kLmF0dHJpYnV0ZUlkK1wiIGFuZCB2YWx1ZSBcIiArIGNsaWVudEF0dHJpYnV0ZS5nZXRWYWx1ZSgpICtcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgd2FzIHNldCB0byB2YWx1ZSBcIiArIHNlcnZlckNvbW1hbmQubmV3VmFsdWUgKyBcIiBldmVuIHRob3VnaCB0aGUgY2hhbmdlIHdhcyBiYXNlZCBvbiBhbiBvdXRkYXRlZCBvbGQgdmFsdWUgb2YgXCIgKyBzZXJ2ZXJDb21tYW5kLm9sZFZhbHVlKTtcbiAgICAgICAgLy8gICAgICAgICAgICB9XG4gICAgICAgIGNsaWVudEF0dHJpYnV0ZS5zZXRWYWx1ZShzZXJ2ZXJDb21tYW5kLm5ld1ZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBDbGllbnRDb25uZWN0b3IucHJvdG90eXBlLmhhbmRsZVN3aXRjaFByZXNlbnRhdGlvbk1vZGVsQ29tbWFuZCA9IGZ1bmN0aW9uIChzZXJ2ZXJDb21tYW5kKSB7XG4gICAgICAgIHZhciBzd2l0Y2hQbSA9IHRoaXMuY2xpZW50RG9scGhpbi5nZXRDbGllbnRNb2RlbFN0b3JlKCkuZmluZFByZXNlbnRhdGlvbk1vZGVsQnlJZChzZXJ2ZXJDb21tYW5kLnBtSWQpO1xuICAgICAgICBpZiAoIXN3aXRjaFBtKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInN3aXRjaCBtb2RlbCB3aXRoIGlkIFwiICsgc2VydmVyQ29tbWFuZC5wbUlkICsgXCIgbm90IGZvdW5kLCBjYW5ub3Qgc3dpdGNoLlwiKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzb3VyY2VQbSA9IHRoaXMuY2xpZW50RG9scGhpbi5nZXRDbGllbnRNb2RlbFN0b3JlKCkuZmluZFByZXNlbnRhdGlvbk1vZGVsQnlJZChzZXJ2ZXJDb21tYW5kLnNvdXJjZVBtSWQpO1xuICAgICAgICBpZiAoIXNvdXJjZVBtKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInNvdXJjZSBtb2RlbCB3aXRoIGlkIFwiICsgc2VydmVyQ29tbWFuZC5zb3VyY2VQbUlkICsgXCIgbm90IGZvdW5kLCBjYW5ub3Qgc3dpdGNoLlwiKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaFBtLnN5bmNXaXRoKHNvdXJjZVBtKTtcbiAgICAgICAgcmV0dXJuIHN3aXRjaFBtO1xuICAgIH07XG4gICAgQ2xpZW50Q29ubmVjdG9yLnByb3RvdHlwZS5oYW5kbGVJbml0aWFsaXplQXR0cmlidXRlQ29tbWFuZCA9IGZ1bmN0aW9uIChzZXJ2ZXJDb21tYW5kKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGUgPSBuZXcgQ2xpZW50QXR0cmlidXRlXzEuQ2xpZW50QXR0cmlidXRlKHNlcnZlckNvbW1hbmQucHJvcGVydHlOYW1lLCBzZXJ2ZXJDb21tYW5kLnF1YWxpZmllciwgc2VydmVyQ29tbWFuZC5uZXdWYWx1ZSk7XG4gICAgICAgIGlmIChzZXJ2ZXJDb21tYW5kLnF1YWxpZmllcikge1xuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZXNDb3B5ID0gdGhpcy5jbGllbnREb2xwaGluLmdldENsaWVudE1vZGVsU3RvcmUoKS5maW5kQWxsQXR0cmlidXRlc0J5UXVhbGlmaWVyKHNlcnZlckNvbW1hbmQucXVhbGlmaWVyKTtcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVzQ29weSkge1xuICAgICAgICAgICAgICAgIGlmICghc2VydmVyQ29tbWFuZC5uZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0ciA9IGF0dHJpYnV0ZXNDb3B5LnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGUuc2V0VmFsdWUoYXR0ci5nZXRWYWx1ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlc0NvcHkuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0ci5zZXRWYWx1ZShhdHRyaWJ1dGUuZ2V0VmFsdWUoKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJlc2VudGF0aW9uTW9kZWw7XG4gICAgICAgIGlmIChzZXJ2ZXJDb21tYW5kLnBtSWQpIHtcbiAgICAgICAgICAgIHByZXNlbnRhdGlvbk1vZGVsID0gdGhpcy5jbGllbnREb2xwaGluLmdldENsaWVudE1vZGVsU3RvcmUoKS5maW5kUHJlc2VudGF0aW9uTW9kZWxCeUlkKHNlcnZlckNvbW1hbmQucG1JZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwcmVzZW50YXRpb25Nb2RlbCkge1xuICAgICAgICAgICAgcHJlc2VudGF0aW9uTW9kZWwgPSBuZXcgQ2xpZW50UHJlc2VudGF0aW9uTW9kZWxfMS5DbGllbnRQcmVzZW50YXRpb25Nb2RlbChzZXJ2ZXJDb21tYW5kLnBtSWQsIHNlcnZlckNvbW1hbmQucG1UeXBlKTtcbiAgICAgICAgICAgIHRoaXMuY2xpZW50RG9scGhpbi5nZXRDbGllbnRNb2RlbFN0b3JlKCkuYWRkKHByZXNlbnRhdGlvbk1vZGVsKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsaWVudERvbHBoaW4uYWRkQXR0cmlidXRlVG9Nb2RlbChwcmVzZW50YXRpb25Nb2RlbCwgYXR0cmlidXRlKTtcbiAgICAgICAgdGhpcy5jbGllbnREb2xwaGluLnVwZGF0ZVByZXNlbnRhdGlvbk1vZGVsUXVhbGlmaWVyKHByZXNlbnRhdGlvbk1vZGVsKTtcbiAgICAgICAgcmV0dXJuIHByZXNlbnRhdGlvbk1vZGVsO1xuICAgIH07XG4gICAgQ2xpZW50Q29ubmVjdG9yLnByb3RvdHlwZS5oYW5kbGVBdHRyaWJ1dGVNZXRhZGF0YUNoYW5nZWRDb21tYW5kID0gZnVuY3Rpb24gKHNlcnZlckNvbW1hbmQpIHtcbiAgICAgICAgdmFyIGNsaWVudEF0dHJpYnV0ZSA9IHRoaXMuY2xpZW50RG9scGhpbi5nZXRDbGllbnRNb2RlbFN0b3JlKCkuZmluZEF0dHJpYnV0ZUJ5SWQoc2VydmVyQ29tbWFuZC5hdHRyaWJ1dGVJZCk7XG4gICAgICAgIGlmICghY2xpZW50QXR0cmlidXRlKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNsaWVudEF0dHJpYnV0ZVtzZXJ2ZXJDb21tYW5kLm1ldGFkYXRhTmFtZV0gPSBzZXJ2ZXJDb21tYW5kLnZhbHVlO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIENsaWVudENvbm5lY3Rvci5wcm90b3R5cGUuaGFuZGxlQ2FsbE5hbWVkQWN0aW9uQ29tbWFuZCA9IGZ1bmN0aW9uIChzZXJ2ZXJDb21tYW5kKSB7XG4gICAgICAgIHRoaXMuY2xpZW50RG9scGhpbi5zZW5kKHNlcnZlckNvbW1hbmQuYWN0aW9uTmFtZSwgbnVsbCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLy8vLy8vLy8vLy8vLyBwdXNoIHN1cHBvcnQgLy8vLy8vLy8vLy8vLy8vXG4gICAgQ2xpZW50Q29ubmVjdG9yLnByb3RvdHlwZS5saXN0ZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5wdXNoRW5hYmxlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMud2FpdGluZylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gdG9kbzogaG93IHRvIGlzc3VlIGEgd2FybmluZyBpZiBubyBwdXNoTGlzdGVuZXIgaXMgc2V0P1xuICAgICAgICBpZiAoIXRoaXMuY3VycmVudGx5U2VuZGluZykge1xuICAgICAgICAgICAgdGhpcy5kb1NlbmROZXh0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENsaWVudENvbm5lY3Rvci5wcm90b3R5cGUuZW5xdWV1ZVB1c2hDb21tYW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB0aGlzLndhaXRpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmNvbW1hbmRRdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgIGNvbW1hbmQ6IHRoaXMucHVzaExpc3RlbmVyLFxuICAgICAgICAgICAgaGFuZGxlcjoge1xuICAgICAgICAgICAgICAgIG9uRmluaXNoZWQ6IGZ1bmN0aW9uIChtb2RlbHMpIHsgbWUud2FpdGluZyA9IGZhbHNlOyB9LFxuICAgICAgICAgICAgICAgIG9uRmluaXNoZWREYXRhOiBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ2xpZW50Q29ubmVjdG9yLnByb3RvdHlwZS5yZWxlYXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMud2FpdGluZylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy53YWl0aW5nID0gZmFsc2U7XG4gICAgICAgIC8vIHRvZG86IGhvdyB0byBpc3N1ZSBhIHdhcm5pbmcgaWYgbm8gcmVsZWFzZUNvbW1hbmQgaXMgc2V0P1xuICAgICAgICB0aGlzLnRyYW5zbWl0dGVyLnNpZ25hbCh0aGlzLnJlbGVhc2VDb21tYW5kKTtcbiAgICB9O1xuICAgIHJldHVybiBDbGllbnRDb25uZWN0b3I7XG59KCkpO1xuZXhwb3J0cy5DbGllbnRDb25uZWN0b3IgPSBDbGllbnRDb25uZWN0b3I7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNsaWVudENvbm5lY3Rvci5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIEF0dHJpYnV0ZUNyZWF0ZWROb3RpZmljYXRpb25fMSA9IHJlcXVpcmUoXCIuL0F0dHJpYnV0ZUNyZWF0ZWROb3RpZmljYXRpb25cIik7XG52YXIgQ2xpZW50QXR0cmlidXRlXzEgPSByZXF1aXJlKFwiLi9DbGllbnRBdHRyaWJ1dGVcIik7XG52YXIgQ2xpZW50UHJlc2VudGF0aW9uTW9kZWxfMSA9IHJlcXVpcmUoXCIuL0NsaWVudFByZXNlbnRhdGlvbk1vZGVsXCIpO1xudmFyIEVtcHR5Tm90aWZpY2F0aW9uXzEgPSByZXF1aXJlKFwiLi9FbXB0eU5vdGlmaWNhdGlvblwiKTtcbnZhciBOYW1lZENvbW1hbmRfMSA9IHJlcXVpcmUoXCIuL05hbWVkQ29tbWFuZFwiKTtcbnZhciBTaWduYWxDb21tYW5kXzEgPSByZXF1aXJlKFwiLi9TaWduYWxDb21tYW5kXCIpO1xudmFyIENsaWVudERvbHBoaW4gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENsaWVudERvbHBoaW4oKSB7XG4gICAgfVxuICAgIENsaWVudERvbHBoaW4ucHJvdG90eXBlLnNldENsaWVudENvbm5lY3RvciA9IGZ1bmN0aW9uIChjbGllbnRDb25uZWN0b3IpIHtcbiAgICAgICAgdGhpcy5jbGllbnRDb25uZWN0b3IgPSBjbGllbnRDb25uZWN0b3I7XG4gICAgfTtcbiAgICBDbGllbnREb2xwaGluLnByb3RvdHlwZS5nZXRDbGllbnRDb25uZWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudENvbm5lY3RvcjtcbiAgICB9O1xuICAgIENsaWVudERvbHBoaW4ucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoY29tbWFuZE5hbWUsIG9uRmluaXNoZWQpIHtcbiAgICAgICAgdGhpcy5jbGllbnRDb25uZWN0b3Iuc2VuZChuZXcgTmFtZWRDb21tYW5kXzFbXCJkZWZhdWx0XCJdKGNvbW1hbmROYW1lKSwgb25GaW5pc2hlZCk7XG4gICAgfTtcbiAgICBDbGllbnREb2xwaGluLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIChzdWNjZXNzSGFuZGxlcikge1xuICAgICAgICB0aGlzLmNsaWVudENvbm5lY3Rvci5yZXNldChzdWNjZXNzSGFuZGxlcik7XG4gICAgfTtcbiAgICBDbGllbnREb2xwaGluLnByb3RvdHlwZS5zZW5kRW1wdHkgPSBmdW5jdGlvbiAob25GaW5pc2hlZCkge1xuICAgICAgICB0aGlzLmNsaWVudENvbm5lY3Rvci5zZW5kKG5ldyBFbXB0eU5vdGlmaWNhdGlvbl8xW1wiZGVmYXVsdFwiXSgpLCBvbkZpbmlzaGVkKTtcbiAgICB9O1xuICAgIC8vIGZhY3RvcnkgbWV0aG9kIGZvciBhdHRyaWJ1dGVzXG4gICAgQ2xpZW50RG9scGhpbi5wcm90b3R5cGUuYXR0cmlidXRlID0gZnVuY3Rpb24gKHByb3BlcnR5TmFtZSwgcXVhbGlmaWVyLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IENsaWVudEF0dHJpYnV0ZV8xLkNsaWVudEF0dHJpYnV0ZShwcm9wZXJ0eU5hbWUsIHF1YWxpZmllciwgdmFsdWUpO1xuICAgIH07XG4gICAgLy8gZmFjdG9yeSBtZXRob2QgZm9yIHByZXNlbnRhdGlvbiBtb2RlbHNcbiAgICBDbGllbnREb2xwaGluLnByb3RvdHlwZS5wcmVzZW50YXRpb25Nb2RlbCA9IGZ1bmN0aW9uIChpZCwgdHlwZSkge1xuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDI7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXR0cmlidXRlc1tfaSAtIDJdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbW9kZWwgPSBuZXcgQ2xpZW50UHJlc2VudGF0aW9uTW9kZWxfMS5DbGllbnRQcmVzZW50YXRpb25Nb2RlbChpZCwgdHlwZSk7XG4gICAgICAgIGlmIChhdHRyaWJ1dGVzICYmIGF0dHJpYnV0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgYXR0cmlidXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICBtb2RlbC5hZGRBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2V0Q2xpZW50TW9kZWxTdG9yZSgpLmFkZChtb2RlbCk7XG4gICAgICAgIHJldHVybiBtb2RlbDtcbiAgICB9O1xuICAgIENsaWVudERvbHBoaW4ucHJvdG90eXBlLnNldENsaWVudE1vZGVsU3RvcmUgPSBmdW5jdGlvbiAoY2xpZW50TW9kZWxTdG9yZSkge1xuICAgICAgICB0aGlzLmNsaWVudE1vZGVsU3RvcmUgPSBjbGllbnRNb2RlbFN0b3JlO1xuICAgIH07XG4gICAgQ2xpZW50RG9scGhpbi5wcm90b3R5cGUuZ2V0Q2xpZW50TW9kZWxTdG9yZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50TW9kZWxTdG9yZTtcbiAgICB9O1xuICAgIENsaWVudERvbHBoaW4ucHJvdG90eXBlLmxpc3RQcmVzZW50YXRpb25Nb2RlbElkcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2xpZW50TW9kZWxTdG9yZSgpLmxpc3RQcmVzZW50YXRpb25Nb2RlbElkcygpO1xuICAgIH07XG4gICAgQ2xpZW50RG9scGhpbi5wcm90b3R5cGUubGlzdFByZXNlbnRhdGlvbk1vZGVscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2xpZW50TW9kZWxTdG9yZSgpLmxpc3RQcmVzZW50YXRpb25Nb2RlbHMoKTtcbiAgICB9O1xuICAgIENsaWVudERvbHBoaW4ucHJvdG90eXBlLmZpbmRBbGxQcmVzZW50YXRpb25Nb2RlbEJ5VHlwZSA9IGZ1bmN0aW9uIChwcmVzZW50YXRpb25Nb2RlbFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2xpZW50TW9kZWxTdG9yZSgpLmZpbmRBbGxQcmVzZW50YXRpb25Nb2RlbEJ5VHlwZShwcmVzZW50YXRpb25Nb2RlbFR5cGUpO1xuICAgIH07XG4gICAgQ2xpZW50RG9scGhpbi5wcm90b3R5cGUuZ2V0QXQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZFByZXNlbnRhdGlvbk1vZGVsQnlJZChpZCk7XG4gICAgfTtcbiAgICBDbGllbnREb2xwaGluLnByb3RvdHlwZS5maW5kUHJlc2VudGF0aW9uTW9kZWxCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENsaWVudE1vZGVsU3RvcmUoKS5maW5kUHJlc2VudGF0aW9uTW9kZWxCeUlkKGlkKTtcbiAgICB9O1xuICAgIENsaWVudERvbHBoaW4ucHJvdG90eXBlLmRlbGV0ZVByZXNlbnRhdGlvbk1vZGVsID0gZnVuY3Rpb24gKG1vZGVsVG9EZWxldGUpIHtcbiAgICAgICAgdGhpcy5nZXRDbGllbnRNb2RlbFN0b3JlKCkuZGVsZXRlUHJlc2VudGF0aW9uTW9kZWwobW9kZWxUb0RlbGV0ZSwgdHJ1ZSk7XG4gICAgfTtcbiAgICBDbGllbnREb2xwaGluLnByb3RvdHlwZS5kZWxldGVBbGxQcmVzZW50YXRpb25Nb2RlbE9mVHlwZSA9IGZ1bmN0aW9uIChwcmVzZW50YXRpb25Nb2RlbFR5cGUpIHtcbiAgICAgICAgdGhpcy5nZXRDbGllbnRNb2RlbFN0b3JlKCkuZGVsZXRlQWxsUHJlc2VudGF0aW9uTW9kZWxPZlR5cGUocHJlc2VudGF0aW9uTW9kZWxUeXBlKTtcbiAgICB9O1xuICAgIENsaWVudERvbHBoaW4ucHJvdG90eXBlLnVwZGF0ZVByZXNlbnRhdGlvbk1vZGVsUXVhbGlmaWVyID0gZnVuY3Rpb24gKHByZXNlbnRhdGlvbk1vZGVsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHByZXNlbnRhdGlvbk1vZGVsLmdldEF0dHJpYnV0ZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIF90aGlzLnVwZGF0ZUF0dHJpYnV0ZVF1YWxpZmllcihzb3VyY2VBdHRyaWJ1dGUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENsaWVudERvbHBoaW4ucHJvdG90eXBlLnVwZGF0ZUF0dHJpYnV0ZVF1YWxpZmllciA9IGZ1bmN0aW9uIChzb3VyY2VBdHRyaWJ1dGUpIHtcbiAgICAgICAgaWYgKCFzb3VyY2VBdHRyaWJ1dGUuZ2V0UXVhbGlmaWVyKCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gdGhpcy5nZXRDbGllbnRNb2RlbFN0b3JlKCkuZmluZEFsbEF0dHJpYnV0ZXNCeVF1YWxpZmllcihzb3VyY2VBdHRyaWJ1dGUuZ2V0UXVhbGlmaWVyKCkpO1xuICAgICAgICBhdHRyaWJ1dGVzLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldEF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgdGFyZ2V0QXR0cmlidXRlLnNldFZhbHVlKHNvdXJjZUF0dHJpYnV0ZS5nZXRWYWx1ZSgpKTsgLy8gc2hvdWxkIGFsd2F5cyBoYXZlIHRoZSBzYW1lIHZhbHVlXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ2xpZW50RG9scGhpbi5wcm90b3R5cGUuYWRkQXR0cmlidXRlVG9Nb2RlbCA9IGZ1bmN0aW9uIChwcmVzZW50YXRpb25Nb2RlbCwgY2xpZW50QXR0cmlidXRlKSB7XG4gICAgICAgIHByZXNlbnRhdGlvbk1vZGVsLmFkZEF0dHJpYnV0ZShjbGllbnRBdHRyaWJ1dGUpO1xuICAgICAgICB0aGlzLmdldENsaWVudE1vZGVsU3RvcmUoKS5yZWdpc3RlckF0dHJpYnV0ZShjbGllbnRBdHRyaWJ1dGUpO1xuICAgICAgICBpZiAoIXByZXNlbnRhdGlvbk1vZGVsLmNsaWVudFNpZGVPbmx5KSB7XG4gICAgICAgICAgICB0aGlzLmNsaWVudENvbm5lY3Rvci5zZW5kKG5ldyBBdHRyaWJ1dGVDcmVhdGVkTm90aWZpY2F0aW9uXzFbXCJkZWZhdWx0XCJdKHByZXNlbnRhdGlvbk1vZGVsLmlkLCBjbGllbnRBdHRyaWJ1dGUuaWQsIGNsaWVudEF0dHJpYnV0ZS5wcm9wZXJ0eU5hbWUsIGNsaWVudEF0dHJpYnV0ZS5nZXRWYWx1ZSgpLCBjbGllbnRBdHRyaWJ1dGUuZ2V0UXVhbGlmaWVyKCkpLCBudWxsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8vLy8vIHB1c2ggc3VwcG9ydCAvLy8vLy8vXG4gICAgQ2xpZW50RG9scGhpbi5wcm90b3R5cGUuc3RhcnRQdXNoTGlzdGVuaW5nID0gZnVuY3Rpb24gKHB1c2hBY3Rpb25OYW1lLCByZWxlYXNlQWN0aW9uTmFtZSkge1xuICAgICAgICB0aGlzLmNsaWVudENvbm5lY3Rvci5zZXRQdXNoTGlzdGVuZXIobmV3IE5hbWVkQ29tbWFuZF8xW1wiZGVmYXVsdFwiXShwdXNoQWN0aW9uTmFtZSkpO1xuICAgICAgICB0aGlzLmNsaWVudENvbm5lY3Rvci5zZXRSZWxlYXNlQ29tbWFuZChuZXcgU2lnbmFsQ29tbWFuZF8xW1wiZGVmYXVsdFwiXShyZWxlYXNlQWN0aW9uTmFtZSkpO1xuICAgICAgICB0aGlzLmNsaWVudENvbm5lY3Rvci5zZXRQdXNoRW5hYmxlZCh0cnVlKTtcbiAgICAgICAgdGhpcy5jbGllbnRDb25uZWN0b3IubGlzdGVuKCk7XG4gICAgfTtcbiAgICBDbGllbnREb2xwaGluLnByb3RvdHlwZS5zdG9wUHVzaExpc3RlbmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jbGllbnRDb25uZWN0b3Iuc2V0UHVzaEVuYWJsZWQoZmFsc2UpO1xuICAgIH07XG4gICAgcmV0dXJuIENsaWVudERvbHBoaW47XG59KCkpO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gQ2xpZW50RG9scGhpbjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2xpZW50RG9scGhpbi5qcy5tYXBcbiIsIi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuL2NvcmUtanMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBBdHRyaWJ1dGVfMSA9IHJlcXVpcmUoXCIuL0F0dHJpYnV0ZVwiKTtcbnZhciBDaGFuZ2VBdHRyaWJ1dGVNZXRhZGF0YUNvbW1hbmRfMSA9IHJlcXVpcmUoXCIuL0NoYW5nZUF0dHJpYnV0ZU1ldGFkYXRhQ29tbWFuZFwiKTtcbnZhciBDcmVhdGVQcmVzZW50YXRpb25Nb2RlbENvbW1hbmRfMSA9IHJlcXVpcmUoXCIuL0NyZWF0ZVByZXNlbnRhdGlvbk1vZGVsQ29tbWFuZFwiKTtcbnZhciBEZWxldGVkQWxsUHJlc2VudGF0aW9uTW9kZWxzT2ZUeXBlTm90aWZpY2F0aW9uXzEgPSByZXF1aXJlKFwiLi9EZWxldGVkQWxsUHJlc2VudGF0aW9uTW9kZWxzT2ZUeXBlTm90aWZpY2F0aW9uXCIpO1xudmFyIERlbGV0ZWRQcmVzZW50YXRpb25Nb2RlbE5vdGlmaWNhdGlvbl8xID0gcmVxdWlyZShcIi4vRGVsZXRlZFByZXNlbnRhdGlvbk1vZGVsTm90aWZpY2F0aW9uXCIpO1xudmFyIEV2ZW50QnVzXzEgPSByZXF1aXJlKFwiLi9FdmVudEJ1c1wiKTtcbnZhciBWYWx1ZUNoYW5nZWRDb21tYW5kXzEgPSByZXF1aXJlKFwiLi9WYWx1ZUNoYW5nZWRDb21tYW5kXCIpO1xuKGZ1bmN0aW9uIChUeXBlKSB7XG4gICAgVHlwZVtUeXBlW1wiQURERURcIl0gPSAnQURERUQnXSA9IFwiQURERURcIjtcbiAgICBUeXBlW1R5cGVbXCJSRU1PVkVEXCJdID0gJ1JFTU9WRUQnXSA9IFwiUkVNT1ZFRFwiO1xufSkoZXhwb3J0cy5UeXBlIHx8IChleHBvcnRzLlR5cGUgPSB7fSkpO1xudmFyIFR5cGUgPSBleHBvcnRzLlR5cGU7XG52YXIgQ2xpZW50TW9kZWxTdG9yZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2xpZW50TW9kZWxTdG9yZShjbGllbnREb2xwaGluKSB7XG4gICAgICAgIHRoaXMuY2xpZW50RG9scGhpbiA9IGNsaWVudERvbHBoaW47XG4gICAgICAgIHRoaXMucHJlc2VudGF0aW9uTW9kZWxzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnByZXNlbnRhdGlvbk1vZGVsc1BlclR5cGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlc1BlcklkID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXNQZXJRdWFsaWZpZXIgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubW9kZWxTdG9yZUNoYW5nZUJ1cyA9IG5ldyBFdmVudEJ1c18xW1wiZGVmYXVsdFwiXSgpO1xuICAgIH1cbiAgICBDbGllbnRNb2RlbFN0b3JlLnByb3RvdHlwZS5nZXRDbGllbnREb2xwaGluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnREb2xwaGluO1xuICAgIH07XG4gICAgQ2xpZW50TW9kZWxTdG9yZS5wcm90b3R5cGUucmVnaXN0ZXJNb2RlbCA9IGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAobW9kZWwuY2xpZW50U2lkZU9ubHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29ubmVjdG9yID0gdGhpcy5jbGllbnREb2xwaGluLmdldENsaWVudENvbm5lY3RvcigpO1xuICAgICAgICB2YXIgY3JlYXRlUE1Db21tYW5kID0gbmV3IENyZWF0ZVByZXNlbnRhdGlvbk1vZGVsQ29tbWFuZF8xW1wiZGVmYXVsdFwiXShtb2RlbCk7XG4gICAgICAgIGNvbm5lY3Rvci5zZW5kKGNyZWF0ZVBNQ29tbWFuZCwgbnVsbCk7XG4gICAgICAgIG1vZGVsLmdldEF0dHJpYnV0ZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIF90aGlzLnJlZ2lzdGVyQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ2xpZW50TW9kZWxTdG9yZS5wcm90b3R5cGUucmVnaXN0ZXJBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuYWRkQXR0cmlidXRlQnlJZChhdHRyaWJ1dGUpO1xuICAgICAgICBpZiAoYXR0cmlidXRlLmdldFF1YWxpZmllcigpKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZUJ5UXVhbGlmaWVyKGF0dHJpYnV0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2hlbmV2ZXIgYW4gYXR0cmlidXRlIGNoYW5nZXMgaXRzIHZhbHVlLCB0aGUgc2VydmVyIG5lZWRzIHRvIGJlIG5vdGlmaWVkXG4gICAgICAgIC8vIGFuZCBhbGwgb3RoZXIgYXR0cmlidXRlcyB3aXRoIHRoZSBzYW1lIHF1YWxpZmllciBhcmUgZ2l2ZW4gdGhlIHNhbWUgdmFsdWVcbiAgICAgICAgYXR0cmlidXRlLm9uVmFsdWVDaGFuZ2UoZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlQ2hhbmdlQ29tbWFuZCA9IG5ldyBWYWx1ZUNoYW5nZWRDb21tYW5kXzFbXCJkZWZhdWx0XCJdKGF0dHJpYnV0ZS5pZCwgZXZ0Lm9sZFZhbHVlLCBldnQubmV3VmFsdWUpO1xuICAgICAgICAgICAgX3RoaXMuY2xpZW50RG9scGhpbi5nZXRDbGllbnRDb25uZWN0b3IoKS5zZW5kKHZhbHVlQ2hhbmdlQ29tbWFuZCwgbnVsbCk7XG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlLmdldFF1YWxpZmllcigpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJzID0gX3RoaXMuZmluZEF0dHJpYnV0ZXNCeUZpbHRlcihmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXR0ciAhPT0gYXR0cmlidXRlICYmIGF0dHIuZ2V0UXVhbGlmaWVyKCkgPT0gYXR0cmlidXRlLmdldFF1YWxpZmllcigpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGF0dHJzLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0ci5zZXRWYWx1ZShhdHRyaWJ1dGUuZ2V0VmFsdWUoKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBhdHRyaWJ1dGUub25RdWFsaWZpZXJDaGFuZ2UoZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgdmFyIGNoYW5nZUF0dHJNZXRhZGF0YUNtZCA9IG5ldyBDaGFuZ2VBdHRyaWJ1dGVNZXRhZGF0YUNvbW1hbmRfMVtcImRlZmF1bHRcIl0oYXR0cmlidXRlLmlkLCBBdHRyaWJ1dGVfMVtcImRlZmF1bHRcIl0uUVVBTElGSUVSX1BST1BFUlRZLCBldnQubmV3VmFsdWUpO1xuICAgICAgICAgICAgX3RoaXMuY2xpZW50RG9scGhpbi5nZXRDbGllbnRDb25uZWN0b3IoKS5zZW5kKGNoYW5nZUF0dHJNZXRhZGF0YUNtZCwgbnVsbCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ2xpZW50TW9kZWxTdG9yZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgICAgIGlmICghbW9kZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcmVzZW50YXRpb25Nb2RlbHMuaGFzKG1vZGVsLmlkKSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJUaGVyZSBhbHJlYWR5IGlzIGEgUE0gd2l0aCBpZCBcIiArIG1vZGVsLmlkKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWRkZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKCF0aGlzLnByZXNlbnRhdGlvbk1vZGVscy5oYXMobW9kZWwuaWQpKSB7XG4gICAgICAgICAgICB0aGlzLnByZXNlbnRhdGlvbk1vZGVscy5zZXQobW9kZWwuaWQsIG1vZGVsKTtcbiAgICAgICAgICAgIHRoaXMuYWRkUHJlc2VudGF0aW9uTW9kZWxCeVR5cGUobW9kZWwpO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3Rlck1vZGVsKG1vZGVsKTtcbiAgICAgICAgICAgIHRoaXMubW9kZWxTdG9yZUNoYW5nZUJ1cy50cmlnZ2VyKHsgJ2V2ZW50VHlwZSc6IFR5cGUuQURERUQsICdjbGllbnRQcmVzZW50YXRpb25Nb2RlbCc6IG1vZGVsIH0pO1xuICAgICAgICAgICAgYWRkZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhZGRlZDtcbiAgICB9O1xuICAgIENsaWVudE1vZGVsU3RvcmUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIW1vZGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlbW92ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMucHJlc2VudGF0aW9uTW9kZWxzLmhhcyhtb2RlbC5pZCkpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlUHJlc2VudGF0aW9uTW9kZWxCeVR5cGUobW9kZWwpO1xuICAgICAgICAgICAgdGhpcy5wcmVzZW50YXRpb25Nb2RlbHMuZGVsZXRlKG1vZGVsLmlkKTtcbiAgICAgICAgICAgIG1vZGVsLmdldEF0dHJpYnV0ZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZW1vdmVBdHRyaWJ1dGVCeUlkKGF0dHJpYnV0ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZS5nZXRRdWFsaWZpZXIoKSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZW1vdmVBdHRyaWJ1dGVCeVF1YWxpZmllcihhdHRyaWJ1dGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5tb2RlbFN0b3JlQ2hhbmdlQnVzLnRyaWdnZXIoeyAnZXZlbnRUeXBlJzogVHlwZS5SRU1PVkVELCAnY2xpZW50UHJlc2VudGF0aW9uTW9kZWwnOiBtb2RlbCB9KTtcbiAgICAgICAgICAgIHJlbW92ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZW1vdmVkO1xuICAgIH07XG4gICAgQ2xpZW50TW9kZWxTdG9yZS5wcm90b3R5cGUuZmluZEF0dHJpYnV0ZXNCeUZpbHRlciA9IGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSBbXTtcbiAgICAgICAgdGhpcy5wcmVzZW50YXRpb25Nb2RlbHMuZm9yRWFjaChmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAgICAgICAgIG1vZGVsLmdldEF0dHJpYnV0ZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlcihhdHRyKSkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzLnB1c2goYXR0cik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWF0Y2hlcztcbiAgICB9O1xuICAgIENsaWVudE1vZGVsU3RvcmUucHJvdG90eXBlLmFkZFByZXNlbnRhdGlvbk1vZGVsQnlUeXBlID0gZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgICAgIGlmICghbW9kZWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdHlwZSA9IG1vZGVsLnByZXNlbnRhdGlvbk1vZGVsVHlwZTtcbiAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXNlbnRhdGlvbk1vZGVscyA9IHRoaXMucHJlc2VudGF0aW9uTW9kZWxzUGVyVHlwZS5nZXQodHlwZSk7XG4gICAgICAgIGlmICghcHJlc2VudGF0aW9uTW9kZWxzKSB7XG4gICAgICAgICAgICBwcmVzZW50YXRpb25Nb2RlbHMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMucHJlc2VudGF0aW9uTW9kZWxzUGVyVHlwZS5zZXQodHlwZSwgcHJlc2VudGF0aW9uTW9kZWxzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShwcmVzZW50YXRpb25Nb2RlbHMuaW5kZXhPZihtb2RlbCkgPiAtMSkpIHtcbiAgICAgICAgICAgIHByZXNlbnRhdGlvbk1vZGVscy5wdXNoKG1vZGVsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2xpZW50TW9kZWxTdG9yZS5wcm90b3R5cGUucmVtb3ZlUHJlc2VudGF0aW9uTW9kZWxCeVR5cGUgPSBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAgICAgaWYgKCFtb2RlbCB8fCAhKG1vZGVsLnByZXNlbnRhdGlvbk1vZGVsVHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJlc2VudGF0aW9uTW9kZWxzID0gdGhpcy5wcmVzZW50YXRpb25Nb2RlbHNQZXJUeXBlLmdldChtb2RlbC5wcmVzZW50YXRpb25Nb2RlbFR5cGUpO1xuICAgICAgICBpZiAoIXByZXNlbnRhdGlvbk1vZGVscykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmVzZW50YXRpb25Nb2RlbHMubGVuZ3RoID4gLTEpIHtcbiAgICAgICAgICAgIHByZXNlbnRhdGlvbk1vZGVscy5zcGxpY2UocHJlc2VudGF0aW9uTW9kZWxzLmluZGV4T2YobW9kZWwpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJlc2VudGF0aW9uTW9kZWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5wcmVzZW50YXRpb25Nb2RlbHNQZXJUeXBlLmRlbGV0ZShtb2RlbC5wcmVzZW50YXRpb25Nb2RlbFR5cGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDbGllbnRNb2RlbFN0b3JlLnByb3RvdHlwZS5saXN0UHJlc2VudGF0aW9uTW9kZWxJZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdmFyIGl0ZXIgPSB0aGlzLnByZXNlbnRhdGlvbk1vZGVscy5rZXlzKCk7XG4gICAgICAgIHZhciBuZXh0ID0gaXRlci5uZXh0KCk7XG4gICAgICAgIHdoaWxlICghbmV4dC5kb25lKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChuZXh0LnZhbHVlKTtcbiAgICAgICAgICAgIG5leHQgPSBpdGVyLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgQ2xpZW50TW9kZWxTdG9yZS5wcm90b3R5cGUubGlzdFByZXNlbnRhdGlvbk1vZGVscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB2YXIgaXRlciA9IHRoaXMucHJlc2VudGF0aW9uTW9kZWxzLnZhbHVlcygpO1xuICAgICAgICB2YXIgbmV4dCA9IGl0ZXIubmV4dCgpO1xuICAgICAgICB3aGlsZSAoIW5leHQuZG9uZSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV4dC52YWx1ZSk7XG4gICAgICAgICAgICBuZXh0ID0gaXRlci5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIENsaWVudE1vZGVsU3RvcmUucHJvdG90eXBlLmZpbmRQcmVzZW50YXRpb25Nb2RlbEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJlc2VudGF0aW9uTW9kZWxzLmdldChpZCk7XG4gICAgfTtcbiAgICBDbGllbnRNb2RlbFN0b3JlLnByb3RvdHlwZS5maW5kQWxsUHJlc2VudGF0aW9uTW9kZWxCeVR5cGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICBpZiAoIXR5cGUgfHwgIXRoaXMucHJlc2VudGF0aW9uTW9kZWxzUGVyVHlwZS5oYXModHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcmVzZW50YXRpb25Nb2RlbHNQZXJUeXBlLmdldCh0eXBlKS5zbGljZSgwKTsgLy8gc2xpY2UgaXMgdXNlZCB0byBjbG9uZSB0aGUgYXJyYXlcbiAgICB9O1xuICAgIENsaWVudE1vZGVsU3RvcmUucHJvdG90eXBlLmRlbGV0ZUFsbFByZXNlbnRhdGlvbk1vZGVsT2ZUeXBlID0gZnVuY3Rpb24gKHByZXNlbnRhdGlvbk1vZGVsVHlwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcHJlc2VudGF0aW9uTW9kZWxzID0gdGhpcy5maW5kQWxsUHJlc2VudGF0aW9uTW9kZWxCeVR5cGUocHJlc2VudGF0aW9uTW9kZWxUeXBlKTtcbiAgICAgICAgcHJlc2VudGF0aW9uTW9kZWxzLmZvckVhY2goZnVuY3Rpb24gKHBtKSB7XG4gICAgICAgICAgICBfdGhpcy5kZWxldGVQcmVzZW50YXRpb25Nb2RlbChwbSwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jbGllbnREb2xwaGluLmdldENsaWVudENvbm5lY3RvcigpLnNlbmQobmV3IERlbGV0ZWRBbGxQcmVzZW50YXRpb25Nb2RlbHNPZlR5cGVOb3RpZmljYXRpb25fMVtcImRlZmF1bHRcIl0ocHJlc2VudGF0aW9uTW9kZWxUeXBlKSwgdW5kZWZpbmVkKTtcbiAgICB9O1xuICAgIENsaWVudE1vZGVsU3RvcmUucHJvdG90eXBlLmRlbGV0ZVByZXNlbnRhdGlvbk1vZGVsID0gZnVuY3Rpb24gKG1vZGVsLCBub3RpZnkpIHtcbiAgICAgICAgaWYgKCFtb2RlbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbnRhaW5zUHJlc2VudGF0aW9uTW9kZWwobW9kZWwuaWQpKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZShtb2RlbCk7XG4gICAgICAgICAgICBpZiAoIW5vdGlmeSB8fCBtb2RlbC5jbGllbnRTaWRlT25seSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2xpZW50RG9scGhpbi5nZXRDbGllbnRDb25uZWN0b3IoKS5zZW5kKG5ldyBEZWxldGVkUHJlc2VudGF0aW9uTW9kZWxOb3RpZmljYXRpb25fMVtcImRlZmF1bHRcIl0obW9kZWwuaWQpLCBudWxsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2xpZW50TW9kZWxTdG9yZS5wcm90b3R5cGUuY29udGFpbnNQcmVzZW50YXRpb25Nb2RlbCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmVzZW50YXRpb25Nb2RlbHMuaGFzKGlkKTtcbiAgICB9O1xuICAgIENsaWVudE1vZGVsU3RvcmUucHJvdG90eXBlLmFkZEF0dHJpYnV0ZUJ5SWQgPSBmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICAgIGlmICghYXR0cmlidXRlIHx8IHRoaXMuYXR0cmlidXRlc1BlcklkLmhhcyhhdHRyaWJ1dGUuaWQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzUGVySWQuc2V0KGF0dHJpYnV0ZS5pZCwgYXR0cmlidXRlKTtcbiAgICB9O1xuICAgIENsaWVudE1vZGVsU3RvcmUucHJvdG90eXBlLnJlbW92ZUF0dHJpYnV0ZUJ5SWQgPSBmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICAgIGlmICghYXR0cmlidXRlIHx8ICF0aGlzLmF0dHJpYnV0ZXNQZXJJZC5oYXMoYXR0cmlidXRlLmlkKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXR0cmlidXRlc1BlcklkLmRlbGV0ZShhdHRyaWJ1dGUuaWQpO1xuICAgIH07XG4gICAgQ2xpZW50TW9kZWxTdG9yZS5wcm90b3R5cGUuZmluZEF0dHJpYnV0ZUJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlc1BlcklkLmdldChpZCk7XG4gICAgfTtcbiAgICBDbGllbnRNb2RlbFN0b3JlLnByb3RvdHlwZS5hZGRBdHRyaWJ1dGVCeVF1YWxpZmllciA9IGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcbiAgICAgICAgaWYgKCFhdHRyaWJ1dGUgfHwgIWF0dHJpYnV0ZS5nZXRRdWFsaWZpZXIoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzUGVyUXVhbGlmaWVyLmdldChhdHRyaWJ1dGUuZ2V0UXVhbGlmaWVyKCkpO1xuICAgICAgICBpZiAoIWF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlc1BlclF1YWxpZmllci5zZXQoYXR0cmlidXRlLmdldFF1YWxpZmllcigpLCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShhdHRyaWJ1dGVzLmluZGV4T2YoYXR0cmlidXRlKSA+IC0xKSkge1xuICAgICAgICAgICAgYXR0cmlidXRlcy5wdXNoKGF0dHJpYnV0ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENsaWVudE1vZGVsU3RvcmUucHJvdG90eXBlLnJlbW92ZUF0dHJpYnV0ZUJ5UXVhbGlmaWVyID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuICAgICAgICBpZiAoIWF0dHJpYnV0ZSB8fCAhYXR0cmlidXRlLmdldFF1YWxpZmllcigpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXNQZXJRdWFsaWZpZXIuZ2V0KGF0dHJpYnV0ZS5nZXRRdWFsaWZpZXIoKSk7XG4gICAgICAgIGlmICghYXR0cmlidXRlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRyaWJ1dGVzLmxlbmd0aCA+IC0xKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzLnNwbGljZShhdHRyaWJ1dGVzLmluZGV4T2YoYXR0cmlidXRlKSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXNQZXJRdWFsaWZpZXIuZGVsZXRlKGF0dHJpYnV0ZS5nZXRRdWFsaWZpZXIoKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENsaWVudE1vZGVsU3RvcmUucHJvdG90eXBlLmZpbmRBbGxBdHRyaWJ1dGVzQnlRdWFsaWZpZXIgPSBmdW5jdGlvbiAocXVhbGlmaWVyKSB7XG4gICAgICAgIGlmICghcXVhbGlmaWVyIHx8ICF0aGlzLmF0dHJpYnV0ZXNQZXJRdWFsaWZpZXIuaGFzKHF1YWxpZmllcikpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzUGVyUXVhbGlmaWVyLmdldChxdWFsaWZpZXIpLnNsaWNlKDApOyAvLyBzbGljZSBpcyB1c2VkIHRvIGNsb25lIHRoZSBhcnJheVxuICAgIH07XG4gICAgQ2xpZW50TW9kZWxTdG9yZS5wcm90b3R5cGUub25Nb2RlbFN0b3JlQ2hhbmdlID0gZnVuY3Rpb24gKGV2ZW50SGFuZGxlcikge1xuICAgICAgICB0aGlzLm1vZGVsU3RvcmVDaGFuZ2VCdXMub25FdmVudChldmVudEhhbmRsZXIpO1xuICAgIH07XG4gICAgQ2xpZW50TW9kZWxTdG9yZS5wcm90b3R5cGUub25Nb2RlbFN0b3JlQ2hhbmdlRm9yVHlwZSA9IGZ1bmN0aW9uIChwcmVzZW50YXRpb25Nb2RlbFR5cGUsIGV2ZW50SGFuZGxlcikge1xuICAgICAgICB0aGlzLm1vZGVsU3RvcmVDaGFuZ2VCdXMub25FdmVudChmdW5jdGlvbiAocG1TdG9yZUV2ZW50KSB7XG4gICAgICAgICAgICBpZiAocG1TdG9yZUV2ZW50LmNsaWVudFByZXNlbnRhdGlvbk1vZGVsLnByZXNlbnRhdGlvbk1vZGVsVHlwZSA9PSBwcmVzZW50YXRpb25Nb2RlbFR5cGUpIHtcbiAgICAgICAgICAgICAgICBldmVudEhhbmRsZXIocG1TdG9yZUV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2xpZW50TW9kZWxTdG9yZTtcbn0oKSk7XG5leHBvcnRzLkNsaWVudE1vZGVsU3RvcmUgPSBDbGllbnRNb2RlbFN0b3JlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1DbGllbnRNb2RlbFN0b3JlLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgRXZlbnRCdXNfMSA9IHJlcXVpcmUoJy4vRXZlbnRCdXMnKTtcbnZhciBwcmVzZW50YXRpb25Nb2RlbEluc3RhbmNlQ291bnQgPSAwOyAvLyB0b2RvIGRrOiBjb25zaWRlciBtYWtpbmcgdGhpcyBzdGF0aWMgaW4gY2xhc3NcbnZhciBDbGllbnRQcmVzZW50YXRpb25Nb2RlbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2xpZW50UHJlc2VudGF0aW9uTW9kZWwoaWQsIHByZXNlbnRhdGlvbk1vZGVsVHlwZSkge1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMucHJlc2VudGF0aW9uTW9kZWxUeXBlID0gcHJlc2VudGF0aW9uTW9kZWxUeXBlO1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5jbGllbnRTaWRlT25seSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIGlmICh0eXBlb2YgaWQgIT09ICd1bmRlZmluZWQnICYmIGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaWQgPSAocHJlc2VudGF0aW9uTW9kZWxJbnN0YW5jZUNvdW50KyspLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnZhbGlkQnVzID0gbmV3IEV2ZW50QnVzXzFbXCJkZWZhdWx0XCJdKCk7XG4gICAgICAgIHRoaXMuZGlydHlWYWx1ZUNoYW5nZUJ1cyA9IG5ldyBFdmVudEJ1c18xW1wiZGVmYXVsdFwiXSgpO1xuICAgIH1cbiAgICAvLyB0b2RvIGRrOiBhbGlnbiB3aXRoIEphdmEgdmVyc2lvbjogbW92ZSB0byBDbGllbnREb2xwaGluIGFuZCBhdXRvLWFkZCB0byBtb2RlbCBzdG9yZVxuICAgIC8qKiBhIGNvcHkgY29uc3RydWN0b3IgZm9yIGFueXRoaW5nIGJ1dCBJRHMuIFBlciBkZWZhdWx0LCBjb3BpZXMgYXJlIGNsaWVudCBzaWRlIG9ubHksIG5vIGF1dG9tYXRpYyB1cGRhdGUgYXBwbGllcy4gKi9cbiAgICBDbGllbnRQcmVzZW50YXRpb25Nb2RlbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBDbGllbnRQcmVzZW50YXRpb25Nb2RlbChudWxsLCB0aGlzLnByZXNlbnRhdGlvbk1vZGVsVHlwZSk7XG4gICAgICAgIHJlc3VsdC5jbGllbnRTaWRlT25seSA9IHRydWU7XG4gICAgICAgIHRoaXMuZ2V0QXR0cmlidXRlcygpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZUNvcHkgPSBhdHRyaWJ1dGUuY29weSgpO1xuICAgICAgICAgICAgcmVzdWx0LmFkZEF0dHJpYnV0ZShhdHRyaWJ1dGVDb3B5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvL2FkZCBhcnJheSBvZiBhdHRyaWJ1dGVzXG4gICAgQ2xpZW50UHJlc2VudGF0aW9uTW9kZWwucHJvdG90eXBlLmFkZEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoYXR0cmlidXRlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIWF0dHJpYnV0ZXMgfHwgYXR0cmlidXRlcy5sZW5ndGggPCAxKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBhdHRyaWJ1dGVzLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICAgIF90aGlzLmFkZEF0dHJpYnV0ZShhdHRyKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDbGllbnRQcmVzZW50YXRpb25Nb2RlbC5wcm90b3R5cGUuYWRkQXR0cmlidXRlID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIWF0dHJpYnV0ZSB8fCAodGhpcy5hdHRyaWJ1dGVzLmluZGV4T2YoYXR0cmlidXRlKSA+IC0xKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZpbmRBdHRyaWJ1dGVCeVByb3BlcnR5TmFtZShhdHRyaWJ1dGUucHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlcmUgYWxyZWFkeSBpcyBhbiBhdHRyaWJ1dGUgd2l0aCBwcm9wZXJ0eSBuYW1lOiBcIiArIGF0dHJpYnV0ZS5wcm9wZXJ0eU5hbWVcbiAgICAgICAgICAgICAgICArIFwiIGluIHByZXNlbnRhdGlvbiBtb2RlbCB3aXRoIGlkOiBcIiArIHRoaXMuaWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRyaWJ1dGUuZ2V0UXVhbGlmaWVyKCkgJiYgdGhpcy5maW5kQXR0cmlidXRlQnlRdWFsaWZpZXIoYXR0cmlidXRlLmdldFF1YWxpZmllcigpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlcmUgYWxyZWFkeSBpcyBhbiBhdHRyaWJ1dGUgd2l0aCBxdWFsaWZpZXI6IFwiICsgYXR0cmlidXRlLmdldFF1YWxpZmllcigpXG4gICAgICAgICAgICAgICAgKyBcIiBpbiBwcmVzZW50YXRpb24gbW9kZWwgd2l0aCBpZDogXCIgKyB0aGlzLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBhdHRyaWJ1dGUuc2V0UHJlc2VudGF0aW9uTW9kZWwodGhpcyk7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcy5wdXNoKGF0dHJpYnV0ZSk7XG4gICAgICAgIGF0dHJpYnV0ZS5vblZhbHVlQ2hhbmdlKGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgICAgIF90aGlzLmludmFsaWRCdXMudHJpZ2dlcih7IHNvdXJjZTogX3RoaXMgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ2xpZW50UHJlc2VudGF0aW9uTW9kZWwucHJvdG90eXBlLm9uSW52YWxpZGF0ZWQgPSBmdW5jdGlvbiAoaGFuZGxlSW52YWxpZGF0ZSkge1xuICAgICAgICB0aGlzLmludmFsaWRCdXMub25FdmVudChoYW5kbGVJbnZhbGlkYXRlKTtcbiAgICB9O1xuICAgIC8qKiByZXR1cm5zIGEgY29weSBvZiB0aGUgaW50ZXJuYWwgc3RhdGUgKi9cbiAgICBDbGllbnRQcmVzZW50YXRpb25Nb2RlbC5wcm90b3R5cGUuZ2V0QXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlcy5zbGljZSgwKTtcbiAgICB9O1xuICAgIENsaWVudFByZXNlbnRhdGlvbk1vZGVsLnByb3RvdHlwZS5nZXRBdCA9IGZ1bmN0aW9uIChwcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZEF0dHJpYnV0ZUJ5UHJvcGVydHlOYW1lKHByb3BlcnR5TmFtZSk7XG4gICAgfTtcbiAgICBDbGllbnRQcmVzZW50YXRpb25Nb2RlbC5wcm90b3R5cGUuZmluZEFsbEF0dHJpYnV0ZXNCeVByb3BlcnR5TmFtZSA9IGZ1bmN0aW9uIChwcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAoIXByb3BlcnR5TmFtZSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlLnByb3BlcnR5TmFtZSA9PSBwcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhdHRyaWJ1dGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIENsaWVudFByZXNlbnRhdGlvbk1vZGVsLnByb3RvdHlwZS5maW5kQXR0cmlidXRlQnlQcm9wZXJ0eU5hbWUgPSBmdW5jdGlvbiAocHJvcGVydHlOYW1lKSB7XG4gICAgICAgIGlmICghcHJvcGVydHlOYW1lKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoKHRoaXMuYXR0cmlidXRlc1tpXS5wcm9wZXJ0eU5hbWUgPT0gcHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBDbGllbnRQcmVzZW50YXRpb25Nb2RlbC5wcm90b3R5cGUuZmluZEF0dHJpYnV0ZUJ5UXVhbGlmaWVyID0gZnVuY3Rpb24gKHF1YWxpZmllcikge1xuICAgICAgICBpZiAoIXF1YWxpZmllcilcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXR0cmlidXRlc1tpXS5nZXRRdWFsaWZpZXIoKSA9PSBxdWFsaWZpZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBDbGllbnRQcmVzZW50YXRpb25Nb2RlbC5wcm90b3R5cGUuZmluZEF0dHJpYnV0ZUJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgaWYgKCFpZClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXR0cmlidXRlc1tpXS5pZCA9PSBpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIENsaWVudFByZXNlbnRhdGlvbk1vZGVsLnByb3RvdHlwZS5zeW5jV2l0aCA9IGZ1bmN0aW9uIChzb3VyY2VQcmVzZW50YXRpb25Nb2RlbCkge1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0QXR0cmlidXRlKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlQXR0cmlidXRlID0gc291cmNlUHJlc2VudGF0aW9uTW9kZWwuZ2V0QXQodGFyZ2V0QXR0cmlidXRlLnByb3BlcnR5TmFtZSk7XG4gICAgICAgICAgICBpZiAoc291cmNlQXR0cmlidXRlKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0QXR0cmlidXRlLnN5bmNXaXRoKHNvdXJjZUF0dHJpYnV0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIENsaWVudFByZXNlbnRhdGlvbk1vZGVsO1xufSgpKTtcbmV4cG9ydHMuQ2xpZW50UHJlc2VudGF0aW9uTW9kZWwgPSBDbGllbnRQcmVzZW50YXRpb25Nb2RlbDtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2xpZW50UHJlc2VudGF0aW9uTW9kZWwuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBDb2RlYyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29kZWMoKSB7XG4gICAgfVxuICAgIENvZGVjLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAoY29tbWFuZHMpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGNvbW1hbmRzKTsgLy8gdG9kbyBkazogbG9vayBmb3IgcG9zc2libGUgQVBJIHN1cHBvcnQgZm9yIGNoYXJhY3RlciBlbmNvZGluZ1xuICAgIH07XG4gICAgQ29kZWMucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uICh0cmFuc21pdHRlZCkge1xuICAgICAgICBpZiAodHlwZW9mIHRyYW5zbWl0dGVkID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh0cmFuc21pdHRlZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNtaXR0ZWQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDb2RlYztcbn0oKSk7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBDb2RlYztcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29kZWMuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBDb21tYW5kID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb21tYW5kKCkge1xuICAgICAgICB0aGlzLmlkID0gXCJkb2xwaGluLWNvcmUtY29tbWFuZFwiO1xuICAgIH1cbiAgICByZXR1cm4gQ29tbWFuZDtcbn0oKSk7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBDb21tYW5kO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db21tYW5kLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgVmFsdWVDaGFuZ2VkQ29tbWFuZF8xID0gcmVxdWlyZSgnLi9WYWx1ZUNoYW5nZWRDb21tYW5kJyk7XG4vKiogQSBCYXRjaGVyIHRoYXQgZG9lcyBubyBiYXRjaGluZyBidXQgbWVyZWx5IHRha2VzIHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBxdWV1ZSBhcyB0aGUgc2luZ2xlIGl0ZW0gaW4gdGhlIGJhdGNoICovXG52YXIgTm9Db21tYW5kQmF0Y2hlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTm9Db21tYW5kQmF0Y2hlcigpIHtcbiAgICB9XG4gICAgTm9Db21tYW5kQmF0Y2hlci5wcm90b3R5cGUuYmF0Y2ggPSBmdW5jdGlvbiAocXVldWUpIHtcbiAgICAgICAgcmV0dXJuIFtxdWV1ZS5zaGlmdCgpXTtcbiAgICB9O1xuICAgIHJldHVybiBOb0NvbW1hbmRCYXRjaGVyO1xufSgpKTtcbmV4cG9ydHMuTm9Db21tYW5kQmF0Y2hlciA9IE5vQ29tbWFuZEJhdGNoZXI7XG4vKiogQSBiYXRjaGVyIHRoYXQgYmF0Y2hlcyB0aGUgYmxpbmRzIChjb21tYW5kcyB3aXRoIG5vIGNhbGxiYWNrKSBhbmQgb3B0aW9uYWxseSBhbHNvIGZvbGRzIHZhbHVlIGNoYW5nZXMgKi9cbnZhciBCbGluZENvbW1hbmRCYXRjaGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogZm9sZGluZzogd2hldGhlciB3ZSBzaG91bGQgdHJ5IGZvbGRpbmcgVmFsdWVDaGFuZ2VkQ29tbWFuZHMgKi9cbiAgICBmdW5jdGlvbiBCbGluZENvbW1hbmRCYXRjaGVyKGZvbGRpbmcsIG1heEJhdGNoU2l6ZSkge1xuICAgICAgICBpZiAoZm9sZGluZyA9PT0gdm9pZCAwKSB7IGZvbGRpbmcgPSB0cnVlOyB9XG4gICAgICAgIGlmIChtYXhCYXRjaFNpemUgPT09IHZvaWQgMCkgeyBtYXhCYXRjaFNpemUgPSA1MDsgfVxuICAgICAgICB0aGlzLmZvbGRpbmcgPSBmb2xkaW5nO1xuICAgICAgICB0aGlzLm1heEJhdGNoU2l6ZSA9IG1heEJhdGNoU2l6ZTtcbiAgICB9XG4gICAgQmxpbmRDb21tYW5kQmF0Y2hlci5wcm90b3R5cGUuYmF0Y2ggPSBmdW5jdGlvbiAocXVldWUpIHtcbiAgICAgICAgdmFyIGJhdGNoID0gW107XG4gICAgICAgIHZhciBuID0gTWF0aC5taW4ocXVldWUubGVuZ3RoLCB0aGlzLm1heEJhdGNoU2l6ZSk7XG4gICAgICAgIGZvciAodmFyIGNvdW50ZXIgPSAwOyBjb3VudGVyIDwgbjsgY291bnRlcisrKSB7XG4gICAgICAgICAgICB2YXIgY2FuZGlkYXRlID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmZvbGRpbmcgJiYgY2FuZGlkYXRlLmNvbW1hbmQgaW5zdGFuY2VvZiBWYWx1ZUNoYW5nZWRDb21tYW5kXzFbXCJkZWZhdWx0XCJdICYmICghY2FuZGlkYXRlLmhhbmRsZXIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZvdW5kID0gbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgY2FuQ21kID0gY2FuZGlkYXRlLmNvbW1hbmQ7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYXRjaC5sZW5ndGggJiYgZm91bmQgPT0gbnVsbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiYXRjaFtpXS5jb21tYW5kIGluc3RhbmNlb2YgVmFsdWVDaGFuZ2VkQ29tbWFuZF8xW1wiZGVmYXVsdFwiXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJhdGNoQ21kID0gYmF0Y2hbaV0uY29tbWFuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYW5DbWQuYXR0cmlidXRlSWQgPT0gYmF0Y2hDbWQuYXR0cmlidXRlSWQgJiYgYmF0Y2hDbWQubmV3VmFsdWUgPT0gY2FuQ21kLm9sZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBiYXRjaENtZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQubmV3VmFsdWUgPSBjYW5DbWQubmV3VmFsdWU7IC8vIGNoYW5nZSBleGlzdGluZyB2YWx1ZSwgZG8gbm90IGJhdGNoXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBiYXRjaC5wdXNoKGNhbmRpZGF0ZSk7IC8vIHdlIGNhbm5vdCBtZXJnZSwgc28gYmF0Y2ggdGhlIGNhbmRpZGF0ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJhdGNoLnB1c2goY2FuZGlkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYW5kaWRhdGUuaGFuZGxlciB8fFxuICAgICAgICAgICAgICAgIChjYW5kaWRhdGUuY29tbWFuZFsnY2xhc3NOYW1lJ10gPT0gXCJvcmcub3BlbmRvbHBoaW4uY29yZS5jb21tLk5hbWVkQ29tbWFuZFwiKSB8fFxuICAgICAgICAgICAgICAgIChjYW5kaWRhdGUuY29tbWFuZFsnY2xhc3NOYW1lJ10gPT0gXCJvcmcub3BlbmRvbHBoaW4uY29yZS5jb21tLkVtcHR5Tm90aWZpY2F0aW9uXCIpIC8vIG9yIHVua25vd24gY2xpZW50IHNpZGUgZWZmZWN0XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gbGVhdmUgdGhlIGxvb3BcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmF0Y2g7XG4gICAgfTtcbiAgICByZXR1cm4gQmxpbmRDb21tYW5kQmF0Y2hlcjtcbn0oKSk7XG5leHBvcnRzLkJsaW5kQ29tbWFuZEJhdGNoZXIgPSBCbGluZENvbW1hbmRCYXRjaGVyO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db21tYW5kQmF0Y2hlci5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgQ29tbWFuZF8xID0gcmVxdWlyZSgnLi9Db21tYW5kJyk7XG52YXIgQ3JlYXRlUHJlc2VudGF0aW9uTW9kZWxDb21tYW5kID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ3JlYXRlUHJlc2VudGF0aW9uTW9kZWxDb21tYW5kLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENyZWF0ZVByZXNlbnRhdGlvbk1vZGVsQ29tbWFuZChwcmVzZW50YXRpb25Nb2RlbCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0gW107XG4gICAgICAgIHRoaXMuY2xpZW50U2lkZU9ubHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pZCA9IFwiQ3JlYXRlUHJlc2VudGF0aW9uTW9kZWxcIjtcbiAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBcIm9yZy5vcGVuZG9scGhpbi5jb3JlLmNvbW0uQ3JlYXRlUHJlc2VudGF0aW9uTW9kZWxDb21tYW5kXCI7XG4gICAgICAgIHRoaXMucG1JZCA9IHByZXNlbnRhdGlvbk1vZGVsLmlkO1xuICAgICAgICB0aGlzLnBtVHlwZSA9IHByZXNlbnRhdGlvbk1vZGVsLnByZXNlbnRhdGlvbk1vZGVsVHlwZTtcbiAgICAgICAgdmFyIGF0dHJzID0gdGhpcy5hdHRyaWJ1dGVzO1xuICAgICAgICBwcmVzZW50YXRpb25Nb2RlbC5nZXRBdHRyaWJ1dGVzKCkuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgICAgYXR0cnMucHVzaCh7XG4gICAgICAgICAgICAgICAgcHJvcGVydHlOYW1lOiBhdHRyLnByb3BlcnR5TmFtZSxcbiAgICAgICAgICAgICAgICBpZDogYXR0ci5pZCxcbiAgICAgICAgICAgICAgICBxdWFsaWZpZXI6IGF0dHIuZ2V0UXVhbGlmaWVyKCksXG4gICAgICAgICAgICAgICAgdmFsdWU6IGF0dHIuZ2V0VmFsdWUoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gQ3JlYXRlUHJlc2VudGF0aW9uTW9kZWxDb21tYW5kO1xufShDb21tYW5kXzFbXCJkZWZhdWx0XCJdKSk7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBDcmVhdGVQcmVzZW50YXRpb25Nb2RlbENvbW1hbmQ7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNyZWF0ZVByZXNlbnRhdGlvbk1vZGVsQ29tbWFuZC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgQ29tbWFuZF8xID0gcmVxdWlyZSgnLi9Db21tYW5kJyk7XG52YXIgRGVsZXRlZEFsbFByZXNlbnRhdGlvbk1vZGVsc09mVHlwZU5vdGlmaWNhdGlvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERlbGV0ZWRBbGxQcmVzZW50YXRpb25Nb2RlbHNPZlR5cGVOb3RpZmljYXRpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGVsZXRlZEFsbFByZXNlbnRhdGlvbk1vZGVsc09mVHlwZU5vdGlmaWNhdGlvbihwbVR5cGUpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMucG1UeXBlID0gcG1UeXBlO1xuICAgICAgICB0aGlzLmlkID0gJ0RlbGV0ZWRBbGxQcmVzZW50YXRpb25Nb2RlbHNPZlR5cGUnO1xuICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IFwib3JnLm9wZW5kb2xwaGluLmNvcmUuY29tbS5EZWxldGVkQWxsUHJlc2VudGF0aW9uTW9kZWxzT2ZUeXBlTm90aWZpY2F0aW9uXCI7XG4gICAgfVxuICAgIHJldHVybiBEZWxldGVkQWxsUHJlc2VudGF0aW9uTW9kZWxzT2ZUeXBlTm90aWZpY2F0aW9uO1xufShDb21tYW5kXzFbXCJkZWZhdWx0XCJdKSk7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBEZWxldGVkQWxsUHJlc2VudGF0aW9uTW9kZWxzT2ZUeXBlTm90aWZpY2F0aW9uO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1EZWxldGVkQWxsUHJlc2VudGF0aW9uTW9kZWxzT2ZUeXBlTm90aWZpY2F0aW9uLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBDb21tYW5kXzEgPSByZXF1aXJlKCcuL0NvbW1hbmQnKTtcbnZhciBEZWxldGVkUHJlc2VudGF0aW9uTW9kZWxOb3RpZmljYXRpb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEZWxldGVkUHJlc2VudGF0aW9uTW9kZWxOb3RpZmljYXRpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGVsZXRlZFByZXNlbnRhdGlvbk1vZGVsTm90aWZpY2F0aW9uKHBtSWQpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMucG1JZCA9IHBtSWQ7XG4gICAgICAgIHRoaXMuaWQgPSAnRGVsZXRlZFByZXNlbnRhdGlvbk1vZGVsJztcbiAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBcIm9yZy5vcGVuZG9scGhpbi5jb3JlLmNvbW0uRGVsZXRlZFByZXNlbnRhdGlvbk1vZGVsTm90aWZpY2F0aW9uXCI7XG4gICAgfVxuICAgIHJldHVybiBEZWxldGVkUHJlc2VudGF0aW9uTW9kZWxOb3RpZmljYXRpb247XG59KENvbW1hbmRfMVtcImRlZmF1bHRcIl0pKTtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IERlbGV0ZWRQcmVzZW50YXRpb25Nb2RlbE5vdGlmaWNhdGlvbjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGVsZXRlZFByZXNlbnRhdGlvbk1vZGVsTm90aWZpY2F0aW9uLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgQ2xpZW50Q29ubmVjdG9yXzEgPSByZXF1aXJlKFwiLi9DbGllbnRDb25uZWN0b3JcIik7XG52YXIgQ2xpZW50RG9scGhpbl8xID0gcmVxdWlyZShcIi4vQ2xpZW50RG9scGhpblwiKTtcbnZhciBDbGllbnRNb2RlbFN0b3JlXzEgPSByZXF1aXJlKFwiLi9DbGllbnRNb2RlbFN0b3JlXCIpO1xudmFyIEh0dHBUcmFuc21pdHRlcl8xID0gcmVxdWlyZShcIi4vSHR0cFRyYW5zbWl0dGVyXCIpO1xudmFyIE5vVHJhbnNtaXR0ZXJfMSA9IHJlcXVpcmUoXCIuL05vVHJhbnNtaXR0ZXJcIik7XG52YXIgRG9scGhpbkJ1aWxkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERvbHBoaW5CdWlsZGVyKCkge1xuICAgICAgICB0aGlzLnJlc2V0XyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNsYWNrTVNfID0gMzAwO1xuICAgICAgICB0aGlzLm1heEJhdGNoU2l6ZV8gPSA1MDtcbiAgICAgICAgdGhpcy5zdXBwb3J0Q09SU18gPSBmYWxzZTtcbiAgICB9XG4gICAgRG9scGhpbkJ1aWxkZXIucHJvdG90eXBlLnVybCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgdGhpcy51cmxfID0gdXJsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIERvbHBoaW5CdWlsZGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIChyZXNldCkge1xuICAgICAgICB0aGlzLnJlc2V0XyA9IHJlc2V0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIERvbHBoaW5CdWlsZGVyLnByb3RvdHlwZS5zbGFja01TID0gZnVuY3Rpb24gKHNsYWNrTVMpIHtcbiAgICAgICAgdGhpcy5zbGFja01TXyA9IHNsYWNrTVM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgRG9scGhpbkJ1aWxkZXIucHJvdG90eXBlLm1heEJhdGNoU2l6ZSA9IGZ1bmN0aW9uIChtYXhCYXRjaFNpemUpIHtcbiAgICAgICAgdGhpcy5tYXhCYXRjaFNpemVfID0gbWF4QmF0Y2hTaXplO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIERvbHBoaW5CdWlsZGVyLnByb3RvdHlwZS5zdXBwb3J0Q09SUyA9IGZ1bmN0aW9uIChzdXBwb3J0Q09SUykge1xuICAgICAgICB0aGlzLnN1cHBvcnRDT1JTXyA9IHN1cHBvcnRDT1JTO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIERvbHBoaW5CdWlsZGVyLnByb3RvdHlwZS5lcnJvckhhbmRsZXIgPSBmdW5jdGlvbiAoZXJyb3JIYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuZXJyb3JIYW5kbGVyXyA9IGVycm9ySGFuZGxlcjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBEb2xwaGluQnVpbGRlci5wcm90b3R5cGUuaGVhZGVyc0luZm8gPSBmdW5jdGlvbiAoaGVhZGVyc0luZm8pIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzSW5mb18gPSBoZWFkZXJzSW5mbztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBEb2xwaGluQnVpbGRlci5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiT3BlbkRvbHBoaW4ganMgZm91bmRcIik7XG4gICAgICAgIHZhciBjbGllbnREb2xwaGluID0gbmV3IENsaWVudERvbHBoaW5fMVtcImRlZmF1bHRcIl0oKTtcbiAgICAgICAgdmFyIHRyYW5zbWl0dGVyO1xuICAgICAgICBpZiAodGhpcy51cmxfICE9IG51bGwgJiYgdGhpcy51cmxfLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRyYW5zbWl0dGVyID0gbmV3IEh0dHBUcmFuc21pdHRlcl8xW1wiZGVmYXVsdFwiXSh0aGlzLnVybF8sIHRoaXMucmVzZXRfLCBcIlVURi04XCIsIHRoaXMuZXJyb3JIYW5kbGVyXywgdGhpcy5zdXBwb3J0Q09SU18sIHRoaXMuaGVhZGVyc0luZm9fKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyYW5zbWl0dGVyID0gbmV3IE5vVHJhbnNtaXR0ZXJfMVtcImRlZmF1bHRcIl0oKTtcbiAgICAgICAgfVxuICAgICAgICBjbGllbnREb2xwaGluLnNldENsaWVudENvbm5lY3RvcihuZXcgQ2xpZW50Q29ubmVjdG9yXzEuQ2xpZW50Q29ubmVjdG9yKHRyYW5zbWl0dGVyLCBjbGllbnREb2xwaGluLCB0aGlzLnNsYWNrTVNfLCB0aGlzLm1heEJhdGNoU2l6ZV8pKTtcbiAgICAgICAgY2xpZW50RG9scGhpbi5zZXRDbGllbnRNb2RlbFN0b3JlKG5ldyBDbGllbnRNb2RlbFN0b3JlXzEuQ2xpZW50TW9kZWxTdG9yZShjbGllbnREb2xwaGluKSk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiQ2xpZW50RG9scGhpbiBpbml0aWFsaXplZFwiKTtcbiAgICAgICAgcmV0dXJuIGNsaWVudERvbHBoaW47XG4gICAgfTtcbiAgICByZXR1cm4gRG9scGhpbkJ1aWxkZXI7XG59KCkpO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gRG9scGhpbkJ1aWxkZXI7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURvbHBoaW5CdWlsZGVyLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBDb21tYW5kXzEgPSByZXF1aXJlKCcuL0NvbW1hbmQnKTtcbnZhciBFbXB0eU5vdGlmaWNhdGlvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEVtcHR5Tm90aWZpY2F0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEVtcHR5Tm90aWZpY2F0aW9uKCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5pZCA9IFwiRW1wdHlcIjtcbiAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBcIm9yZy5vcGVuZG9scGhpbi5jb3JlLmNvbW0uRW1wdHlOb3RpZmljYXRpb25cIjtcbiAgICB9XG4gICAgcmV0dXJuIEVtcHR5Tm90aWZpY2F0aW9uO1xufShDb21tYW5kXzFbXCJkZWZhdWx0XCJdKSk7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBFbXB0eU5vdGlmaWNhdGlvbjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RW1wdHlOb3RpZmljYXRpb24uanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBFdmVudEJ1cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXZlbnRCdXMoKSB7XG4gICAgICAgIHRoaXMuZXZlbnRIYW5kbGVycyA9IFtdO1xuICAgIH1cbiAgICBFdmVudEJ1cy5wcm90b3R5cGUub25FdmVudCA9IGZ1bmN0aW9uIChldmVudEhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzLnB1c2goZXZlbnRIYW5kbGVyKTtcbiAgICB9O1xuICAgIEV2ZW50QnVzLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZXZlbnRIYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGUpIHsgcmV0dXJuIGhhbmRsZShldmVudCk7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEV2ZW50QnVzO1xufSgpKTtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IEV2ZW50QnVzO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1FdmVudEJ1cy5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIENvZGVjXzEgPSByZXF1aXJlKFwiLi9Db2RlY1wiKTtcbnZhciBIdHRwVHJhbnNtaXR0ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEh0dHBUcmFuc21pdHRlcih1cmwsIHJlc2V0LCBjaGFyc2V0LCBlcnJvckhhbmRsZXIsIHN1cHBvcnRDT1JTLCBoZWFkZXJzSW5mbykge1xuICAgICAgICBpZiAocmVzZXQgPT09IHZvaWQgMCkgeyByZXNldCA9IHRydWU7IH1cbiAgICAgICAgaWYgKGNoYXJzZXQgPT09IHZvaWQgMCkgeyBjaGFyc2V0ID0gXCJVVEYtOFwiOyB9XG4gICAgICAgIGlmIChlcnJvckhhbmRsZXIgPT09IHZvaWQgMCkgeyBlcnJvckhhbmRsZXIgPSBudWxsOyB9XG4gICAgICAgIGlmIChzdXBwb3J0Q09SUyA9PT0gdm9pZCAwKSB7IHN1cHBvcnRDT1JTID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKGhlYWRlcnNJbmZvID09PSB2b2lkIDApIHsgaGVhZGVyc0luZm8gPSBudWxsOyB9XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICB0aGlzLmNoYXJzZXQgPSBjaGFyc2V0O1xuICAgICAgICB0aGlzLkh0dHBDb2RlcyA9IHtcbiAgICAgICAgICAgIGZpbmlzaGVkOiA0LFxuICAgICAgICAgICAgc3VjY2VzczogMjAwXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZXJyb3JIYW5kbGVyID0gZXJyb3JIYW5kbGVyO1xuICAgICAgICB0aGlzLnN1cHBvcnRDT1JTID0gc3VwcG9ydENPUlM7XG4gICAgICAgIHRoaXMuaGVhZGVyc0luZm8gPSBoZWFkZXJzSW5mbztcbiAgICAgICAgdGhpcy5odHRwID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHRoaXMuc2lnID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIGlmICh0aGlzLnN1cHBvcnRDT1JTKSB7XG4gICAgICAgICAgICBpZiAoXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiB0aGlzLmh0dHApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmh0dHAud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTsgLy8gTk9URTogZG9pbmcgdGhpcyBmb3Igbm9uIENPUlMgcmVxdWVzdHMgaGFzIG5vIGltcGFjdFxuICAgICAgICAgICAgICAgIHRoaXMuc2lnLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb2RlYyA9IG5ldyBDb2RlY18xW1wiZGVmYXVsdFwiXSgpO1xuICAgICAgICBpZiAocmVzZXQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdIdHRwVHJhbnNtaXR0ZXIuaW52YWxpZGF0ZSgpIGlzIGRlcHJlY2F0ZWQuIFVzZSBDbGllbnREb2xwaGluLnJlc2V0KE9uU3VjY2Vzc0hhbmRsZXIpIGluc3RlYWQnKTtcbiAgICAgICAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIEh0dHBUcmFuc21pdHRlci5wcm90b3R5cGUudHJhbnNtaXQgPSBmdW5jdGlvbiAoY29tbWFuZHMsIG9uRG9uZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmh0dHAub25lcnJvciA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgICAgIF90aGlzLmhhbmRsZUVycm9yKCdvbmVycm9yJywgXCJcIik7XG4gICAgICAgICAgICBvbkRvbmUoW10pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmh0dHAub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLmh0dHAucmVhZHlTdGF0ZSA9PSBfdGhpcy5IdHRwQ29kZXMuZmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuaHR0cC5zdGF0dXMgPT0gX3RoaXMuSHR0cENvZGVzLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlVGV4dCA9IF90aGlzLmh0dHAucmVzcG9uc2VUZXh0O1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VUZXh0LnRyaW0oKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNwb25zZUNvbW1hbmRzID0gX3RoaXMuY29kZWMuZGVjb2RlKHJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25Eb25lKHJlc3BvbnNlQ29tbWFuZHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRXJyb3Igb2NjdXJyZWQgcGFyc2luZyByZXNwb25zZVRleHQ6IFwiLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiSW5jb3JyZWN0IHJlc3BvbnNlVGV4dDogXCIsIHJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlRXJyb3IoJ2FwcGxpY2F0aW9uJywgXCJIdHRwVHJhbnNtaXR0ZXI6IEluY29ycmVjdCByZXNwb25zZVRleHQ6IFwiICsgcmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkRvbmUoW10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlRXJyb3IoJ2FwcGxpY2F0aW9uJywgXCJIdHRwVHJhbnNtaXR0ZXI6IGVtcHR5IHJlc3BvbnNlVGV4dFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRG9uZShbXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmhhbmRsZUVycm9yKCdhcHBsaWNhdGlvbicsIFwiSHR0cFRyYW5zbWl0dGVyOiBIVFRQIFN0YXR1cyAhPSAyMDBcIik7XG4gICAgICAgICAgICAgICAgICAgIG9uRG9uZShbXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmh0dHAub3BlbignUE9TVCcsIHRoaXMudXJsLCB0cnVlKTtcbiAgICAgICAgdGhpcy5zZXRIZWFkZXJzKHRoaXMuaHR0cCk7XG4gICAgICAgIGlmIChcIm92ZXJyaWRlTWltZVR5cGVcIiBpbiB0aGlzLmh0dHApIHtcbiAgICAgICAgICAgIHRoaXMuaHR0cC5vdmVycmlkZU1pbWVUeXBlKFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD1cIiArIHRoaXMuY2hhcnNldCk7IC8vIHRvZG8gbWFrZSBpbmplY3RhYmxlXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5odHRwLnNlbmQodGhpcy5jb2RlYy5lbmNvZGUoY29tbWFuZHMpKTtcbiAgICB9O1xuICAgIEh0dHBUcmFuc21pdHRlci5wcm90b3R5cGUuc2V0SGVhZGVycyA9IGZ1bmN0aW9uIChodHRwUmVxKSB7XG4gICAgICAgIGlmICh0aGlzLmhlYWRlcnNJbmZvKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuaGVhZGVyc0luZm8pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oZWFkZXJzSW5mby5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgICAgICAgICBodHRwUmVxLnNldFJlcXVlc3RIZWFkZXIoaSwgdGhpcy5oZWFkZXJzSW5mb1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBIdHRwVHJhbnNtaXR0ZXIucHJvdG90eXBlLmhhbmRsZUVycm9yID0gZnVuY3Rpb24gKGtpbmQsIG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIGVycm9yRXZlbnQgPSB7IGtpbmQ6IGtpbmQsIHVybDogdGhpcy51cmwsIGh0dHBTdGF0dXM6IHRoaXMuaHR0cC5zdGF0dXMsIG1lc3NhZ2U6IG1lc3NhZ2UgfTtcbiAgICAgICAgaWYgKHRoaXMuZXJyb3JIYW5kbGVyKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9ySGFuZGxlcihlcnJvckV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRXJyb3Igb2NjdXJyZWQ6IFwiLCBlcnJvckV2ZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSHR0cFRyYW5zbWl0dGVyLnByb3RvdHlwZS5zaWduYWwgPSBmdW5jdGlvbiAoY29tbWFuZCkge1xuICAgICAgICB0aGlzLnNpZy5vcGVuKCdQT1NUJywgdGhpcy51cmwsIHRydWUpO1xuICAgICAgICB0aGlzLnNldEhlYWRlcnModGhpcy5zaWcpO1xuICAgICAgICB0aGlzLnNpZy5zZW5kKHRoaXMuY29kZWMuZW5jb2RlKFtjb21tYW5kXSkpO1xuICAgIH07XG4gICAgLy8gRGVwcmVjYXRlZCAhIFVzZSAncmVzZXQoT25TdWNjZXNzSGFuZGxlcikgaW5zdGVhZFxuICAgIEh0dHBUcmFuc21pdHRlci5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5odHRwLm9wZW4oJ1BPU1QnLCB0aGlzLnVybCArICdpbnZhbGlkYXRlPycsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5odHRwLnNlbmQoKTtcbiAgICB9O1xuICAgIEh0dHBUcmFuc21pdHRlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoc3VjY2Vzc0hhbmRsZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5odHRwLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5odHRwLnJlYWR5U3RhdGUgPT0gX3RoaXMuSHR0cENvZGVzLmZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmh0dHAuc3RhdHVzID09IF90aGlzLkh0dHBDb2Rlcy5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NIYW5kbGVyLm9uU3VjY2VzcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlRXJyb3IoJ2FwcGxpY2F0aW9uJywgXCJIdHRwVHJhbnNtaXR0ZXIucmVzZXQoKTogSFRUUCBTdGF0dXMgIT0gMjAwXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5odHRwLm9wZW4oJ1BPU1QnLCB0aGlzLnVybCArICdpbnZhbGlkYXRlPycsIHRydWUpO1xuICAgICAgICB0aGlzLmh0dHAuc2VuZCgpO1xuICAgIH07XG4gICAgcmV0dXJuIEh0dHBUcmFuc21pdHRlcjtcbn0oKSk7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBIdHRwVHJhbnNtaXR0ZXI7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUh0dHBUcmFuc21pdHRlci5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgQ29tbWFuZF8xID0gcmVxdWlyZSgnLi9Db21tYW5kJyk7XG52YXIgTmFtZWRDb21tYW5kID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTmFtZWRDb21tYW5kLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE5hbWVkQ29tbWFuZChuYW1lKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmlkID0gbmFtZTtcbiAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBcIm9yZy5vcGVuZG9scGhpbi5jb3JlLmNvbW0uTmFtZWRDb21tYW5kXCI7XG4gICAgfVxuICAgIHJldHVybiBOYW1lZENvbW1hbmQ7XG59KENvbW1hbmRfMVtcImRlZmF1bHRcIl0pKTtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IE5hbWVkQ29tbWFuZDtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TmFtZWRDb21tYW5kLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEEgdHJhbnNtaXR0ZXIgdGhhdCBpcyBub3QgdHJhbnNtaXR0aW5nIGF0IGFsbC5cbiAqIEl0IG1heSBzZXJ2ZSBhcyBhIHN0YW5kLWluIHdoZW4gbm8gcmVhbCB0cmFuc21pdHRlciBpcyBuZWVkZWQuXG4gKi9cbnZhciBOb1RyYW5zbWl0dGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOb1RyYW5zbWl0dGVyKCkge1xuICAgIH1cbiAgICBOb1RyYW5zbWl0dGVyLnByb3RvdHlwZS50cmFuc21pdCA9IGZ1bmN0aW9uIChjb21tYW5kcywgb25Eb25lKSB7XG4gICAgICAgIC8vIGRvIG5vdGhpbmcgc3BlY2lhbFxuICAgICAgICBvbkRvbmUoW10pO1xuICAgIH07XG4gICAgTm9UcmFuc21pdHRlci5wcm90b3R5cGUuc2lnbmFsID0gZnVuY3Rpb24gKGNvbW1hbmQpIHtcbiAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgIH07XG4gICAgTm9UcmFuc21pdHRlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoc3VjY2Vzc0hhbmRsZXIpIHtcbiAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgIH07XG4gICAgcmV0dXJuIE5vVHJhbnNtaXR0ZXI7XG59KCkpO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gTm9UcmFuc21pdHRlcjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Tm9UcmFuc21pdHRlci5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIERvbHBoaW5CdWlsZGVyXzEgPSByZXF1aXJlKFwiLi9Eb2xwaGluQnVpbGRlclwiKTtcbi8qKlxuICogSlMtZnJpZW5kbHkgZmFjYWRlIHRvIGF2b2lkIHRvbyBtYW55IGRlcGVuZGVuY2llcyBpbiBwbGFpbiBKUyBjb2RlLlxuICogVGhlIG5hbWUgb2YgdGhpcyBmaWxlIGlzIGFsc28gdXNlZCBmb3IgdGhlIGluaXRpYWwgbG9va3VwIG9mIHRoZVxuICogb25lIGphdmFzY3JpcHQgZmlsZSB0aGF0IGNvbnRhaW5zIGFsbCB0aGUgZG9scGhpbiBjb2RlLlxuICogQ2hhbmdpbmcgdGhlIG5hbWUgcmVxdWlyZXMgdGhlIGJ1aWxkIHN1cHBvcnQgYW5kIGFsbCB1c2Vyc1xuICogdG8gYmUgdXBkYXRlZCBhcyB3ZWxsLlxuICogRGllcmsgS29lbmlnXG4gKi9cbi8vIGZhY3RvcnkgbWV0aG9kIGZvciB0aGUgaW5pdGlhbGl6ZWQgZG9scGhpblxuLy8gRGVwcmVjYXRlZCAhIFVzZSAnbWFrZURvbHBoaW4oKSBpbnN0ZWFkXG5mdW5jdGlvbiBkb2xwaGluKHVybCwgcmVzZXQsIHNsYWNrTVMpIHtcbiAgICBpZiAoc2xhY2tNUyA9PT0gdm9pZCAwKSB7IHNsYWNrTVMgPSAzMDA7IH1cbiAgICByZXR1cm4gbWFrZURvbHBoaW4oKS51cmwodXJsKS5yZXNldChyZXNldCkuc2xhY2tNUyhzbGFja01TKS5idWlsZCgpO1xufVxuZXhwb3J0cy5kb2xwaGluID0gZG9scGhpbjtcbi8vIGZhY3RvcnkgbWV0aG9kIHRvIGJ1aWxkIGFuIGluaXRpYWxpemVkIGRvbHBoaW5cbmZ1bmN0aW9uIG1ha2VEb2xwaGluKCkge1xuICAgIHJldHVybiBuZXcgRG9scGhpbkJ1aWxkZXJfMVtcImRlZmF1bHRcIl0oKTtcbn1cbmV4cG9ydHMubWFrZURvbHBoaW4gPSBtYWtlRG9scGhpbjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T3BlbkRvbHBoaW4uanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIENvbW1hbmRfMSA9IHJlcXVpcmUoJy4vQ29tbWFuZCcpO1xudmFyIFNpZ25hbENvbW1hbmQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTaWduYWxDb21tYW5kLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNpZ25hbENvbW1hbmQobmFtZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5pZCA9IG5hbWU7XG4gICAgICAgIHRoaXMuY2xhc3NOYW1lID0gXCJvcmcub3BlbmRvbHBoaW4uY29yZS5jb21tLlNpZ25hbENvbW1hbmRcIjtcbiAgICB9XG4gICAgcmV0dXJuIFNpZ25hbENvbW1hbmQ7XG59KENvbW1hbmRfMVtcImRlZmF1bHRcIl0pKTtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFNpZ25hbENvbW1hbmQ7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNpZ25hbENvbW1hbmQuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIENvbW1hbmRfMSA9IHJlcXVpcmUoJy4vQ29tbWFuZCcpO1xudmFyIFZhbHVlQ2hhbmdlZENvbW1hbmQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhWYWx1ZUNoYW5nZWRDb21tYW5kLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFZhbHVlQ2hhbmdlZENvbW1hbmQoYXR0cmlidXRlSWQsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVJZCA9IGF0dHJpYnV0ZUlkO1xuICAgICAgICB0aGlzLm9sZFZhbHVlID0gb2xkVmFsdWU7XG4gICAgICAgIHRoaXMubmV3VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgdGhpcy5pZCA9IFwiVmFsdWVDaGFuZ2VkXCI7XG4gICAgICAgIHRoaXMuY2xhc3NOYW1lID0gXCJvcmcub3BlbmRvbHBoaW4uY29yZS5jb21tLlZhbHVlQ2hhbmdlZENvbW1hbmRcIjtcbiAgICB9XG4gICAgcmV0dXJuIFZhbHVlQ2hhbmdlZENvbW1hbmQ7XG59KENvbW1hbmRfMVtcImRlZmF1bHRcIl0pKTtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFZhbHVlQ2hhbmdlZENvbW1hbmQ7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZhbHVlQ2hhbmdlZENvbW1hbmQuanMubWFwXG4iLCIvKiBDb3B5cmlnaHQgMjAxNSBDYW5vbyBFbmdpbmVlcmluZyBBRy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLypqc2xpbnQgYnJvd3NlcmlmeTogdHJ1ZSAqL1xuLyogZ2xvYmFsIGNvbnNvbGUgKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgTWFwID0gcmVxdWlyZSgnLi4vYm93ZXJfY29tcG9uZW50cy9jb3JlLmpzL2xpYnJhcnkvZm4vbWFwJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzLmpzJyk7XG52YXIgZXhpc3RzID0gdXRpbHMuZXhpc3RzO1xudmFyIGNoZWNrTWV0aG9kID0gdXRpbHMuY2hlY2tNZXRob2Q7XG52YXIgY2hlY2tQYXJhbSA9IHV0aWxzLmNoZWNrUGFyYW07XG5cblxuZnVuY3Rpb24gQmVhbk1hbmFnZXIoY2xhc3NSZXBvc2l0b3J5KSB7XG4gICAgY2hlY2tNZXRob2QoJ0JlYW5NYW5hZ2VyKGNsYXNzUmVwb3NpdG9yeSknKTtcbiAgICBjaGVja1BhcmFtKGNsYXNzUmVwb3NpdG9yeSwgJ2NsYXNzUmVwb3NpdG9yeScpO1xuXG4gICAgdGhpcy5jbGFzc1JlcG9zaXRvcnkgPSBjbGFzc1JlcG9zaXRvcnk7XG4gICAgdGhpcy5hZGRlZEhhbmRsZXJzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMucmVtb3ZlZEhhbmRsZXJzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMudXBkYXRlZEhhbmRsZXJzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuYXJyYXlVcGRhdGVkSGFuZGxlcnMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5hbGxBZGRlZEhhbmRsZXJzID0gW107XG4gICAgdGhpcy5hbGxSZW1vdmVkSGFuZGxlcnMgPSBbXTtcbiAgICB0aGlzLmFsbFVwZGF0ZWRIYW5kbGVycyA9IFtdO1xuICAgIHRoaXMuYWxsQXJyYXlVcGRhdGVkSGFuZGxlcnMgPSBbXTtcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLmNsYXNzUmVwb3NpdG9yeS5vbkJlYW5BZGRlZChmdW5jdGlvbih0eXBlLCBiZWFuKSB7XG4gICAgICAgIHZhciBoYW5kbGVyTGlzdCA9IHNlbGYuYWRkZWRIYW5kbGVycy5nZXQodHlwZSk7XG4gICAgICAgIGlmIChleGlzdHMoaGFuZGxlckxpc3QpKSB7XG4gICAgICAgICAgICBoYW5kbGVyTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcihiZWFuKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdBbiBleGNlcHRpb24gb2NjdXJyZWQgd2hpbGUgY2FsbGluZyBhbiBvbkJlYW5BZGRlZC1oYW5kbGVyIGZvciB0eXBlJywgdHlwZSwgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5hbGxBZGRlZEhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlcihiZWFuKTtcbiAgICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignQW4gZXhjZXB0aW9uIG9jY3VycmVkIHdoaWxlIGNhbGxpbmcgYSBnZW5lcmFsIG9uQmVhbkFkZGVkLWhhbmRsZXInLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5jbGFzc1JlcG9zaXRvcnkub25CZWFuUmVtb3ZlZChmdW5jdGlvbih0eXBlLCBiZWFuKSB7XG4gICAgICAgIHZhciBoYW5kbGVyTGlzdCA9IHNlbGYucmVtb3ZlZEhhbmRsZXJzLmdldCh0eXBlKTtcbiAgICAgICAgaWYgKGV4aXN0cyhoYW5kbGVyTGlzdCkpIHtcbiAgICAgICAgICAgIGhhbmRsZXJMaXN0LmZvckVhY2goZnVuY3Rpb24oaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIoYmVhbik7XG4gICAgICAgICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignQW4gZXhjZXB0aW9uIG9jY3VycmVkIHdoaWxlIGNhbGxpbmcgYW4gb25CZWFuUmVtb3ZlZC1oYW5kbGVyIGZvciB0eXBlJywgdHlwZSwgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5hbGxSZW1vdmVkSGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbihoYW5kbGVyKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIoYmVhbik7XG4gICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0FuIGV4Y2VwdGlvbiBvY2N1cnJlZCB3aGlsZSBjYWxsaW5nIGEgZ2VuZXJhbCBvbkJlYW5SZW1vdmVkLWhhbmRsZXInLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5jbGFzc1JlcG9zaXRvcnkub25CZWFuVXBkYXRlKGZ1bmN0aW9uKHR5cGUsIGJlYW4sIHByb3BlcnR5TmFtZSwgbmV3VmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHZhciBoYW5kbGVyTGlzdCA9IHNlbGYudXBkYXRlZEhhbmRsZXJzLmdldCh0eXBlKTtcbiAgICAgICAgaWYgKGV4aXN0cyhoYW5kbGVyTGlzdCkpIHtcbiAgICAgICAgICAgIGhhbmRsZXJMaXN0LmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyKGJlYW4sIHByb3BlcnR5TmFtZSwgbmV3VmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdBbiBleGNlcHRpb24gb2NjdXJyZWQgd2hpbGUgY2FsbGluZyBhbiBvbkJlYW5VcGRhdGUtaGFuZGxlciBmb3IgdHlwZScsIHR5cGUsIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuYWxsVXBkYXRlZEhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlcihiZWFuLCBwcm9wZXJ0eU5hbWUsIG5ld1ZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0FuIGV4Y2VwdGlvbiBvY2N1cnJlZCB3aGlsZSBjYWxsaW5nIGEgZ2VuZXJhbCBvbkJlYW5VcGRhdGUtaGFuZGxlcicsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLmNsYXNzUmVwb3NpdG9yeS5vbkFycmF5VXBkYXRlKGZ1bmN0aW9uKHR5cGUsIGJlYW4sIHByb3BlcnR5TmFtZSwgaW5kZXgsIGNvdW50LCBuZXdFbGVtZW50cykge1xuICAgICAgICB2YXIgaGFuZGxlckxpc3QgPSBzZWxmLmFycmF5VXBkYXRlZEhhbmRsZXJzLmdldCh0eXBlKTtcbiAgICAgICAgaWYgKGV4aXN0cyhoYW5kbGVyTGlzdCkpIHtcbiAgICAgICAgICAgIGhhbmRsZXJMaXN0LmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyKGJlYW4sIHByb3BlcnR5TmFtZSwgaW5kZXgsIGNvdW50LCBuZXdFbGVtZW50cyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignQW4gZXhjZXB0aW9uIG9jY3VycmVkIHdoaWxlIGNhbGxpbmcgYW4gb25BcnJheVVwZGF0ZS1oYW5kbGVyIGZvciB0eXBlJywgdHlwZSwgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5hbGxBcnJheVVwZGF0ZWRIYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIoYmVhbiwgcHJvcGVydHlOYW1lLCBpbmRleCwgY291bnQsIG5ld0VsZW1lbnRzKTtcbiAgICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignQW4gZXhjZXB0aW9uIG9jY3VycmVkIHdoaWxlIGNhbGxpbmcgYSBnZW5lcmFsIG9uQXJyYXlVcGRhdGUtaGFuZGxlcicsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcblxufVxuXG5cbkJlYW5NYW5hZ2VyLnByb3RvdHlwZS5ub3RpZnlCZWFuQ2hhbmdlID0gZnVuY3Rpb24oYmVhbiwgcHJvcGVydHlOYW1lLCBuZXdWYWx1ZSkge1xuICAgIGNoZWNrTWV0aG9kKCdCZWFuTWFuYWdlci5ub3RpZnlCZWFuQ2hhbmdlKGJlYW4sIHByb3BlcnR5TmFtZSwgbmV3VmFsdWUpJyk7XG4gICAgY2hlY2tQYXJhbShiZWFuLCAnYmVhbicpO1xuICAgIGNoZWNrUGFyYW0ocHJvcGVydHlOYW1lLCAncHJvcGVydHlOYW1lJyk7XG5cbiAgICByZXR1cm4gdGhpcy5jbGFzc1JlcG9zaXRvcnkubm90aWZ5QmVhbkNoYW5nZShiZWFuLCBwcm9wZXJ0eU5hbWUsIG5ld1ZhbHVlKTtcbn07XG5cblxuQmVhbk1hbmFnZXIucHJvdG90eXBlLm5vdGlmeUFycmF5Q2hhbmdlID0gZnVuY3Rpb24oYmVhbiwgcHJvcGVydHlOYW1lLCBpbmRleCwgY291bnQsIHJlbW92ZWRFbGVtZW50cykge1xuICAgIGNoZWNrTWV0aG9kKCdCZWFuTWFuYWdlci5ub3RpZnlBcnJheUNoYW5nZShiZWFuLCBwcm9wZXJ0eU5hbWUsIGluZGV4LCBjb3VudCwgcmVtb3ZlZEVsZW1lbnRzKScpO1xuICAgIGNoZWNrUGFyYW0oYmVhbiwgJ2JlYW4nKTtcbiAgICBjaGVja1BhcmFtKHByb3BlcnR5TmFtZSwgJ3Byb3BlcnR5TmFtZScpO1xuICAgIGNoZWNrUGFyYW0oaW5kZXgsICdpbmRleCcpO1xuICAgIGNoZWNrUGFyYW0oY291bnQsICdjb3VudCcpO1xuICAgIGNoZWNrUGFyYW0ocmVtb3ZlZEVsZW1lbnRzLCAncmVtb3ZlZEVsZW1lbnRzJyk7XG5cbiAgICB0aGlzLmNsYXNzUmVwb3NpdG9yeS5ub3RpZnlBcnJheUNoYW5nZShiZWFuLCBwcm9wZXJ0eU5hbWUsIGluZGV4LCBjb3VudCwgcmVtb3ZlZEVsZW1lbnRzKTtcbn07XG5cblxuQmVhbk1hbmFnZXIucHJvdG90eXBlLmlzTWFuYWdlZCA9IGZ1bmN0aW9uKGJlYW4pIHtcbiAgICBjaGVja01ldGhvZCgnQmVhbk1hbmFnZXIuaXNNYW5hZ2VkKGJlYW4pJyk7XG4gICAgY2hlY2tQYXJhbShiZWFuLCAnYmVhbicpO1xuXG4gICAgLy8gVE9ETzogSW1wbGVtZW50IGRvbHBoaW4uaXNNYW5hZ2VkKCkgW0RQLTddXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkIHlldFwiKTtcbn07XG5cblxuQmVhbk1hbmFnZXIucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICBjaGVja01ldGhvZCgnQmVhbk1hbmFnZXIuY3JlYXRlKHR5cGUpJyk7XG4gICAgY2hlY2tQYXJhbSh0eXBlLCAndHlwZScpO1xuXG4gICAgLy8gVE9ETzogSW1wbGVtZW50IGRvbHBoaW4uY3JlYXRlKCkgW0RQLTddXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkIHlldFwiKTtcbn07XG5cblxuQmVhbk1hbmFnZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKHR5cGUsIGJlYW4pIHtcbiAgICBjaGVja01ldGhvZCgnQmVhbk1hbmFnZXIuYWRkKHR5cGUsIGJlYW4pJyk7XG4gICAgY2hlY2tQYXJhbSh0eXBlLCAndHlwZScpO1xuICAgIGNoZWNrUGFyYW0oYmVhbiwgJ2JlYW4nKTtcblxuICAgIC8vIFRPRE86IEltcGxlbWVudCBkb2xwaGluLmFkZCgpIFtEUC03XVxuICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZCB5ZXRcIik7XG59O1xuXG5cbkJlYW5NYW5hZ2VyLnByb3RvdHlwZS5hZGRBbGwgPSBmdW5jdGlvbih0eXBlLCBjb2xsZWN0aW9uKSB7XG4gICAgY2hlY2tNZXRob2QoJ0JlYW5NYW5hZ2VyLmFkZEFsbCh0eXBlLCBjb2xsZWN0aW9uKScpO1xuICAgIGNoZWNrUGFyYW0odHlwZSwgJ3R5cGUnKTtcbiAgICBjaGVja1BhcmFtKGNvbGxlY3Rpb24sICdjb2xsZWN0aW9uJyk7XG5cbiAgICAvLyBUT0RPOiBJbXBsZW1lbnQgZG9scGhpbi5hZGRBbGwoKSBbRFAtN11cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWQgeWV0XCIpO1xufTtcblxuXG5CZWFuTWFuYWdlci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oYmVhbikge1xuICAgIGNoZWNrTWV0aG9kKCdCZWFuTWFuYWdlci5yZW1vdmUoYmVhbiknKTtcbiAgICBjaGVja1BhcmFtKGJlYW4sICdiZWFuJyk7XG5cbiAgICAvLyBUT0RPOiBJbXBsZW1lbnQgZG9scGhpbi5yZW1vdmUoKSBbRFAtN11cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWQgeWV0XCIpO1xufTtcblxuXG5CZWFuTWFuYWdlci5wcm90b3R5cGUucmVtb3ZlQWxsID0gZnVuY3Rpb24oY29sbGVjdGlvbikge1xuICAgIGNoZWNrTWV0aG9kKCdCZWFuTWFuYWdlci5yZW1vdmVBbGwoY29sbGVjdGlvbiknKTtcbiAgICBjaGVja1BhcmFtKGNvbGxlY3Rpb24sICdjb2xsZWN0aW9uJyk7XG5cbiAgICAvLyBUT0RPOiBJbXBsZW1lbnQgZG9scGhpbi5yZW1vdmVBbGwoKSBbRFAtN11cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWQgeWV0XCIpO1xufTtcblxuXG5CZWFuTWFuYWdlci5wcm90b3R5cGUucmVtb3ZlSWYgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICBjaGVja01ldGhvZCgnQmVhbk1hbmFnZXIucmVtb3ZlSWYocHJlZGljYXRlKScpO1xuICAgIGNoZWNrUGFyYW0ocHJlZGljYXRlLCAncHJlZGljYXRlJyk7XG5cbiAgICAvLyBUT0RPOiBJbXBsZW1lbnQgZG9scGhpbi5yZW1vdmVJZigpIFtEUC03XVxuICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZCB5ZXRcIik7XG59O1xuXG5cbkJlYW5NYW5hZ2VyLnByb3RvdHlwZS5vbkFkZGVkID0gZnVuY3Rpb24odHlwZSwgZXZlbnRIYW5kbGVyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmICghZXhpc3RzKGV2ZW50SGFuZGxlcikpIHtcbiAgICAgICAgZXZlbnRIYW5kbGVyID0gdHlwZTtcbiAgICAgICAgY2hlY2tNZXRob2QoJ0JlYW5NYW5hZ2VyLm9uQWRkZWQoZXZlbnRIYW5kbGVyKScpO1xuICAgICAgICBjaGVja1BhcmFtKGV2ZW50SGFuZGxlciwgJ2V2ZW50SGFuZGxlcicpO1xuXG4gICAgICAgIHNlbGYuYWxsQWRkZWRIYW5kbGVycyA9IHNlbGYuYWxsQWRkZWRIYW5kbGVycy5jb25jYXQoZXZlbnRIYW5kbGVyKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmFsbEFkZGVkSGFuZGxlcnMgPSBzZWxmLmFsbEFkZGVkSGFuZGxlcnMuZmlsdGVyKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPT0gZXZlbnRIYW5kbGVyO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNoZWNrTWV0aG9kKCdCZWFuTWFuYWdlci5vbkFkZGVkKHR5cGUsIGV2ZW50SGFuZGxlciknKTtcbiAgICAgICAgY2hlY2tQYXJhbSh0eXBlLCAndHlwZScpO1xuICAgICAgICBjaGVja1BhcmFtKGV2ZW50SGFuZGxlciwgJ2V2ZW50SGFuZGxlcicpO1xuXG4gICAgICAgIHZhciBoYW5kbGVyTGlzdCA9IHNlbGYuYWRkZWRIYW5kbGVycy5nZXQodHlwZSk7XG4gICAgICAgIGlmICghZXhpc3RzKGhhbmRsZXJMaXN0KSkge1xuICAgICAgICAgICAgaGFuZGxlckxpc3QgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLmFkZGVkSGFuZGxlcnMuc2V0KHR5cGUsIGhhbmRsZXJMaXN0LmNvbmNhdChldmVudEhhbmRsZXIpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGFuZGxlckxpc3QgPSBzZWxmLmFkZGVkSGFuZGxlcnMuZ2V0KHR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChleGlzdHMoaGFuZGxlckxpc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYWRkZWRIYW5kbGVycy5zZXQodHlwZSwgaGFuZGxlckxpc3QuZmlsdGVyKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IGV2ZW50SGFuZGxlcjtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG5cbkJlYW5NYW5hZ2VyLnByb3RvdHlwZS5vblJlbW92ZWQgPSBmdW5jdGlvbih0eXBlLCBldmVudEhhbmRsZXIpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCFleGlzdHMoZXZlbnRIYW5kbGVyKSkge1xuICAgICAgICBldmVudEhhbmRsZXIgPSB0eXBlO1xuICAgICAgICBjaGVja01ldGhvZCgnQmVhbk1hbmFnZXIub25SZW1vdmVkKGV2ZW50SGFuZGxlciknKTtcbiAgICAgICAgY2hlY2tQYXJhbShldmVudEhhbmRsZXIsICdldmVudEhhbmRsZXInKTtcblxuICAgICAgICBzZWxmLmFsbFJlbW92ZWRIYW5kbGVycyA9IHNlbGYuYWxsUmVtb3ZlZEhhbmRsZXJzLmNvbmNhdChldmVudEhhbmRsZXIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdW5zdWJzY3JpYmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuYWxsUmVtb3ZlZEhhbmRsZXJzID0gc2VsZi5hbGxSZW1vdmVkSGFuZGxlcnMuZmlsdGVyKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPT0gZXZlbnRIYW5kbGVyO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNoZWNrTWV0aG9kKCdCZWFuTWFuYWdlci5vblJlbW92ZWQodHlwZSwgZXZlbnRIYW5kbGVyKScpO1xuICAgICAgICBjaGVja1BhcmFtKHR5cGUsICd0eXBlJyk7XG4gICAgICAgIGNoZWNrUGFyYW0oZXZlbnRIYW5kbGVyLCAnZXZlbnRIYW5kbGVyJyk7XG5cbiAgICAgICAgdmFyIGhhbmRsZXJMaXN0ID0gc2VsZi5yZW1vdmVkSGFuZGxlcnMuZ2V0KHR5cGUpO1xuICAgICAgICBpZiAoIWV4aXN0cyhoYW5kbGVyTGlzdCkpIHtcbiAgICAgICAgICAgIGhhbmRsZXJMaXN0ID0gW107XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5yZW1vdmVkSGFuZGxlcnMuc2V0KHR5cGUsIGhhbmRsZXJMaXN0LmNvbmNhdChldmVudEhhbmRsZXIpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGFuZGxlckxpc3QgPSBzZWxmLnJlbW92ZWRIYW5kbGVycy5nZXQodHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0cyhoYW5kbGVyTGlzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5yZW1vdmVkSGFuZGxlcnMuc2V0KHR5cGUsIGhhbmRsZXJMaXN0LmZpbHRlcihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSBldmVudEhhbmRsZXI7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufTtcblxuXG5CZWFuTWFuYWdlci5wcm90b3R5cGUub25CZWFuVXBkYXRlID0gZnVuY3Rpb24odHlwZSwgZXZlbnRIYW5kbGVyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmICghZXhpc3RzKGV2ZW50SGFuZGxlcikpIHtcbiAgICAgICAgZXZlbnRIYW5kbGVyID0gdHlwZTtcbiAgICAgICAgY2hlY2tNZXRob2QoJ0JlYW5NYW5hZ2VyLm9uQmVhblVwZGF0ZShldmVudEhhbmRsZXIpJyk7XG4gICAgICAgIGNoZWNrUGFyYW0oZXZlbnRIYW5kbGVyLCAnZXZlbnRIYW5kbGVyJyk7XG5cbiAgICAgICAgc2VsZi5hbGxVcGRhdGVkSGFuZGxlcnMgPSBzZWxmLmFsbFVwZGF0ZWRIYW5kbGVycy5jb25jYXQoZXZlbnRIYW5kbGVyKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmFsbFVwZGF0ZWRIYW5kbGVycyA9IHNlbGYuYWxsVXBkYXRlZEhhbmRsZXJzLmZpbHRlcihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IGV2ZW50SGFuZGxlcjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjaGVja01ldGhvZCgnQmVhbk1hbmFnZXIub25CZWFuVXBkYXRlKHR5cGUsIGV2ZW50SGFuZGxlciknKTtcbiAgICAgICAgY2hlY2tQYXJhbSh0eXBlLCAndHlwZScpO1xuICAgICAgICBjaGVja1BhcmFtKGV2ZW50SGFuZGxlciwgJ2V2ZW50SGFuZGxlcicpO1xuXG4gICAgICAgIHZhciBoYW5kbGVyTGlzdCA9IHNlbGYudXBkYXRlZEhhbmRsZXJzLmdldCh0eXBlKTtcbiAgICAgICAgaWYgKCFleGlzdHMoaGFuZGxlckxpc3QpKSB7XG4gICAgICAgICAgICBoYW5kbGVyTGlzdCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYudXBkYXRlZEhhbmRsZXJzLnNldCh0eXBlLCBoYW5kbGVyTGlzdC5jb25jYXQoZXZlbnRIYW5kbGVyKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1bnN1YnNjcmliZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZXJMaXN0ID0gc2VsZi51cGRhdGVkSGFuZGxlcnMuZ2V0KHR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChleGlzdHMoaGFuZGxlckxpc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYudXBkYXRlZEhhbmRsZXJzLnNldCh0eXBlLCBoYW5kbGVyTGlzdC5maWx0ZXIoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPT0gZXZlbnRIYW5kbGVyO1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn07XG5cblxuQmVhbk1hbmFnZXIucHJvdG90eXBlLm9uQXJyYXlVcGRhdGUgPSBmdW5jdGlvbih0eXBlLCBldmVudEhhbmRsZXIpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCFleGlzdHMoZXZlbnRIYW5kbGVyKSkge1xuICAgICAgICBldmVudEhhbmRsZXIgPSB0eXBlO1xuICAgICAgICBjaGVja01ldGhvZCgnQmVhbk1hbmFnZXIub25BcnJheVVwZGF0ZShldmVudEhhbmRsZXIpJyk7XG4gICAgICAgIGNoZWNrUGFyYW0oZXZlbnRIYW5kbGVyLCAnZXZlbnRIYW5kbGVyJyk7XG5cbiAgICAgICAgc2VsZi5hbGxBcnJheVVwZGF0ZWRIYW5kbGVycyA9IHNlbGYuYWxsQXJyYXlVcGRhdGVkSGFuZGxlcnMuY29uY2F0KGV2ZW50SGFuZGxlcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1bnN1YnNjcmliZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5hbGxBcnJheVVwZGF0ZWRIYW5kbGVycyA9IHNlbGYuYWxsQXJyYXlVcGRhdGVkSGFuZGxlcnMuZmlsdGVyKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPT0gZXZlbnRIYW5kbGVyO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNoZWNrTWV0aG9kKCdCZWFuTWFuYWdlci5vbkFycmF5VXBkYXRlKHR5cGUsIGV2ZW50SGFuZGxlciknKTtcbiAgICAgICAgY2hlY2tQYXJhbSh0eXBlLCAndHlwZScpO1xuICAgICAgICBjaGVja1BhcmFtKGV2ZW50SGFuZGxlciwgJ2V2ZW50SGFuZGxlcicpO1xuXG4gICAgICAgIHZhciBoYW5kbGVyTGlzdCA9IHNlbGYuYXJyYXlVcGRhdGVkSGFuZGxlcnMuZ2V0KHR5cGUpO1xuICAgICAgICBpZiAoIWV4aXN0cyhoYW5kbGVyTGlzdCkpIHtcbiAgICAgICAgICAgIGhhbmRsZXJMaXN0ID0gW107XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5hcnJheVVwZGF0ZWRIYW5kbGVycy5zZXQodHlwZSwgaGFuZGxlckxpc3QuY29uY2F0KGV2ZW50SGFuZGxlcikpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdW5zdWJzY3JpYmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyTGlzdCA9IHNlbGYuYXJyYXlVcGRhdGVkSGFuZGxlcnMuZ2V0KHR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChleGlzdHMoaGFuZGxlckxpc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYXJyYXlVcGRhdGVkSGFuZGxlcnMuc2V0KHR5cGUsIGhhbmRsZXJMaXN0LmZpbHRlcihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSBldmVudEhhbmRsZXI7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufTtcblxuXG5cbmV4cG9ydHMuQmVhbk1hbmFnZXIgPSBCZWFuTWFuYWdlcjsiLCIvKiBDb3B5cmlnaHQgMjAxNSBDYW5vbyBFbmdpbmVlcmluZyBBRy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLypqc2xpbnQgYnJvd3NlcmlmeTogdHJ1ZSAqL1xuLyogZ2xvYmFsIFBsYXRmb3JtLCBjb25zb2xlICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIE1hcCA9IHJlcXVpcmUoJy4uL2Jvd2VyX2NvbXBvbmVudHMvY29yZS5qcy9saWJyYXJ5L2ZuL21hcCcpO1xudmFyIGNvbnN0cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMuanMnKTtcbnZhciBleGlzdHMgPSB1dGlscy5leGlzdHM7XG52YXIgY2hlY2tNZXRob2QgPSB1dGlscy5jaGVja01ldGhvZDtcbnZhciBjaGVja1BhcmFtID0gdXRpbHMuY2hlY2tQYXJhbTtcblxudmFyIGJsb2NrZWQgPSBudWxsO1xuXG5mdW5jdGlvbiBmaXhUeXBlKHR5cGUsIHZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgY29uc3RzLkJZVEU6XG4gICAgICAgIGNhc2UgY29uc3RzLlNIT1JUOlxuICAgICAgICBjYXNlIGNvbnN0cy5JTlQ6XG4gICAgICAgIGNhc2UgY29uc3RzLkxPTkc6XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUpO1xuICAgICAgICBjYXNlIGNvbnN0cy5GTE9BVDpcbiAgICAgICAgY2FzZSBjb25zdHMuRE9VQkxFOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICBjYXNlIGNvbnN0cy5CT09MRUFOOlxuICAgICAgICAgICAgcmV0dXJuICd0cnVlJyA9PT0gU3RyaW5nKHZhbHVlKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjYXNlIGNvbnN0cy5TVFJJTkc6XG4gICAgICAgIGNhc2UgY29uc3RzLkVOVU06XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZyb21Eb2xwaGluKGNsYXNzUmVwb3NpdG9yeSwgdHlwZSwgdmFsdWUpIHtcbiAgICBpZiAoISBleGlzdHModmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBjb25zdHMuRE9MUEhJTl9CRUFOOlxuICAgICAgICAgICAgcmV0dXJuIGNsYXNzUmVwb3NpdG9yeS5iZWFuRnJvbURvbHBoaW4uZ2V0KFN0cmluZyh2YWx1ZSkpO1xuICAgICAgICBjYXNlIGNvbnN0cy5EQVRFOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKFN0cmluZyh2YWx1ZSkpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZpeFR5cGUodHlwZSwgdmFsdWUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdG9Eb2xwaGluKGNsYXNzUmVwb3NpdG9yeSwgdHlwZSwgdmFsdWUpIHtcbiAgICBpZiAoISBleGlzdHModmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBjb25zdHMuRE9MUEhJTl9CRUFOOlxuICAgICAgICAgICAgcmV0dXJuIGNsYXNzUmVwb3NpdG9yeS5iZWFuVG9Eb2xwaGluLmdldCh2YWx1ZSk7XG4gICAgICAgIGNhc2UgY29uc3RzLkRBVEU6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBEYXRlPyB2YWx1ZS50b0lTT1N0cmluZygpIDogdmFsdWU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZml4VHlwZSh0eXBlLCB2YWx1ZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzZW5kTGlzdFNwbGljZShjbGFzc1JlcG9zaXRvcnksIG1vZGVsSWQsIHByb3BlcnR5TmFtZSwgZnJvbSwgdG8sIG5ld0VsZW1lbnRzKSB7XG4gICAgdmFyIGRvbHBoaW4gPSBjbGFzc1JlcG9zaXRvcnkuZG9scGhpbjtcbiAgICB2YXIgbW9kZWwgPSBkb2xwaGluLmZpbmRQcmVzZW50YXRpb25Nb2RlbEJ5SWQobW9kZWxJZCk7XG4gICAgaWYgKGV4aXN0cyhtb2RlbCkpIHtcbiAgICAgICAgdmFyIGNsYXNzSW5mbyA9IGNsYXNzUmVwb3NpdG9yeS5jbGFzc2VzLmdldChtb2RlbC5wcmVzZW50YXRpb25Nb2RlbFR5cGUpO1xuICAgICAgICB2YXIgdHlwZSA9IGNsYXNzSW5mb1twcm9wZXJ0eU5hbWVdO1xuICAgICAgICBpZiAoZXhpc3RzKHR5cGUpKSB7XG5cbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVzID0gW1xuICAgICAgICAgICAgICAgIGRvbHBoaW4uYXR0cmlidXRlKCdAQEAgU09VUkNFX1NZU1RFTSBAQEAnLCBudWxsLCAnY2xpZW50JyksXG4gICAgICAgICAgICAgICAgZG9scGhpbi5hdHRyaWJ1dGUoJ3NvdXJjZScsIG51bGwsIG1vZGVsSWQpLFxuICAgICAgICAgICAgICAgIGRvbHBoaW4uYXR0cmlidXRlKCdhdHRyaWJ1dGUnLCBudWxsLCBwcm9wZXJ0eU5hbWUpLFxuICAgICAgICAgICAgICAgIGRvbHBoaW4uYXR0cmlidXRlKCdmcm9tJywgbnVsbCwgZnJvbSksXG4gICAgICAgICAgICAgICAgZG9scGhpbi5hdHRyaWJ1dGUoJ3RvJywgbnVsbCwgdG8pLFxuICAgICAgICAgICAgICAgIGRvbHBoaW4uYXR0cmlidXRlKCdjb3VudCcsIG51bGwsIG5ld0VsZW1lbnRzLmxlbmd0aClcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBuZXdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcy5wdXNoKGRvbHBoaW4uYXR0cmlidXRlKGluZGV4LnRvU3RyaW5nKCksIG51bGwsIHRvRG9scGhpbihjbGFzc1JlcG9zaXRvcnksIHR5cGUsIGVsZW1lbnQpKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRvbHBoaW4ucHJlc2VudGF0aW9uTW9kZWwuYXBwbHkoZG9scGhpbiwgW251bGwsICdARFA6TFNAJ10uY29uY2F0KGF0dHJpYnV0ZXMpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVMaXN0KGNsYXNzUmVwb3NpdG9yeSwgdHlwZSwgYmVhbiwgcHJvcGVydHlOYW1lKSB7XG4gICAgdmFyIGxpc3QgPSBiZWFuW3Byb3BlcnR5TmFtZV07XG4gICAgaWYgKCFleGlzdHMobGlzdCkpIHtcbiAgICAgICAgY2xhc3NSZXBvc2l0b3J5LnByb3BlcnR5VXBkYXRlSGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbihoYW5kbGVyKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIodHlwZSwgYmVhbiwgcHJvcGVydHlOYW1lLCBbXSwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignQW4gZXhjZXB0aW9uIG9jY3VycmVkIHdoaWxlIGNhbGxpbmcgYW4gb25CZWFuVXBkYXRlLWhhbmRsZXInLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBibG9jayhiZWFuLCBwcm9wZXJ0eU5hbWUpIHtcbiAgICBpZiAoZXhpc3RzKGJsb2NrZWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVHJ5aW5nIHRvIGNyZWF0ZSBhIGJsb2NrIHdoaWxlIGFub3RoZXIgYmxvY2sgZXhpc3RzJyk7XG4gICAgfVxuICAgIGJsb2NrZWQgPSB7XG4gICAgICAgIGJlYW46IGJlYW4sXG4gICAgICAgIHByb3BlcnR5TmFtZTogcHJvcGVydHlOYW1lXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gaXNCbG9ja2VkKGJlYW4sIHByb3BlcnR5TmFtZSkge1xuICAgIHJldHVybiBleGlzdHMoYmxvY2tlZCkgJiYgYmxvY2tlZC5iZWFuID09PSBiZWFuICYmIGJsb2NrZWQucHJvcGVydHlOYW1lID09PSBwcm9wZXJ0eU5hbWU7XG59XG5cbmZ1bmN0aW9uIHVuYmxvY2soKSB7XG4gICAgYmxvY2tlZCA9IG51bGw7XG59XG5cblxuZnVuY3Rpb24gQ2xhc3NSZXBvc2l0b3J5KGRvbHBoaW4pIHtcbiAgICBjaGVja01ldGhvZCgnQ2xhc3NSZXBvc2l0b3J5KGRvbHBoaW4pJyk7XG4gICAgY2hlY2tQYXJhbShkb2xwaGluLCAnZG9scGhpbicpO1xuXG4gICAgdGhpcy5kb2xwaGluID0gZG9scGhpbjtcbiAgICB0aGlzLmNsYXNzZXMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5iZWFuRnJvbURvbHBoaW4gPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5iZWFuVG9Eb2xwaGluID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuY2xhc3NJbmZvcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmJlYW5BZGRlZEhhbmRsZXJzID0gW107XG4gICAgdGhpcy5iZWFuUmVtb3ZlZEhhbmRsZXJzID0gW107XG4gICAgdGhpcy5wcm9wZXJ0eVVwZGF0ZUhhbmRsZXJzID0gW107XG4gICAgdGhpcy5hcnJheVVwZGF0ZUhhbmRsZXJzID0gW107XG59XG5cblxuQ2xhc3NSZXBvc2l0b3J5LnByb3RvdHlwZS5ub3RpZnlCZWFuQ2hhbmdlID0gZnVuY3Rpb24oYmVhbiwgcHJvcGVydHlOYW1lLCBuZXdWYWx1ZSkge1xuICAgIGNoZWNrTWV0aG9kKCdDbGFzc1JlcG9zaXRvcnkubm90aWZ5QmVhbkNoYW5nZShiZWFuLCBwcm9wZXJ0eU5hbWUsIG5ld1ZhbHVlKScpO1xuICAgIGNoZWNrUGFyYW0oYmVhbiwgJ2JlYW4nKTtcbiAgICBjaGVja1BhcmFtKHByb3BlcnR5TmFtZSwgJ3Byb3BlcnR5TmFtZScpO1xuXG4gICAgdmFyIG1vZGVsSWQgPSB0aGlzLmJlYW5Ub0RvbHBoaW4uZ2V0KGJlYW4pO1xuICAgIGlmIChleGlzdHMobW9kZWxJZCkpIHtcbiAgICAgICAgdmFyIG1vZGVsID0gdGhpcy5kb2xwaGluLmZpbmRQcmVzZW50YXRpb25Nb2RlbEJ5SWQobW9kZWxJZCk7XG4gICAgICAgIGlmIChleGlzdHMobW9kZWwpKSB7XG4gICAgICAgICAgICB2YXIgY2xhc3NJbmZvID0gdGhpcy5jbGFzc2VzLmdldChtb2RlbC5wcmVzZW50YXRpb25Nb2RlbFR5cGUpO1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBjbGFzc0luZm9bcHJvcGVydHlOYW1lXTtcbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSBtb2RlbC5maW5kQXR0cmlidXRlQnlQcm9wZXJ0eU5hbWUocHJvcGVydHlOYW1lKTtcbiAgICAgICAgICAgIGlmIChleGlzdHModHlwZSkgJiYgZXhpc3RzKGF0dHJpYnV0ZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2xkVmFsdWUgPSBhdHRyaWJ1dGUuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGUuc2V0VmFsdWUodG9Eb2xwaGluKHRoaXMsIHR5cGUsIG5ld1ZhbHVlKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyb21Eb2xwaGluKHRoaXMsIHR5cGUsIG9sZFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuQ2xhc3NSZXBvc2l0b3J5LnByb3RvdHlwZS5ub3RpZnlBcnJheUNoYW5nZSA9IGZ1bmN0aW9uKGJlYW4sIHByb3BlcnR5TmFtZSwgaW5kZXgsIGNvdW50LCByZW1vdmVkRWxlbWVudHMpIHtcbiAgICBjaGVja01ldGhvZCgnQ2xhc3NSZXBvc2l0b3J5Lm5vdGlmeUFycmF5Q2hhbmdlKGJlYW4sIHByb3BlcnR5TmFtZSwgaW5kZXgsIGNvdW50LCByZW1vdmVkRWxlbWVudHMpJyk7XG4gICAgY2hlY2tQYXJhbShiZWFuLCAnYmVhbicpO1xuICAgIGNoZWNrUGFyYW0ocHJvcGVydHlOYW1lLCAncHJvcGVydHlOYW1lJyk7XG4gICAgY2hlY2tQYXJhbShpbmRleCwgJ2luZGV4Jyk7XG4gICAgY2hlY2tQYXJhbShjb3VudCwgJ2NvdW50Jyk7XG4gICAgY2hlY2tQYXJhbShyZW1vdmVkRWxlbWVudHMsICdyZW1vdmVkRWxlbWVudHMnKTtcblxuICAgIGlmIChpc0Jsb2NrZWQoYmVhbiwgcHJvcGVydHlOYW1lKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBtb2RlbElkID0gdGhpcy5iZWFuVG9Eb2xwaGluLmdldChiZWFuKTtcbiAgICB2YXIgYXJyYXkgPSBiZWFuW3Byb3BlcnR5TmFtZV07XG4gICAgaWYgKGV4aXN0cyhtb2RlbElkKSAmJiBleGlzdHMoYXJyYXkpKSB7XG4gICAgICAgIHZhciByZW1vdmVkRWxlbWVudHNDb3VudCA9IEFycmF5LmlzQXJyYXkocmVtb3ZlZEVsZW1lbnRzKT8gcmVtb3ZlZEVsZW1lbnRzLmxlbmd0aCA6IDA7XG4gICAgICAgIHNlbmRMaXN0U3BsaWNlKHRoaXMsIG1vZGVsSWQsIHByb3BlcnR5TmFtZSwgaW5kZXgsIGluZGV4ICsgcmVtb3ZlZEVsZW1lbnRzQ291bnQsIGFycmF5LnNsaWNlKGluZGV4LCBpbmRleCArIGNvdW50KSk7XG4gICAgfVxufTtcblxuXG5DbGFzc1JlcG9zaXRvcnkucHJvdG90eXBlLm9uQmVhbkFkZGVkID0gZnVuY3Rpb24oaGFuZGxlcikge1xuICAgIGNoZWNrTWV0aG9kKCdDbGFzc1JlcG9zaXRvcnkub25CZWFuQWRkZWQoaGFuZGxlciknKTtcbiAgICBjaGVja1BhcmFtKGhhbmRsZXIsICdoYW5kbGVyJyk7XG4gICAgdGhpcy5iZWFuQWRkZWRIYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xufTtcblxuXG5DbGFzc1JlcG9zaXRvcnkucHJvdG90eXBlLm9uQmVhblJlbW92ZWQgPSBmdW5jdGlvbihoYW5kbGVyKSB7XG4gICAgY2hlY2tNZXRob2QoJ0NsYXNzUmVwb3NpdG9yeS5vbkJlYW5SZW1vdmVkKGhhbmRsZXIpJyk7XG4gICAgY2hlY2tQYXJhbShoYW5kbGVyLCAnaGFuZGxlcicpO1xuICAgIHRoaXMuYmVhblJlbW92ZWRIYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xufTtcblxuXG5DbGFzc1JlcG9zaXRvcnkucHJvdG90eXBlLm9uQmVhblVwZGF0ZSA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICBjaGVja01ldGhvZCgnQ2xhc3NSZXBvc2l0b3J5Lm9uQmVhblVwZGF0ZShoYW5kbGVyKScpO1xuICAgIGNoZWNrUGFyYW0oaGFuZGxlciwgJ2hhbmRsZXInKTtcbiAgICB0aGlzLnByb3BlcnR5VXBkYXRlSGFuZGxlcnMucHVzaChoYW5kbGVyKTtcbn07XG5cblxuQ2xhc3NSZXBvc2l0b3J5LnByb3RvdHlwZS5vbkFycmF5VXBkYXRlID0gZnVuY3Rpb24oaGFuZGxlcikge1xuICAgIGNoZWNrTWV0aG9kKCdDbGFzc1JlcG9zaXRvcnkub25BcnJheVVwZGF0ZShoYW5kbGVyKScpO1xuICAgIGNoZWNrUGFyYW0oaGFuZGxlciwgJ2hhbmRsZXInKTtcbiAgICB0aGlzLmFycmF5VXBkYXRlSGFuZGxlcnMucHVzaChoYW5kbGVyKTtcbn07XG5cblxuQ2xhc3NSZXBvc2l0b3J5LnByb3RvdHlwZS5yZWdpc3RlckNsYXNzID0gZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgY2hlY2tNZXRob2QoJ0NsYXNzUmVwb3NpdG9yeS5yZWdpc3RlckNsYXNzKG1vZGVsKScpO1xuICAgIGNoZWNrUGFyYW0obW9kZWwsICdtb2RlbCcpO1xuXG4gICAgaWYgKHRoaXMuY2xhc3Nlcy5oYXMobW9kZWwuaWQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY2xhc3NJbmZvID0ge307XG4gICAgbW9kZWwuYXR0cmlidXRlcy5maWx0ZXIoZnVuY3Rpb24oYXR0cmlidXRlKSB7XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGUucHJvcGVydHlOYW1lLnNlYXJjaCgvXkAvKSA8IDA7XG4gICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICAgIGNsYXNzSW5mb1thdHRyaWJ1dGUucHJvcGVydHlOYW1lXSA9IGF0dHJpYnV0ZS52YWx1ZTtcbiAgICB9KTtcbiAgICB0aGlzLmNsYXNzZXMuc2V0KG1vZGVsLmlkLCBjbGFzc0luZm8pO1xufTtcblxuXG5DbGFzc1JlcG9zaXRvcnkucHJvdG90eXBlLnVucmVnaXN0ZXJDbGFzcyA9IGZ1bmN0aW9uIChtb2RlbCkge1xuICAgIGNoZWNrTWV0aG9kKCdDbGFzc1JlcG9zaXRvcnkudW5yZWdpc3RlckNsYXNzKG1vZGVsKScpO1xuICAgIGNoZWNrUGFyYW0obW9kZWwsICdtb2RlbCcpO1xuXG4gICAgdGhpcy5jbGFzc2VzWydkZWxldGUnXShtb2RlbC5pZCk7XG59O1xuXG5cbkNsYXNzUmVwb3NpdG9yeS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChtb2RlbCkge1xuICAgIGNoZWNrTWV0aG9kKCdDbGFzc1JlcG9zaXRvcnkubG9hZChtb2RlbCknKTtcbiAgICBjaGVja1BhcmFtKG1vZGVsLCAnbW9kZWwnKTtcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY2xhc3NJbmZvID0gdGhpcy5jbGFzc2VzLmdldChtb2RlbC5wcmVzZW50YXRpb25Nb2RlbFR5cGUpO1xuICAgIHZhciBiZWFuID0ge307XG4gICAgbW9kZWwuYXR0cmlidXRlcy5maWx0ZXIoZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuICAgICAgICByZXR1cm4gKGF0dHJpYnV0ZS5wcm9wZXJ0eU5hbWUuc2VhcmNoKC9eQC8pIDwgMCk7XG4gICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICAgIGJlYW5bYXR0cmlidXRlLnByb3BlcnR5TmFtZV0gPSBudWxsO1xuICAgICAgICBhdHRyaWJ1dGUub25WYWx1ZUNoYW5nZShmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5vbGRWYWx1ZSAhPT0gZXZlbnQubmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2xkVmFsdWUgPSBmcm9tRG9scGhpbihzZWxmLCBjbGFzc0luZm9bYXR0cmlidXRlLnByb3BlcnR5TmFtZV0sIGV2ZW50Lm9sZFZhbHVlKTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSBmcm9tRG9scGhpbihzZWxmLCBjbGFzc0luZm9bYXR0cmlidXRlLnByb3BlcnR5TmFtZV0sIGV2ZW50Lm5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICBzZWxmLnByb3BlcnR5VXBkYXRlSGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbihoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyKG1vZGVsLnByZXNlbnRhdGlvbk1vZGVsVHlwZSwgYmVhbiwgYXR0cmlidXRlLnByb3BlcnR5TmFtZSwgbmV3VmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0FuIGV4Y2VwdGlvbiBvY2N1cnJlZCB3aGlsZSBjYWxsaW5nIGFuIG9uQmVhblVwZGF0ZS1oYW5kbGVyJywgZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5iZWFuRnJvbURvbHBoaW4uc2V0KG1vZGVsLmlkLCBiZWFuKTtcbiAgICB0aGlzLmJlYW5Ub0RvbHBoaW4uc2V0KGJlYW4sIG1vZGVsLmlkKTtcbiAgICB0aGlzLmNsYXNzSW5mb3Muc2V0KG1vZGVsLmlkLCBjbGFzc0luZm8pO1xuICAgIHRoaXMuYmVhbkFkZGVkSGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbihoYW5kbGVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBoYW5kbGVyKG1vZGVsLnByZXNlbnRhdGlvbk1vZGVsVHlwZSwgYmVhbik7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdBbiBleGNlcHRpb24gb2NjdXJyZWQgd2hpbGUgY2FsbGluZyBhbiBvbkJlYW5BZGRlZC1oYW5kbGVyJywgZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYmVhbjtcbn07XG5cblxuQ2xhc3NSZXBvc2l0b3J5LnByb3RvdHlwZS51bmxvYWQgPSBmdW5jdGlvbihtb2RlbCkge1xuICAgIGNoZWNrTWV0aG9kKCdDbGFzc1JlcG9zaXRvcnkudW5sb2FkKG1vZGVsKScpO1xuICAgIGNoZWNrUGFyYW0obW9kZWwsICdtb2RlbCcpO1xuXG4gICAgdmFyIGJlYW4gPSB0aGlzLmJlYW5Gcm9tRG9scGhpbi5nZXQobW9kZWwuaWQpO1xuICAgIHRoaXMuYmVhbkZyb21Eb2xwaGluWydkZWxldGUnXShtb2RlbC5pZCk7XG4gICAgdGhpcy5iZWFuVG9Eb2xwaGluWydkZWxldGUnXShiZWFuKTtcbiAgICB0aGlzLmNsYXNzSW5mb3NbJ2RlbGV0ZSddKG1vZGVsLmlkKTtcbiAgICBpZiAoZXhpc3RzKGJlYW4pKSB7XG4gICAgICAgIHRoaXMuYmVhblJlbW92ZWRIYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlcihtb2RlbC5wcmVzZW50YXRpb25Nb2RlbFR5cGUsIGJlYW4pO1xuICAgICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdBbiBleGNlcHRpb24gb2NjdXJyZWQgd2hpbGUgY2FsbGluZyBhbiBvbkJlYW5SZW1vdmVkLWhhbmRsZXInLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBiZWFuO1xufTtcblxuXG5DbGFzc1JlcG9zaXRvcnkucHJvdG90eXBlLnNwbGljZUxpc3RFbnRyeSA9IGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgY2hlY2tNZXRob2QoJ0NsYXNzUmVwb3NpdG9yeS5zcGxpY2VMaXN0RW50cnkobW9kZWwpJyk7XG4gICAgY2hlY2tQYXJhbShtb2RlbCwgJ21vZGVsJyk7XG5cbiAgICB2YXIgc291cmNlID0gbW9kZWwuZmluZEF0dHJpYnV0ZUJ5UHJvcGVydHlOYW1lKCdzb3VyY2UnKTtcbiAgICB2YXIgYXR0cmlidXRlID0gbW9kZWwuZmluZEF0dHJpYnV0ZUJ5UHJvcGVydHlOYW1lKCdhdHRyaWJ1dGUnKTtcbiAgICB2YXIgZnJvbSA9IG1vZGVsLmZpbmRBdHRyaWJ1dGVCeVByb3BlcnR5TmFtZSgnZnJvbScpO1xuICAgIHZhciB0byA9IG1vZGVsLmZpbmRBdHRyaWJ1dGVCeVByb3BlcnR5TmFtZSgndG8nKTtcbiAgICB2YXIgY291bnQgPSBtb2RlbC5maW5kQXR0cmlidXRlQnlQcm9wZXJ0eU5hbWUoJ2NvdW50Jyk7XG5cbiAgICBpZiAoZXhpc3RzKHNvdXJjZSkgJiYgZXhpc3RzKGF0dHJpYnV0ZSkgJiYgZXhpc3RzKGZyb20pICYmIGV4aXN0cyh0bykgJiYgZXhpc3RzKGNvdW50KSkge1xuICAgICAgICB2YXIgY2xhc3NJbmZvID0gdGhpcy5jbGFzc0luZm9zLmdldChzb3VyY2UudmFsdWUpO1xuICAgICAgICB2YXIgYmVhbiA9IHRoaXMuYmVhbkZyb21Eb2xwaGluLmdldChzb3VyY2UudmFsdWUpO1xuICAgICAgICBpZiAoZXhpc3RzKGJlYW4pICYmIGV4aXN0cyhjbGFzc0luZm8pKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IG1vZGVsLnByZXNlbnRhdGlvbk1vZGVsVHlwZTtcbiAgICAgICAgICAgIC8vdmFyIGVudHJ5ID0gZnJvbURvbHBoaW4odGhpcywgY2xhc3NJbmZvW2F0dHJpYnV0ZS52YWx1ZV0sIGVsZW1lbnQudmFsdWUpO1xuICAgICAgICAgICAgdmFsaWRhdGVMaXN0KHRoaXMsIHR5cGUsIGJlYW4sIGF0dHJpYnV0ZS52YWx1ZSk7XG4gICAgICAgICAgICB2YXIgbmV3RWxlbWVudHMgPSBbXSxcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQudmFsdWU7IGkrKykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBtb2RlbC5maW5kQXR0cmlidXRlQnlQcm9wZXJ0eU5hbWUoaS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICBpZiAoISBleGlzdHMoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBsaXN0IG1vZGlmaWNhdGlvbiB1cGRhdGUgcmVjZWl2ZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5ld0VsZW1lbnRzLnB1c2goZnJvbURvbHBoaW4odGhpcywgY2xhc3NJbmZvW2F0dHJpYnV0ZS52YWx1ZV0sIGVsZW1lbnQudmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYmxvY2soYmVhbiwgYXR0cmlidXRlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFycmF5VXBkYXRlSGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcih0eXBlLCBiZWFuLCBhdHRyaWJ1dGUudmFsdWUsIGZyb20udmFsdWUsIHRvLnZhbHVlIC0gZnJvbS52YWx1ZSwgbmV3RWxlbWVudHMpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignQW4gZXhjZXB0aW9uIG9jY3VycmVkIHdoaWxlIGNhbGxpbmcgYW4gb25BcnJheVVwZGF0ZS1oYW5kbGVyJywgZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdW5ibG9jaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBsaXN0IG1vZGlmaWNhdGlvbiB1cGRhdGUgcmVjZWl2ZWQuIFNvdXJjZSBiZWFuIHVua25vd24uXCIpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBsaXN0IG1vZGlmaWNhdGlvbiB1cGRhdGUgcmVjZWl2ZWRcIik7XG4gICAgfVxufTtcblxuXG5DbGFzc1JlcG9zaXRvcnkucHJvdG90eXBlLm1hcFBhcmFtVG9Eb2xwaGluID0gZnVuY3Rpb24ocGFyYW0pIHtcbiAgICBpZiAoIWV4aXN0cyhwYXJhbSkpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtO1xuICAgIH1cbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBwYXJhbTtcbiAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKHBhcmFtIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmFtLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmJlYW5Ub0RvbHBoaW4uZ2V0KHBhcmFtKTtcbiAgICAgICAgICAgIGlmIChleGlzdHModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9ubHkgbWFuYWdlZCBEb2xwaGluIEJlYW5zIGNhbiBiZSB1c2VkXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlID09PSAnbnVtYmVyJyB8fCB0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT25seSBtYW5hZ2VkIERvbHBoaW4gQmVhbnMgYW5kIHByaW1pdGl2ZSB0eXBlcyBjYW4gYmUgdXNlZFwiKTtcbn07XG5cblxuQ2xhc3NSZXBvc2l0b3J5LnByb3RvdHlwZS5tYXBEb2xwaGluVG9CZWFuID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnJvbURvbHBoaW4odGhpcywgY29uc3RzLkRPTFBISU5fQkVBTiwgdmFsdWUpO1xufTtcblxuXG5cbmV4cG9ydHMuQ2xhc3NSZXBvc2l0b3J5ID0gQ2xhc3NSZXBvc2l0b3J5O1xuIiwiLyogQ29weXJpZ2h0IDIwMTUgQ2Fub28gRW5naW5lZXJpbmcgQUcuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qanNsaW50IGJyb3dzZXJpZnk6IHRydWUgKi9cbi8qIGdsb2JhbCBjb25zb2xlICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdlbWl0dGVyLWNvbXBvbmVudCcpO1xudmFyIFByb21pc2UgPSByZXF1aXJlKCcuLi9ib3dlcl9jb21wb25lbnRzL2NvcmUuanMvbGlicmFyeS9mbi9wcm9taXNlJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzLmpzJyk7XG52YXIgY2hlY2tNZXRob2QgPSB1dGlscy5jaGVja01ldGhvZDtcbnZhciBjaGVja1BhcmFtID0gdXRpbHMuY2hlY2tQYXJhbTtcblxudmFyIERPTFBISU5fUExBVEZPUk1fUFJFRklYID0gJ2RvbHBoaW5fcGxhdGZvcm1faW50ZXJuXyc7XG52YXIgSU5JVF9DT01NQU5EX05BTUUgPSBET0xQSElOX1BMQVRGT1JNX1BSRUZJWCArICdpbml0Q2xpZW50Q29udGV4dCc7XG52YXIgRElTQ09OTkVDVF9DT01NQU5EX05BTUUgPSBET0xQSElOX1BMQVRGT1JNX1BSRUZJWCArICdkaXNjb25uZWN0Q2xpZW50Q29udGV4dCc7XG5cbmZ1bmN0aW9uIENsaWVudENvbnRleHQoZG9scGhpbiwgYmVhbk1hbmFnZXIsIGNvbnRyb2xsZXJNYW5hZ2VyLCBjb25uZWN0b3IpIHtcbiAgICBjaGVja01ldGhvZCgnQ2xpZW50Q29udGV4dChkb2xwaGluLCBiZWFuTWFuYWdlciwgY29udHJvbGxlck1hbmFnZXIsIGNvbm5lY3RvciknKTtcbiAgICBjaGVja1BhcmFtKGRvbHBoaW4sICdkb2xwaGluJyk7XG4gICAgY2hlY2tQYXJhbShiZWFuTWFuYWdlciwgJ2JlYW5NYW5hZ2VyJyk7XG4gICAgY2hlY2tQYXJhbShjb250cm9sbGVyTWFuYWdlciwgJ2NvbnRyb2xsZXJNYW5hZ2VyJyk7XG4gICAgY2hlY2tQYXJhbShjb25uZWN0b3IsICdjb25uZWN0b3InKTtcblxuICAgIHRoaXMuZG9scGhpbiA9IGRvbHBoaW47XG4gICAgdGhpcy5iZWFuTWFuYWdlciA9IGJlYW5NYW5hZ2VyO1xuICAgIHRoaXMuX2NvbnRyb2xsZXJNYW5hZ2VyID0gY29udHJvbGxlck1hbmFnZXI7XG4gICAgdGhpcy5fY29ubmVjdG9yID0gY29ubmVjdG9yO1xuXG4gICAgdGhpcy5fY29ubmVjdG9yLmludm9rZShJTklUX0NPTU1BTkRfTkFNRSk7XG59XG5cbkVtaXR0ZXIoQ2xpZW50Q29udGV4dC5wcm90b3R5cGUpO1xuXG5cbkNsaWVudENvbnRleHQucHJvdG90eXBlLmNyZWF0ZUNvbnRyb2xsZXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgY2hlY2tNZXRob2QoJ0NsaWVudENvbnRleHQuY3JlYXRlQ29udHJvbGxlcihuYW1lKScpO1xuICAgIGNoZWNrUGFyYW0obmFtZSwgJ25hbWUnKTtcblxuICAgIHJldHVybiB0aGlzLl9jb250cm9sbGVyTWFuYWdlci5jcmVhdGVDb250cm9sbGVyKG5hbWUpO1xufTtcblxuXG5DbGllbnRDb250ZXh0LnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gVE9ETzogSW1wbGVtZW50IENsaWVudENvbnRleHQuZGlzY29ubmVjdCBbRFAtNDZdXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuZG9scGhpbi5zdG9wUHVzaExpc3RlbmluZygpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgIHNlbGYuX2NvbnRyb2xsZXJNYW5hZ2VyLmRlc3Ryb3koKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNlbGYuX2Nvbm5lY3Rvci5pbnZva2UoRElTQ09OTkVDVF9DT01NQU5EX05BTUUpO1xuICAgICAgICAgICAgc2VsZi5kb2xwaGluID0gbnVsbDtcbiAgICAgICAgICAgIHNlbGYuYmVhbk1hbmFnZXIgPSBudWxsO1xuICAgICAgICAgICAgc2VsZi5fY29udHJvbGxlck1hbmFnZXIgPSBudWxsO1xuICAgICAgICAgICAgc2VsZi5fY29ubmVjdG9yID0gbnVsbDtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuXG5cbmV4cG9ydHMuQ2xpZW50Q29udGV4dCA9IENsaWVudENvbnRleHQ7IiwiLyogQ29weXJpZ2h0IDIwMTYgQ2Fub28gRW5naW5lZXJpbmcgQUcuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qanNsaW50IGJyb3dzZXJpZnk6IHRydWUgKi9cblxuXG5pbXBvcnQgeyBleGlzdHMgfSBmcm9tICcuL3V0aWxzLmpzJztcblxuXG5mdW5jdGlvbiBlbmNvZGVDcmVhdGVQcmVzZW50YXRpb25Nb2RlbENvbW1hbmQoY29tbWFuZCkge1xuICAgIHJldHVybiB7XG4gICAgICAgICdwJzogY29tbWFuZC5wbUlkLFxuICAgICAgICAndCc6IGNvbW1hbmQucG1UeXBlLFxuICAgICAgICAnYSc6IGNvbW1hbmQuYXR0cmlidXRlcy5tYXAoZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICAnbic6IGF0dHJpYnV0ZS5wcm9wZXJ0eU5hbWUsXG4gICAgICAgICAgICAgICAgJ2knOiBhdHRyaWJ1dGUuaWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZXhpc3RzKGF0dHJpYnV0ZS52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudiA9IGF0dHJpYnV0ZS52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pLFxuICAgICAgICAnaWQnOiAnQ3JlYXRlUHJlc2VudGF0aW9uTW9kZWwnXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQ3JlYXRlUHJlc2VudGF0aW9uTW9kZWxDb21tYW5kKGNvbW1hbmQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAnaWQnOiAnQ3JlYXRlUHJlc2VudGF0aW9uTW9kZWwnLFxuICAgICAgICAnY2xhc3NOYW1lJzogXCJvcmcub3BlbmRvbHBoaW4uY29yZS5jb21tLkNyZWF0ZVByZXNlbnRhdGlvbk1vZGVsQ29tbWFuZFwiLFxuICAgICAgICAnY2xpZW50U2lkZU9ubHknOiBmYWxzZSxcbiAgICAgICAgJ3BtSWQnOiBjb21tYW5kLnAsXG4gICAgICAgICdwbVR5cGUnOiBjb21tYW5kLnQsXG4gICAgICAgICdhdHRyaWJ1dGVzJzogY29tbWFuZC5hLm1hcChmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICdwcm9wZXJ0eU5hbWUnOiBhdHRyaWJ1dGUubixcbiAgICAgICAgICAgICAgICAnaWQnOiBhdHRyaWJ1dGUuaSxcbiAgICAgICAgICAgICAgICAndmFsdWUnOiBleGlzdHMoYXR0cmlidXRlLnYpPyBhdHRyaWJ1dGUudiA6IG51bGwsXG4gICAgICAgICAgICAgICAgJ3F1YWxpZmllcic6IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgfTtcbn1cblxuXG5mdW5jdGlvbiBlbmNvZGVWYWx1ZUNoYW5nZWRDb21tYW5kKGNvbW1hbmQpIHtcbiAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAnYSc6IGNvbW1hbmQuYXR0cmlidXRlSWRcbiAgICB9O1xuICAgIGlmIChleGlzdHMoY29tbWFuZC5vbGRWYWx1ZSkpIHtcbiAgICAgICAgcmVzdWx0Lm8gPSBjb21tYW5kLm9sZFZhbHVlO1xuICAgIH1cbiAgICBpZiAoZXhpc3RzKGNvbW1hbmQubmV3VmFsdWUpKSB7XG4gICAgICAgIHJlc3VsdC5uID0gY29tbWFuZC5uZXdWYWx1ZTtcbiAgICB9XG4gICAgcmVzdWx0LmlkID0gJ1ZhbHVlQ2hhbmdlZCc7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZGVjb2RlVmFsdWVDaGFuZ2VkQ29tbWFuZChjb21tYW5kKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgJ2lkJzogJ1ZhbHVlQ2hhbmdlZCcsXG4gICAgICAgICdjbGFzc05hbWUnOiBcIm9yZy5vcGVuZG9scGhpbi5jb3JlLmNvbW0uVmFsdWVDaGFuZ2VkQ29tbWFuZFwiLFxuICAgICAgICAnYXR0cmlidXRlSWQnOiBjb21tYW5kLmEsXG4gICAgICAgICdvbGRWYWx1ZSc6IGV4aXN0cyhjb21tYW5kLm8pPyBjb21tYW5kLm8gOiBudWxsLFxuICAgICAgICAnbmV3VmFsdWUnOiBleGlzdHMoY29tbWFuZC5uKT8gY29tbWFuZC5uIDogbnVsbFxuICAgIH07XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZShjb21tYW5kcykge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShjb21tYW5kcy5tYXAoZnVuY3Rpb24gKGNvbW1hbmQpIHtcbiAgICAgICAgaWYgKGNvbW1hbmQuaWQgPT09ICdDcmVhdGVQcmVzZW50YXRpb25Nb2RlbCcpIHtcbiAgICAgICAgICAgIHJldHVybiBlbmNvZGVDcmVhdGVQcmVzZW50YXRpb25Nb2RlbENvbW1hbmQoY29tbWFuZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29tbWFuZC5pZCA9PT0gJ1ZhbHVlQ2hhbmdlZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBlbmNvZGVWYWx1ZUNoYW5nZWRDb21tYW5kKGNvbW1hbmQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21tYW5kO1xuICAgIH0pKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZSh0cmFuc21pdHRlZCkge1xuICAgIGlmICh0eXBlb2YgdHJhbnNtaXR0ZWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHRyYW5zbWl0dGVkKS5tYXAoZnVuY3Rpb24gKGNvbW1hbmQpIHtcbiAgICAgICAgICAgIGlmIChjb21tYW5kLmlkID09PSAnQ3JlYXRlUHJlc2VudGF0aW9uTW9kZWwnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZUNyZWF0ZVByZXNlbnRhdGlvbk1vZGVsQ29tbWFuZChjb21tYW5kKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29tbWFuZC5pZCA9PT0gJ1ZhbHVlQ2hhbmdlZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlVmFsdWVDaGFuZ2VkQ29tbWFuZChjb21tYW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb21tYW5kO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHJhbnNtaXR0ZWQ7XG4gICAgfVxufVxuIiwiLyogQ29weXJpZ2h0IDIwMTUgQ2Fub28gRW5naW5lZXJpbmcgQUcuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qanNsaW50IGJyb3dzZXJpZnk6IHRydWUgKi9cbi8qIGdsb2JhbCBjb25zb2xlICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIFByb21pc2UgPSByZXF1aXJlKCcuLi9ib3dlcl9jb21wb25lbnRzL2NvcmUuanMvbGlicmFyeS9mbi9wcm9taXNlJyk7XG52YXIgQ2xpZW50TW9kZWxTdG9yZSA9IHJlcXVpcmUoJy4uL29wZW5kb2xwaGluL2J1aWxkL0NsaWVudE1vZGVsU3RvcmUnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMuanMnKTtcbnZhciBleGlzdHMgPSB1dGlscy5leGlzdHM7XG52YXIgY2hlY2tNZXRob2QgPSB1dGlscy5jaGVja01ldGhvZDtcbnZhciBjaGVja1BhcmFtID0gdXRpbHMuY2hlY2tQYXJhbTtcblxuXG52YXIgRE9MUEhJTl9QTEFURk9STV9QUkVGSVggPSAnZG9scGhpbl9wbGF0Zm9ybV9pbnRlcm5fJztcbnZhciBQT0xMX0NPTU1BTkRfTkFNRSA9IERPTFBISU5fUExBVEZPUk1fUFJFRklYICsgJ2xvbmdQb2xsJztcbnZhciBSRUxFQVNFX0NPTU1BTkRfTkFNRSA9IERPTFBISU5fUExBVEZPUk1fUFJFRklYICsgJ3JlbGVhc2UnO1xuXG52YXIgRE9MUEhJTl9CRUFOID0gJ0BAQCBET0xQSElOX0JFQU4gQEBAJztcbnZhciBBQ1RJT05fQ0FMTF9CRUFOID0gJ0BAQCBDT05UUk9MTEVSX0FDVElPTl9DQUxMX0JFQU4gQEBAJztcbnZhciBISUdITEFOREVSX0JFQU4gPSAnQEBAIEhJR0hMQU5ERVJfQkVBTiBAQEAnO1xudmFyIERPTFBISU5fTElTVF9TUExJQ0UgPSAnQERQOkxTQCc7XG52YXIgU09VUkNFX1NZU1RFTSA9ICdAQEAgU09VUkNFX1NZU1RFTSBAQEAnO1xudmFyIFNPVVJDRV9TWVNURU1fQ0xJRU5UID0gJ2NsaWVudCc7XG52YXIgU09VUkNFX1NZU1RFTV9TRVJWRVIgPSAnc2VydmVyJztcblxuXG5cbmZ1bmN0aW9uIENvbm5lY3Rvcih1cmwsIGRvbHBoaW4sIGNsYXNzUmVwb3NpdG9yeSwgY29uZmlnKSB7XG4gICAgY2hlY2tNZXRob2QoJ0Nvbm5lY3Rvcih1cmwsIGRvbHBoaW4sIGNsYXNzUmVwb3NpdG9yeSwgY29uZmlnKScpO1xuICAgIGNoZWNrUGFyYW0odXJsLCAndXJsJyk7XG4gICAgY2hlY2tQYXJhbShkb2xwaGluLCAnZG9scGhpbicpO1xuICAgIGNoZWNrUGFyYW0oY2xhc3NSZXBvc2l0b3J5LCAnY2xhc3NSZXBvc2l0b3J5Jyk7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5kb2xwaGluID0gZG9scGhpbjtcbiAgICB0aGlzLmNsYXNzUmVwb3NpdG9yeSA9IGNsYXNzUmVwb3NpdG9yeTtcbiAgICB0aGlzLmhpZ2hsYW5kZXJQTVJlc29sdmVyID0gZnVuY3Rpb24oKSB7fTtcbiAgICB0aGlzLmhpZ2hsYW5kZXJQTVByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgIHNlbGYuaGlnaGxhbmRlclBNUmVzb2x2ZXIgPSByZXNvbHZlO1xuICAgIH0pO1xuXG4gICAgZG9scGhpbi5nZXRDbGllbnRNb2RlbFN0b3JlKCkub25Nb2RlbFN0b3JlQ2hhbmdlKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgbW9kZWwgPSBldmVudC5jbGllbnRQcmVzZW50YXRpb25Nb2RlbDtcbiAgICAgICAgdmFyIHNvdXJjZVN5c3RlbSA9IG1vZGVsLmZpbmRBdHRyaWJ1dGVCeVByb3BlcnR5TmFtZShTT1VSQ0VfU1lTVEVNKTtcbiAgICAgICAgaWYgKGV4aXN0cyhzb3VyY2VTeXN0ZW0pICYmIHNvdXJjZVN5c3RlbS52YWx1ZSA9PT0gU09VUkNFX1NZU1RFTV9TRVJWRVIpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5ldmVudFR5cGUgPT09IENsaWVudE1vZGVsU3RvcmUuVHlwZS5BRERFRCkge1xuICAgICAgICAgICAgICAgIHNlbGYub25Nb2RlbEFkZGVkKG1vZGVsKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQuZXZlbnRUeXBlID09PSBDbGllbnRNb2RlbFN0b3JlLlR5cGUuUkVNT1ZFRCkge1xuICAgICAgICAgICAgICAgIHNlbGYub25Nb2RlbFJlbW92ZWQobW9kZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoIWV4aXN0cyhjb25maWcpIHx8ICFleGlzdHMoY29uZmlnLnNlcnZlclB1c2gpIHx8IGNvbmZpZy5zZXJ2ZXJQdXNoID09PSB0cnVlKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkb2xwaGluLnN0YXJ0UHVzaExpc3RlbmluZyhQT0xMX0NPTU1BTkRfTkFNRSwgUkVMRUFTRV9DT01NQU5EX05BTUUpO1xuICAgICAgICB9LCA1MDApO1xuICAgIH1cbn1cblxuXG5Db25uZWN0b3IucHJvdG90eXBlLm9uTW9kZWxBZGRlZCA9IGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgY2hlY2tNZXRob2QoJ0Nvbm5lY3Rvci5vbk1vZGVsQWRkZWQobW9kZWwpJyk7XG4gICAgY2hlY2tQYXJhbShtb2RlbCwgJ21vZGVsJyk7XG5cbiAgICB2YXIgdHlwZSA9IG1vZGVsLnByZXNlbnRhdGlvbk1vZGVsVHlwZTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBBQ1RJT05fQ0FMTF9CRUFOOlxuICAgICAgICAgICAgLy8gaWdub3JlXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBET0xQSElOX0JFQU46XG4gICAgICAgICAgICB0aGlzLmNsYXNzUmVwb3NpdG9yeS5yZWdpc3RlckNsYXNzKG1vZGVsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEhJR0hMQU5ERVJfQkVBTjpcbiAgICAgICAgICAgIHRoaXMuaGlnaGxhbmRlclBNUmVzb2x2ZXIobW9kZWwpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRE9MUEhJTl9MSVNUX1NQTElDRTpcbiAgICAgICAgICAgIHRoaXMuY2xhc3NSZXBvc2l0b3J5LnNwbGljZUxpc3RFbnRyeShtb2RlbCk7XG4gICAgICAgICAgICB0aGlzLmRvbHBoaW4uZGVsZXRlUHJlc2VudGF0aW9uTW9kZWwobW9kZWwpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aGlzLmNsYXNzUmVwb3NpdG9yeS5sb2FkKG1vZGVsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbn07XG5cblxuQ29ubmVjdG9yLnByb3RvdHlwZS5vbk1vZGVsUmVtb3ZlZCA9IGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgY2hlY2tNZXRob2QoJ0Nvbm5lY3Rvci5vbk1vZGVsUmVtb3ZlZChtb2RlbCknKTtcbiAgICBjaGVja1BhcmFtKG1vZGVsLCAnbW9kZWwnKTtcblxuICAgIHZhciB0eXBlID0gbW9kZWwucHJlc2VudGF0aW9uTW9kZWxUeXBlO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIERPTFBISU5fQkVBTjpcbiAgICAgICAgICAgIHRoaXMuY2xhc3NSZXBvc2l0b3J5LnVucmVnaXN0ZXJDbGFzcyhtb2RlbCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBET0xQSElOX0xJU1RfU1BMSUNFOlxuICAgICAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aGlzLmNsYXNzUmVwb3NpdG9yeS51bmxvYWQobW9kZWwpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxufTtcblxuXG5Db25uZWN0b3IucHJvdG90eXBlLmludm9rZSA9IGZ1bmN0aW9uKGNvbW1hbmQpIHtcbiAgICBjaGVja01ldGhvZCgnQ29ubmVjdG9yLmludm9rZShjb21tYW5kKScpO1xuICAgIGNoZWNrUGFyYW0oY29tbWFuZCwgJ2NvbW1hbmQnKTtcblxuICAgIHZhciBkb2xwaGluID0gdGhpcy5kb2xwaGluO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgIGRvbHBoaW4uc2VuZChjb21tYW5kLCB7XG4gICAgICAgICAgICBvbkZpbmlzaGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcblxuXG5Db25uZWN0b3IucHJvdG90eXBlLmdldEhpZ2hsYW5kZXJQTSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmhpZ2hsYW5kZXJQTVByb21pc2U7XG59O1xuXG5cblxuZXhwb3J0cy5Db25uZWN0b3IgPSBDb25uZWN0b3I7XG5leHBvcnRzLlNPVVJDRV9TWVNURU0gPSBTT1VSQ0VfU1lTVEVNO1xuZXhwb3J0cy5TT1VSQ0VfU1lTVEVNX0NMSUVOVCA9IFNPVVJDRV9TWVNURU1fQ0xJRU5UO1xuZXhwb3J0cy5TT1VSQ0VfU1lTVEVNX1NFUlZFUiA9IFNPVVJDRV9TWVNURU1fU0VSVkVSO1xuZXhwb3J0cy5BQ1RJT05fQ0FMTF9CRUFOID0gQUNUSU9OX0NBTExfQkVBTjtcbiIsImV4cG9ydHMuRE9MUEhJTl9CRUFOID0gMDtcbmV4cG9ydHMuQllURSA9IDE7XG5leHBvcnRzLlNIT1JUID0gMjtcbmV4cG9ydHMuSU5UID0gMztcbmV4cG9ydHMuTE9ORyA9IDQ7XG5leHBvcnRzLkZMT0FUID0gNTtcbmV4cG9ydHMuRE9VQkxFID0gNjtcbmV4cG9ydHMuQk9PTEVBTiA9IDc7XG5leHBvcnRzLlNUUklORyA9IDg7XG5leHBvcnRzLkRBVEUgPSA5O1xuZXhwb3J0cy5FTlVNID0gMTA7XG4iLCIvKiBDb3B5cmlnaHQgMjAxNSBDYW5vbyBFbmdpbmVlcmluZyBBRy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLypqc2xpbnQgYnJvd3NlcmlmeTogdHJ1ZSAqL1xuLyogZ2xvYmFsIGNvbnNvbGUgKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoJy4uL2Jvd2VyX2NvbXBvbmVudHMvY29yZS5qcy9saWJyYXJ5L2ZuL3Byb21pc2UnKTtcbnZhciBTZXQgPSByZXF1aXJlKCcuLi9ib3dlcl9jb21wb25lbnRzL2NvcmUuanMvbGlicmFyeS9mbi9zZXQnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMuanMnKTtcbnZhciBleGlzdHMgPSB1dGlscy5leGlzdHM7XG52YXIgY2hlY2tNZXRob2QgPSB1dGlscy5jaGVja01ldGhvZDtcbnZhciBjaGVja1BhcmFtID0gdXRpbHMuY2hlY2tQYXJhbTtcblxudmFyIENvbnRyb2xsZXJQcm94eSA9IHJlcXVpcmUoJy4vY29udHJvbGxlcnByb3h5LmpzJykuQ29udHJvbGxlclByb3h5O1xuXG52YXIgU09VUkNFX1NZU1RFTSA9IHJlcXVpcmUoJy4vY29ubmVjdG9yLmpzJykuU09VUkNFX1NZU1RFTTtcbnZhciBTT1VSQ0VfU1lTVEVNX0NMSUVOVCA9IHJlcXVpcmUoJy4vY29ubmVjdG9yLmpzJykuU09VUkNFX1NZU1RFTV9DTElFTlQ7XG52YXIgQUNUSU9OX0NBTExfQkVBTiA9IHJlcXVpcmUoJy4vY29ubmVjdG9yLmpzJykuQUNUSU9OX0NBTExfQkVBTjtcblxudmFyIERPTFBISU5fUExBVEZPUk1fUFJFRklYID0gJ2RvbHBoaW5fcGxhdGZvcm1faW50ZXJuXyc7XG52YXIgUkVHSVNURVJfQ09OVFJPTExFUl9DT01NQU5EX05BTUUgPSBET0xQSElOX1BMQVRGT1JNX1BSRUZJWCArICdyZWdpc3RlckNvbnRyb2xsZXInO1xudmFyIENBTExfQ09OVFJPTExFUl9BQ1RJT05fQ09NTUFORF9OQU1FID0gRE9MUEhJTl9QTEFURk9STV9QUkVGSVggKyAnY2FsbENvbnRyb2xsZXJBY3Rpb24nO1xudmFyIERFU1RST1lfQ09OVFJPTExFUl9DT01NQU5EX05BTUUgPSBET0xQSElOX1BMQVRGT1JNX1BSRUZJWCArICdkZXN0cm95Q29udHJvbGxlcic7XG5cbnZhciBDT05UUk9MTEVSX05BTUUgPSAnY29udHJvbGxlck5hbWUnO1xudmFyIENPTlRST0xMRVJfSUQgPSAnY29udHJvbGxlcklkJztcbnZhciBNT0RFTCA9ICdtb2RlbCc7XG52YXIgQUNUSU9OX05BTUUgPSAnYWN0aW9uTmFtZSc7XG52YXIgRVJST1JfQ09ERSA9ICdlcnJvckNvZGUnO1xudmFyIFBBUkFNX1BSRUZJWCA9ICdfJztcblxuXG5mdW5jdGlvbiBDb250cm9sbGVyTWFuYWdlcihkb2xwaGluLCBjbGFzc1JlcG9zaXRvcnksIGNvbm5lY3Rvcikge1xuICAgIGNoZWNrTWV0aG9kKCdDb250cm9sbGVyTWFuYWdlcihkb2xwaGluLCBjbGFzc1JlcG9zaXRvcnksIGNvbm5lY3RvciknKTtcbiAgICBjaGVja1BhcmFtKGRvbHBoaW4sICdkb2xwaGluJyk7XG4gICAgY2hlY2tQYXJhbShjbGFzc1JlcG9zaXRvcnksICdjbGFzc1JlcG9zaXRvcnknKTtcbiAgICBjaGVja1BhcmFtKGNvbm5lY3RvciwgJ2Nvbm5lY3RvcicpO1xuXG4gICAgdGhpcy5kb2xwaGluID0gZG9scGhpbjtcbiAgICB0aGlzLmNsYXNzUmVwb3NpdG9yeSA9IGNsYXNzUmVwb3NpdG9yeTtcbiAgICB0aGlzLmNvbm5lY3RvciA9IGNvbm5lY3RvcjtcbiAgICB0aGlzLmNvbnRyb2xsZXJzID0gbmV3IFNldCgpO1xufVxuXG5cbkNvbnRyb2xsZXJNYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGVDb250cm9sbGVyID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGNoZWNrTWV0aG9kKCdDb250cm9sbGVyTWFuYWdlci5jcmVhdGVDb250cm9sbGVyKG5hbWUpJyk7XG4gICAgY2hlY2tQYXJhbShuYW1lLCAnbmFtZScpO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjb250cm9sbGVySWQsIG1vZGVsSWQsIG1vZGVsLCBjb250cm9sbGVyO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgIHNlbGYuY29ubmVjdG9yLmdldEhpZ2hsYW5kZXJQTSgpLnRoZW4oZnVuY3Rpb24gKGhpZ2hsYW5kZXJQTSkge1xuICAgICAgICAgICAgaGlnaGxhbmRlclBNLmZpbmRBdHRyaWJ1dGVCeVByb3BlcnR5TmFtZShDT05UUk9MTEVSX05BTUUpLnNldFZhbHVlKG5hbWUpO1xuICAgICAgICAgICAgc2VsZi5jb25uZWN0b3IuaW52b2tlKFJFR0lTVEVSX0NPTlRST0xMRVJfQ09NTUFORF9OQU1FKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXJJZCA9IGhpZ2hsYW5kZXJQTS5maW5kQXR0cmlidXRlQnlQcm9wZXJ0eU5hbWUoQ09OVFJPTExFUl9JRCkuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgICAgICBtb2RlbElkID0gaGlnaGxhbmRlclBNLmZpbmRBdHRyaWJ1dGVCeVByb3BlcnR5TmFtZShNT0RFTCkuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgICAgICBtb2RlbCA9IHNlbGYuY2xhc3NSZXBvc2l0b3J5Lm1hcERvbHBoaW5Ub0JlYW4obW9kZWxJZCk7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlciA9IG5ldyBDb250cm9sbGVyUHJveHkoY29udHJvbGxlcklkLCBtb2RlbCwgc2VsZik7XG4gICAgICAgICAgICAgICAgc2VsZi5jb250cm9sbGVycy5hZGQoY29udHJvbGxlcik7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShjb250cm9sbGVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5cblxuQ29udHJvbGxlck1hbmFnZXIucHJvdG90eXBlLmludm9rZUFjdGlvbiA9IGZ1bmN0aW9uKGNvbnRyb2xsZXJJZCwgYWN0aW9uTmFtZSwgcGFyYW1zKSB7XG4gICAgY2hlY2tNZXRob2QoJ0NvbnRyb2xsZXJNYW5hZ2VyLmludm9rZUFjdGlvbihjb250cm9sbGVySWQsIGFjdGlvbk5hbWUsIHBhcmFtcyknKTtcbiAgICBjaGVja1BhcmFtKGNvbnRyb2xsZXJJZCwgJ2NvbnRyb2xsZXJJZCcpO1xuICAgIGNoZWNrUGFyYW0oYWN0aW9uTmFtZSwgJ2FjdGlvbk5hbWUnKTtcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBbXG4gICAgICAgICAgICBzZWxmLmRvbHBoaW4uYXR0cmlidXRlKFNPVVJDRV9TWVNURU0sIG51bGwsIFNPVVJDRV9TWVNURU1fQ0xJRU5UKSxcbiAgICAgICAgICAgIHNlbGYuZG9scGhpbi5hdHRyaWJ1dGUoQ09OVFJPTExFUl9JRCwgbnVsbCwgY29udHJvbGxlcklkKSxcbiAgICAgICAgICAgIHNlbGYuZG9scGhpbi5hdHRyaWJ1dGUoQUNUSU9OX05BTUUsIG51bGwsIGFjdGlvbk5hbWUpLFxuICAgICAgICAgICAgc2VsZi5kb2xwaGluLmF0dHJpYnV0ZShFUlJPUl9DT0RFKVxuICAgICAgICBdO1xuXG4gICAgICAgIGlmIChleGlzdHMocGFyYW1zKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbSA9IHNlbGYuY2xhc3NSZXBvc2l0b3J5Lm1hcFBhcmFtVG9Eb2xwaGluKHBhcmFtc1twcm9wXSk7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMucHVzaChzZWxmLmRvbHBoaW4uYXR0cmlidXRlKFBBUkFNX1BSRUZJWCArIHByb3AsIG51bGwsIHBhcmFtLCAnVkFMVUUnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBtID0gc2VsZi5kb2xwaGluLnByZXNlbnRhdGlvbk1vZGVsLmFwcGx5KHNlbGYuZG9scGhpbiwgW251bGwsIEFDVElPTl9DQUxMX0JFQU5dLmNvbmNhdChhdHRyaWJ1dGVzKSk7XG5cbiAgICAgICAgc2VsZi5jb25uZWN0b3IuaW52b2tlKENBTExfQ09OVFJPTExFUl9BQ1RJT05fQ09NTUFORF9OQU1FLCBwYXJhbXMpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaXNFcnJvciA9IHBtLmZpbmRBdHRyaWJ1dGVCeVByb3BlcnR5TmFtZShFUlJPUl9DT0RFKS5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgaWYgKGlzRXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiQ29udHJvbGxlckFjdGlvbiBjYXVzZWQgYW4gZXJyb3JcIikpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLmRvbHBoaW4uZGVsZXRlUHJlc2VudGF0aW9uTW9kZWwocG0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5cblxuQ29udHJvbGxlck1hbmFnZXIucHJvdG90eXBlLmRlc3Ryb3lDb250cm9sbGVyID0gZnVuY3Rpb24oY29udHJvbGxlcikge1xuICAgIGNoZWNrTWV0aG9kKCdDb250cm9sbGVyTWFuYWdlci5kZXN0cm95Q29udHJvbGxlcihjb250cm9sbGVyKScpO1xuICAgIGNoZWNrUGFyYW0oY29udHJvbGxlciwgJ2NvbnRyb2xsZXInKTtcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICBzZWxmLmNvbm5lY3Rvci5nZXRIaWdobGFuZGVyUE0oKS50aGVuKGZ1bmN0aW9uIChoaWdobGFuZGVyUE0pIHtcbiAgICAgICAgICAgIHNlbGYuY29udHJvbGxlcnMuZGVsZXRlKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgaGlnaGxhbmRlclBNLmZpbmRBdHRyaWJ1dGVCeVByb3BlcnR5TmFtZShDT05UUk9MTEVSX0lEKS5zZXRWYWx1ZShjb250cm9sbGVyLmNvbnRyb2xsZXJJZCk7XG4gICAgICAgICAgICBzZWxmLmNvbm5lY3Rvci5pbnZva2UoREVTVFJPWV9DT05UUk9MTEVSX0NPTU1BTkRfTkFNRSkudGhlbihyZXNvbHZlKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuXG5cbkNvbnRyb2xsZXJNYW5hZ2VyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvbnRyb2xsZXJzQ29weSA9IHRoaXMuY29udHJvbGxlcnM7XG4gICAgdmFyIHByb21pc2VzID0gW107XG4gICAgdGhpcy5jb250cm9sbGVycyA9IG5ldyBTZXQoKTtcbiAgICBjb250cm9sbGVyc0NvcHkuZm9yRWFjaChmdW5jdGlvbiAoY29udHJvbGxlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChjb250cm9sbGVyLmRlc3Ryb3koKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIGlnbm9yZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbn07XG5cblxuXG5leHBvcnRzLkNvbnRyb2xsZXJNYW5hZ2VyID0gQ29udHJvbGxlck1hbmFnZXI7XG4iLCIvKiBDb3B5cmlnaHQgMjAxNSBDYW5vbyBFbmdpbmVlcmluZyBBRy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLypqc2xpbnQgYnJvd3NlcmlmeTogdHJ1ZSAqL1xuLyogZ2xvYmFsIGNvbnNvbGUgKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgU2V0ID0gcmVxdWlyZSgnLi4vYm93ZXJfY29tcG9uZW50cy9jb3JlLmpzL2xpYnJhcnkvZm4vc2V0Jyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzLmpzJyk7XG52YXIgY2hlY2tNZXRob2QgPSB1dGlscy5jaGVja01ldGhvZDtcbnZhciBjaGVja1BhcmFtID0gdXRpbHMuY2hlY2tQYXJhbTtcblxuXG5cbmZ1bmN0aW9uIENvbnRyb2xsZXJQcm94eShjb250cm9sbGVySWQsIG1vZGVsLCBtYW5hZ2VyKSB7XG4gICAgY2hlY2tNZXRob2QoJ0NvbnRyb2xsZXJQcm94eShjb250cm9sbGVySWQsIG1vZGVsLCBtYW5hZ2VyKScpO1xuICAgIGNoZWNrUGFyYW0oY29udHJvbGxlcklkLCAnY29udHJvbGxlcklkJyk7XG4gICAgY2hlY2tQYXJhbShtb2RlbCwgJ21vZGVsJyk7XG4gICAgY2hlY2tQYXJhbShtYW5hZ2VyLCAnbWFuYWdlcicpO1xuXG4gICAgdGhpcy5jb250cm9sbGVySWQgPSBjb250cm9sbGVySWQ7XG4gICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgIHRoaXMubWFuYWdlciA9IG1hbmFnZXI7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLm9uRGVzdHJveWVkSGFuZGxlcnMgPSBuZXcgU2V0KCk7XG59XG5cblxuQ29udHJvbGxlclByb3h5LnByb3RvdHlwZS5pbnZva2UgPSBmdW5jdGlvbihuYW1lLCBwYXJhbXMpIHtcbiAgICBjaGVja01ldGhvZCgnQ29udHJvbGxlclByb3h5Lmludm9rZShuYW1lLCBwYXJhbXMpJyk7XG4gICAgY2hlY2tQYXJhbShuYW1lLCAnbmFtZScpO1xuXG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGNvbnRyb2xsZXIgd2FzIGFscmVhZHkgZGVzdHJveWVkJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1hbmFnZXIuaW52b2tlQWN0aW9uKHRoaXMuY29udHJvbGxlcklkLCBuYW1lLCBwYXJhbXMpO1xufTtcblxuXG5Db250cm9sbGVyUHJveHkucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY29udHJvbGxlciB3YXMgYWxyZWFkeSBkZXN0cm95ZWQnKTtcbiAgICB9XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIHRoaXMub25EZXN0cm95ZWRIYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGhhbmRsZXIodGhpcyk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdBbiBleGNlcHRpb24gb2NjdXJyZWQgd2hpbGUgY2FsbGluZyBhbiBvbkRlc3Ryb3llZC1oYW5kbGVyJywgZSk7XG4gICAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5tYW5hZ2VyLmRlc3Ryb3lDb250cm9sbGVyKHRoaXMpO1xufTtcblxuXG5Db250cm9sbGVyUHJveHkucHJvdG90eXBlLm9uRGVzdHJveWVkID0gZnVuY3Rpb24oaGFuZGxlcikge1xuICAgIGNoZWNrTWV0aG9kKCdDb250cm9sbGVyUHJveHkub25EZXN0cm95ZWQoaGFuZGxlciknKTtcbiAgICBjaGVja1BhcmFtKGhhbmRsZXIsICdoYW5kbGVyJyk7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5vbkRlc3Ryb3llZEhhbmRsZXJzLmFkZChoYW5kbGVyKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB1bnN1YnNjcmliZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLm9uRGVzdHJveWVkSGFuZGxlcnMuZGVsZXRlKGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cblxuXG5leHBvcnRzLkNvbnRyb2xsZXJQcm94eSA9IENvbnRyb2xsZXJQcm94eTtcbiIsIi8qIENvcHlyaWdodCAyMDE1IENhbm9vIEVuZ2luZWVyaW5nIEFHLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKmpzbGludCBicm93c2VyaWZ5OiB0cnVlICovXG4vKiBnbG9iYWwgY29uc29sZSAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnJlcXVpcmUoJ2JhYmVsLXBvbHlmaWxsJyk7XG52YXIgT3BlbkRvbHBoaW4gPSByZXF1aXJlKCcuLi9vcGVuZG9scGhpbi9idWlsZC9PcGVuRG9scGhpbi5qcycpO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzLmpzJyk7XG52YXIgZXhpc3RzID0gdXRpbHMuZXhpc3RzO1xudmFyIGNoZWNrTWV0aG9kID0gdXRpbHMuY2hlY2tNZXRob2Q7XG52YXIgY2hlY2tQYXJhbSA9IHV0aWxzLmNoZWNrUGFyYW07XG52YXIgQ29ubmVjdG9yID0gcmVxdWlyZSgnLi9jb25uZWN0b3IuanMnKS5Db25uZWN0b3I7XG52YXIgQmVhbk1hbmFnZXIgPSByZXF1aXJlKCcuL2JlYW5tYW5hZ2VyLmpzJykuQmVhbk1hbmFnZXI7XG52YXIgQ2xhc3NSZXBvc2l0b3J5ID0gcmVxdWlyZSgnLi9jbGFzc3JlcG8uanMnKS5DbGFzc1JlcG9zaXRvcnk7XG52YXIgQ29udHJvbGxlck1hbmFnZXIgPSByZXF1aXJlKCcuL2NvbnRyb2xsZXJtYW5hZ2VyLmpzJykuQ29udHJvbGxlck1hbmFnZXI7XG52YXIgQ2xpZW50Q29udGV4dCA9IHJlcXVpcmUoJy4vY2xpZW50Y29udGV4dC5qcycpLkNsaWVudENvbnRleHQ7XG52YXIgSHR0cFRyYW5zbWl0dGVyID0gcmVxdWlyZSgnLi9odHRwVHJhbnNtaXR0ZXIuZXM2JykuZGVmYXVsdDtcblxuZXhwb3J0cy5jb25uZWN0ID0gZnVuY3Rpb24gKHVybCwgY29uZmlnKSB7XG4gICAgY2hlY2tNZXRob2QoJ2Nvbm5lY3QodXJsLCBjb25maWcpJyk7XG4gICAgY2hlY2tQYXJhbSh1cmwsICd1cmwnKTtcblxuICAgIHZhciBidWlsZGVyID0gT3BlbkRvbHBoaW4ubWFrZURvbHBoaW4oKS51cmwodXJsKS5yZXNldChmYWxzZSkuc2xhY2tNUyg0KS5zdXBwb3J0Q09SUyh0cnVlKS5tYXhCYXRjaFNpemUoTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpO1xuICAgIGlmIChleGlzdHMoY29uZmlnKSkge1xuICAgICAgICBpZiAoZXhpc3RzKGNvbmZpZy5lcnJvckhhbmRsZXIpKSB7XG4gICAgICAgICAgICBidWlsZGVyLmVycm9ySGFuZGxlcihjb25maWcuZXJyb3JIYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhpc3RzKGNvbmZpZy5oZWFkZXJzSW5mbykgJiYgIE9iamVjdC5rZXlzKGNvbmZpZy5oZWFkZXJzSW5mbyApLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgYnVpbGRlci5oZWFkZXJzSW5mbyhjb25maWcuaGVhZGVyc0luZm8pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRvbHBoaW4gPSBidWlsZGVyLmJ1aWxkKCk7XG5cbiAgICB2YXIgdHJhbnNtaXR0ZXIgPSBuZXcgSHR0cFRyYW5zbWl0dGVyKHVybCwgZXhpc3RzKGNvbmZpZyk/Y29uZmlnLmhlYWRlcnNJbmZvIDogbnVsbCk7XG4gICAgdHJhbnNtaXR0ZXIub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGNsaWVudENvbnRleHQuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgfSk7XG4gICAgZG9scGhpbi5jbGllbnRDb25uZWN0b3IudHJhbnNtaXR0ZXIgPSB0cmFuc21pdHRlcjtcblxuICAgIHZhciBjbGFzc1JlcG9zaXRvcnkgPSBuZXcgQ2xhc3NSZXBvc2l0b3J5KGRvbHBoaW4pO1xuICAgIHZhciBiZWFuTWFuYWdlciA9IG5ldyBCZWFuTWFuYWdlcihjbGFzc1JlcG9zaXRvcnkpO1xuICAgIHZhciBjb25uZWN0b3IgPSBuZXcgQ29ubmVjdG9yKHVybCwgZG9scGhpbiwgY2xhc3NSZXBvc2l0b3J5LCBjb25maWcpO1xuICAgIHZhciBjb250cm9sbGVyTWFuYWdlciA9IG5ldyBDb250cm9sbGVyTWFuYWdlcihkb2xwaGluLCBjbGFzc1JlcG9zaXRvcnksIGNvbm5lY3Rvcik7XG5cbiAgICB2YXIgY2xpZW50Q29udGV4dCA9IG5ldyBDbGllbnRDb250ZXh0KGRvbHBoaW4sIGJlYW5NYW5hZ2VyLCBjb250cm9sbGVyTWFuYWdlciwgY29ubmVjdG9yKTtcbiAgICByZXR1cm4gY2xpZW50Q29udGV4dDtcbn07XG4iLCJleHBvcnQgY2xhc3MgRG9scGhpblJlbW90aW5nRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UgPSAnTmV0d29yayBFcnJvcicsIGRldGFpbCkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuZGV0YWlsID0gZGV0YWlsIHx8IHVuZGVmaW5lZDtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgRG9scGhpblNlc3Npb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSA9ICdTZXNzaW9uIEVycm9yJykge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBIdHRwUmVzcG9uc2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSA9ICdIdHRwIFJlc3BvbnNlIEVycm9yJykge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICB9XG59IiwiLyogQ29weXJpZ2h0IDIwMTYgQ2Fub28gRW5naW5lZXJpbmcgQUcuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBFbWl0dGVyIGZyb20gJ2VtaXR0ZXItY29tcG9uZW50JztcblxuXG5pbXBvcnQgeyBleGlzdHMgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IERvbHBoaW5SZW1vdGluZ0Vycm9yLCBEb2xwaGluU2Vzc2lvbkVycm9yLCBIdHRwUmVzcG9uc2VFcnJvciB9IGZyb20gJy4vZXJyb3JzLmVzNic7XG5pbXBvcnQgeyBlbmNvZGUsIGRlY29kZSB9IGZyb20gJy4vY29kZWMuZXM2JztcblxuXG5jb25zdCBGSU5JU0hFRCA9IDQ7XG5jb25zdCBTVUNDRVNTID0gMjAwO1xuY29uc3QgUkVRVUVTVF9USU1FT1VUID0gNDA4O1xuXG5jb25zdCBET0xQSElOX1BMQVRGT1JNX1BSRUZJWCA9ICdkb2xwaGluX3BsYXRmb3JtX2ludGVybl8nO1xuY29uc3QgQ0xJRU5UX0lEX0hUVFBfSEVBREVSX05BTUUgPSBET0xQSElOX1BMQVRGT1JNX1BSRUZJWCArICdkb2xwaGluQ2xpZW50SWQnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIdHRwVHJhbnNtaXR0ZXIge1xuXG4gICAgY29uc3RydWN0b3IodXJsLCBoZWFkZXJzSW5mbykge1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgdGhpcy5oZWFkZXJzSW5mbyA9IGhlYWRlcnNJbmZvO1xuICAgIH1cblxuICAgIHNlbmQoY29tbWFuZHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGh0dHAgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgIGh0dHAud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICAgICAgICAgIGh0dHAub25lcnJvciA9IChlcnJvcikgPT4gcmVqZWN0KG5ldyBEb2xwaGluUmVtb3RpbmdFcnJvcignSHR0cFRyYW5zbWl0dGVyOiBOZXR3b3JrIGVycm9yJywgZXJyb3IpKTtcbiAgICAgICAgICAgIGh0dHAub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChodHRwLnJlYWR5U3RhdGUgPT09IEZJTklTSEVEKXtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChodHRwLnN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBTVUNDRVNTOlxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRDbGllbnRJZCA9IGh0dHAuZ2V0UmVzcG9uc2VIZWFkZXIoQ0xJRU5UX0lEX0hUVFBfSEVBREVSX05BTUUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleGlzdHMoY3VycmVudENsaWVudElkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhpc3RzKHRoaXMuY2xpZW50SWQpICYmIHRoaXMuY2xpZW50SWQgIT09IGN1cnJlbnRDbGllbnRJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBEb2xwaGluU2Vzc2lvbkVycm9yKCdIdHRwVHJhbnNtaXR0ZXI6IENsaWVudElkIG9mIHRoZSByZXNwb25zZSBkaWQgbm90IG1hdGNoJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xpZW50SWQgPSBjdXJyZW50Q2xpZW50SWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBEb2xwaGluU2Vzc2lvbkVycm9yKCdIdHRwVHJhbnNtaXR0ZXI6IFNlcnZlciBkaWQgbm90IHNlbmQgYSBjbGllbnRJZCcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShodHRwLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUkVRVUVTVF9USU1FT1VUOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRG9scGhpblNlc3Npb25FcnJvcignSHR0cFRyYW5zbWl0dGVyOiBTZXNzaW9uIFRpbWVvdXQnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBIdHRwUmVzcG9uc2VFcnJvcignSHR0cFRyYW5zbWl0dGVyOiBIVFRQIFN0YXR1cyAhPSAyMDAgKCcgKyBodHRwLnN0YXR1cyArICcpJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaHR0cC5vcGVuKCdQT1NUJywgdGhpcy51cmwpO1xuICAgICAgICAgICAgaWYgKGV4aXN0cyh0aGlzLmNsaWVudElkKSkge1xuICAgICAgICAgICAgICAgIGh0dHAuc2V0UmVxdWVzdEhlYWRlcihDTElFTlRfSURfSFRUUF9IRUFERVJfTkFNRSwgdGhpcy5jbGllbnRJZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChleGlzdHModGhpcy5oZWFkZXJzSW5mbykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuaGVhZGVyc0luZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGVhZGVyc0luZm8uaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0dHAuc2V0UmVxdWVzdEhlYWRlcihpLCB0aGlzLmhlYWRlcnNJbmZvW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGh0dHAuc2VuZChlbmNvZGUoY29tbWFuZHMpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdHJhbnNtaXQoY29tbWFuZHMsIG9uRG9uZSkge1xuICAgICAgICB0aGlzLnNlbmQoY29tbWFuZHMpXG4gICAgICAgICAgICAudGhlbihyZXNwb25zZVRleHQgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZVRleHQudHJpbSgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQ29tbWFuZHMgPSBkZWNvZGUocmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRG9uZShyZXNwb25zZUNvbW1hbmRzKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEh0dHBSZXNwb25zZUVycm9yKCdIdHRwVHJhbnNtaXR0ZXI6IFBhcnNlIGVycm9yOiAoSW5jb3JyZWN0IHJlc3BvbnNlID0gJyArIHJlc3BvbnNlVGV4dCArICcpJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb25Eb25lKFtdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgSHR0cFJlc3BvbnNlRXJyb3IoJ0h0dHBUcmFuc21pdHRlcjogRW1wdHkgcmVzcG9uc2UnKSk7XG4gICAgICAgICAgICAgICAgICAgIG9uRG9uZShbXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgICAgICAgICBvbkRvbmUoW10pO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc2lnbmFsKGNvbW1hbmQpIHtcbiAgICAgICAgdGhpcy5zZW5kKFtjb21tYW5kXSlcbiAgICAgICAgICAgIC5jYXRjaChlcnJvciA9PiB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgcmVzZXQoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSHR0cFRyYW5zbWl0dGVyLnJlc2V0KCkgaGFzIGJlZW4gZGVwcmVjYXRlZCcpO1xuICAgIH1cbn1cblxuRW1pdHRlcihIdHRwVHJhbnNtaXR0ZXIucHJvdG90eXBlKTtcbiIsIi8qIENvcHlyaWdodCAyMDE1IENhbm9vIEVuZ2luZWVyaW5nIEFHLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKmpzbGludCBicm93c2VyaWZ5OiB0cnVlICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGNoZWNrTWV0aG9kTmFtZTtcblxudmFyIGV4aXN0cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ICE9PSAndW5kZWZpbmVkJyAmJiBvYmplY3QgIT09IG51bGw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5leGlzdHMgPSBleGlzdHM7XG5cbm1vZHVsZS5leHBvcnRzLmNoZWNrTWV0aG9kID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGNoZWNrTWV0aG9kTmFtZSA9IG5hbWU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5jaGVja1BhcmFtID0gZnVuY3Rpb24ocGFyYW0sIHBhcmFtZXRlck5hbWUpIHtcbiAgICBpZiAoIWV4aXN0cyhwYXJhbSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcGFyYW1ldGVyICcgKyBwYXJhbWV0ZXJOYW1lICsgJyBpcyBtYW5kYXRvcnkgaW4gJyArIGNoZWNrTWV0aG9kTmFtZSk7XG4gICAgfVxufTtcbiIsIi8qIENvcHlyaWdodCAyMDE1IENhbm9vIEVuZ2luZWVyaW5nIEFHLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xudmFyIGRvbHBoaW5DbGllbnQgPSByZXF1aXJlKCcuLi9ib3dlcl9jb21wb25lbnRzL2RvbHBoaW4tcGxhdGZvcm0tanMvZGlzdC9kb2xwaGluLXBsYXRmb3JtLmpzJyk7XG5hbmd1bGFyLm1vZHVsZSgnRG9scGhpblBsYXRmb3JtJywgW10pO1xuXG5hbmd1bGFyLm1vZHVsZSgnRG9scGhpblBsYXRmb3JtJykucHJvdmlkZXIoJyRkb2xwaGluQ29uZmlnJywgW2Z1bmN0aW9uICgpIHtcblxuICAgIHZhciAkY2ZnID0ge307XG4gICAgdGhpcy5jb25maWd1cmUgPSBmdW5jdGlvbiAoY2ZnKSB7XG4gICAgICAgICRjZmcgPSBjZmc7XG4gICAgfTtcblxuICAgIHRoaXMuJGdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICRjZmc7XG4gICAgfTtcblxufV0pO1xuXG5hbmd1bGFyLm1vZHVsZSgnRG9scGhpblBsYXRmb3JtJykuZmFjdG9yeSgnZG9scGhpbicsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZG9scGhpbkNsaWVudDtcbn0pO1xuXG5hbmd1bGFyLm1vZHVsZSgnRG9scGhpblBsYXRmb3JtJykuZmFjdG9yeSgndmFuaWxsYUNsaWVudENvbnRleHQnLCBbJ2RvbHBoaW4nLCAnJGRvbHBoaW5Db25maWcnLCAnJHdpbmRvdycsICckbG9nJywgZnVuY3Rpb24gKGRvbHBoaW4sICRkb2xwaGluQ29uZmlnLCAkd2luZG93LCAkbG9nKSB7XG4gICAgdmFyIHZhbmlsbGFDbGllbnRDb250ZXh0ID0gZG9scGhpbi5jb25uZWN0KCRkb2xwaGluQ29uZmlnLkRPTFBISU5fVVJMLCAkZG9scGhpbkNvbmZpZyk7XG4gICAgJGxvZy5kZWJ1ZygnQmFzaWMgRG9scGhpbiBQbGF0Zm9ybSBjb250ZXh0IGNyZWF0ZWQnKTtcbiAgICByZXR1cm4gdmFuaWxsYUNsaWVudENvbnRleHQ7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKCdEb2xwaGluUGxhdGZvcm0nKS5mYWN0b3J5KCdkb2xwaGluQmluZGluZycsIFsnJHJvb3RTY29wZScsICckdGltZW91dCcsICd2YW5pbGxhQ2xpZW50Q29udGV4dCcsICckbG9nJywgZnVuY3Rpb24gKCRyb290U2NvcGUsICR0aW1lb3V0LCB2YW5pbGxhQ2xpZW50Q29udGV4dCwgJGxvZykge1xuXG4gICAgJHJvb3RTY29wZS53YWl0aW5nRm9yR2xvYmFsRG9scGhpbkFwcGx5ID0gZmFsc2U7XG5cbiAgICAkcm9vdFNjb3BlLmFwcGx5SW5Bbmd1bGFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoISRyb290U2NvcGUud2FpdGluZ0Zvckdsb2JhbERvbHBoaW5BcHBseSkge1xuICAgICAgICAgICAgJHJvb3RTY29wZS53YWl0aW5nRm9yR2xvYmFsRG9scGhpbkFwcGx5ID0gdHJ1ZTtcbiAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLndhaXRpbmdGb3JHbG9iYWxEb2xwaGluQXBwbHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAkbG9nLmRlYnVnKCdBbmd1bGFyIGFwcGx5IGlzIGNhbGxlZCBieSBEb2xwaGluIFBsYXRmb3JtJyk7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYXBwbHkoKTtcbiAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGRvbHBoaW5CaW5kaW5nID0ge1xuXG4gICAgICAgIGluamVjdEFycmF5OiBmdW5jdGlvbiAoYmFzZUFycmF5LCBzdGFydEluZGV4LCBpbnNlcnRBcnJheSkge1xuICAgICAgICAgICAgYmFzZUFycmF5LnNwbGljZS5hcHBseShiYXNlQXJyYXksIFtzdGFydEluZGV4LCAwXS5jb25jYXQoaW5zZXJ0QXJyYXkpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZXhpc3RzOiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIG9iamVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgb2JqZWN0ICE9PSBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBkZWVwRXF1YWw6IGZ1bmN0aW9uIChhcnJheTEsIGFycmF5Mikge1xuICAgICAgICAgICAgaWYgKGFycmF5MSA9PT0gYXJyYXkyIHx8ICghdGhpcy5leGlzdHMoYXJyYXkxKSAmJiAhdGhpcy5leGlzdHMoYXJyYXkyKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmV4aXN0cyhhcnJheTEpICE9PSB0aGlzLmV4aXN0cyhhcnJheTIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG4gPSBhcnJheTEubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGFycmF5Mi5sZW5ndGggIT09IG4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChhcnJheTFbaV0gIT09IGFycmF5MltpXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uIChiZWFuTWFuYWdlcikge1xuICAgICAgICAgICAgYmVhbk1hbmFnZXIub25BZGRlZChkb2xwaGluQmluZGluZy5vbkJlYW5BZGRlZEhhbmRsZXIpO1xuICAgICAgICAgICAgYmVhbk1hbmFnZXIub25SZW1vdmVkKGRvbHBoaW5CaW5kaW5nLm9uQmVhblJlbW92ZWRIYW5kbGVyKTtcbiAgICAgICAgICAgIGJlYW5NYW5hZ2VyLm9uQmVhblVwZGF0ZShkb2xwaGluQmluZGluZy5vbkJlYW5VcGRhdGVIYW5kbGVyKTtcbiAgICAgICAgICAgIGJlYW5NYW5hZ2VyLm9uQXJyYXlVcGRhdGUoZG9scGhpbkJpbmRpbmcub25BcnJheVVwZGF0ZUhhbmRsZXIpO1xuXG4gICAgICAgICAgICAkbG9nLmRlYnVnKCdEb2xwaGluIFBsYXRmb3JtIGJpbmRpbmcgbGlzdGVuZXJzIGZvciBBbmd1bGFyIHJlZ2lzdGVyZWQnKTtcbiAgICAgICAgfSxcbiAgICAgICAgd2F0Y2hBdHRyaWJ1dGU6IGZ1bmN0aW9uIChiZWFuLCBhdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICRsb2cuZGVidWcoJ0FkZGVkIEFuZ3VsYXIgbGlzdGVuZXIgZm9yIHByb3BlcnR5ICcgKyBhdHRyaWJ1dGUgKyAgJyBvZiBiZWFuICcgKyBKU09OLnN0cmluZ2lmeShiZWFuKSk7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLiR3YXRjaChcbiAgICAgICAgICAgICAgICBmdW5jdGlvbigpIHsgcmV0dXJuIGJlYW5bYXR0cmlidXRlXTsgfSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbihuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgJGxvZy5kZWJ1ZygnVmFsdWUgJyArIGF0dHJpYnV0ZSArICcgb2YgYmVhbiAnICsgSlNPTi5zdHJpbmdpZnkoYmVhbikgKycgY2hhbmdlZCBmcm9tICcrIG9sZFZhbHVlKyAnIHRvICcgKyBuZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbmlsbGFDbGllbnRDb250ZXh0LmJlYW5NYW5hZ2VyLmNsYXNzUmVwb3NpdG9yeS5ub3RpZnlCZWFuQ2hhbmdlKGJlYW4sIGF0dHJpYnV0ZSwgbmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQmVhbkFkZGVkSGFuZGxlcjogZnVuY3Rpb24oYmVhbikge1xuICAgICAgICAgICAgJGxvZy5kZWJ1ZygnQmVhbiAnICsgSlNPTi5zdHJpbmdpZnkoYmVhbikgKyAnIGFkZGVkJyk7XG5cbiAgICAgICAgICAgIGZvcih2YXIgYXR0ciBpbiBiZWFuKSB7XG4gICAgICAgICAgICAgICAgZG9scGhpbkJpbmRpbmcud2F0Y2hBdHRyaWJ1dGUoYmVhbiwgYXR0cik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICRyb290U2NvcGUuYXBwbHlJbkFuZ3VsYXIoKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25CZWFuUmVtb3ZlZEhhbmRsZXI6IGZ1bmN0aW9uKGJlYW4pIHtcbiAgICAgICAgICAgICRsb2cuZGVidWcoJ0JlYW4gJyArIEpTT04uc3RyaW5naWZ5KGJlYW4pICsgJyByZW1vdmVkJyk7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLmFwcGx5SW5Bbmd1bGFyKCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQmVhblVwZGF0ZUhhbmRsZXI6IGZ1bmN0aW9uIChiZWFuLCBwcm9wZXJ0eU5hbWUsIG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIG5ld1Byb3BlcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvcih2YXIgYXR0ciBpbiBiZWFuKSB7XG4gICAgICAgICAgICAgICAgaWYoYXR0ciA9PT0gcHJvcGVydHlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1Byb3BlcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihuZXdQcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgICRsb2cuZGVidWcoJ1ZhbHVlICcgKyBwcm9wZXJ0eU5hbWUgKyAnIHdhcyBhZGRlZCB0byBiZWFuICcgKyBKU09OLnN0cmluZ2lmeShiZWFuKSk7XG4gICAgICAgICAgICAgICAgZG9scGhpbkJpbmRpbmcud2F0Y2hBdHRyaWJ1dGUoYmVhbiwgcHJvcGVydHlOYW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9sZFZhbHVlID09PSBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgICRsb2cuZGVidWcoJ1JlY2VpdmVkIGJlYW4gdXBkYXRlIGZvciBwcm9wZXJ0eSAnICsgcHJvcGVydHlOYW1lICsgJyB3aXRob3V0IGFueSBjaGFuZ2UnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICRsb2cuZGVidWcoJ0JlYW4gdXBkYXRlIGZvciBwcm9wZXJ0eSAnICsgcHJvcGVydHlOYW1lICsgJyB3aXRoIG5ldyB2YWx1ZSBcIicgKyBuZXdWYWx1ZSArICdcIicpO1xuXG4gICAgICAgICAgICBiZWFuW3Byb3BlcnR5TmFtZV0gPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICRyb290U2NvcGUuYXBwbHlJbkFuZ3VsYXIoKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25BcnJheVVwZGF0ZUhhbmRsZXI6IGZ1bmN0aW9uIChiZWFuLCBwcm9wZXJ0eU5hbWUsIGluZGV4LCBjb3VudCwgbmV3RWxlbWVudHMpIHtcbiAgICAgICAgICAgIHZhciBhcnJheSA9IGJlYW5bcHJvcGVydHlOYW1lXTtcbiAgICAgICAgICAgIHZhciBvbGRFbGVtZW50cyA9IGFycmF5LnNsaWNlKGluZGV4LCBpbmRleCArIGNvdW50KTtcbiAgICAgICAgICAgIGlmIChkb2xwaGluQmluZGluZy5kZWVwRXF1YWwobmV3RWxlbWVudHMsIG9sZEVsZW1lbnRzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgJGxvZy5kZWJ1ZygnQXJyYXkgdXBkYXRlIGZvciBwcm9wZXJ0eSAnICsgcHJvcGVydHlOYW1lICsgJyBzdGFydGluZyBhdCBpbmRleCAnICsgaW5kZXggKyAnIHdpdGggJyArIEpTT04uc3RyaW5naWZ5KG5ld0VsZW1lbnRzKSk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmV3RWxlbWVudHMgPT09ICd1bmRlZmluZWQnIHx8IChuZXdFbGVtZW50cyAmJiBuZXdFbGVtZW50cy5sZW5ndGggPT09IDApKSB7XG4gICAgICAgICAgICAgICAgYXJyYXkuc3BsaWNlKGluZGV4LCBjb3VudCk7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5hcHBseUluQW5ndWxhcigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkb2xwaGluQmluZGluZy5pbmplY3RBcnJheShhcnJheSwgaW5kZXgsIG5ld0VsZW1lbnRzKTtcblxuICAgICAgICAgICAgICAgIGZvcihiZWFuIGluIG5ld0VsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgYXR0ciBpbiBiZWFuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2xwaGluQmluZGluZy53YXRjaEF0dHJpYnV0ZShiZWFuLCBhdHRyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICRyb290U2NvcGUuYXBwbHlJbkFuZ3VsYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAkbG9nLmRlYnVnKCdEb2xwaGluIFBsYXRmb3JtIGJpbmRpbmcgY3JlYXRlZCcpO1xuXG4gICAgcmV0dXJuIGRvbHBoaW5CaW5kaW5nO1xuXG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKCdEb2xwaGluUGxhdGZvcm0nKS5mYWN0b3J5KCdjbGllbnRDb250ZXh0JywgWyd2YW5pbGxhQ2xpZW50Q29udGV4dCcsICdkb2xwaGluQmluZGluZycsICckd2luZG93JywgJyRsb2cnLCBmdW5jdGlvbiAodmFuaWxsYUNsaWVudENvbnRleHQsIGRvbHBoaW5CaW5kaW5nLCAkd2luZG93LCAkbG9nKSB7XG4gICAgdmFyIGNsaWVudENvbnRleHQgPSB7XG4gICAgICAgIGNyZWF0ZUNvbnRyb2xsZXI6IGZ1bmN0aW9uIChzY29wZSwgY29udHJvbGxlck5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YW5pbGxhQ2xpZW50Q29udGV4dC5jcmVhdGVDb250cm9sbGVyKGNvbnRyb2xsZXJOYW1lKS50aGVuKGZ1bmN0aW9uIChjb250cm9sbGVyUHJveHkpIHtcbiAgICAgICAgICAgICAgICAkbG9nLmRlYnVnKCdDcmVhdGluZyBEb2xwaGluIFBsYXRmb3JtIGNvbnRyb2xsZXIgJyArIGNvbnRyb2xsZXJOYW1lKTtcbiAgICAgICAgICAgICAgICBzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAkbG9nLmRlYnVnKCdEZXN0cm95aW5nIERvbHBoaW4gUGxhdGZvcm0gY29udHJvbGxlciAnICsgY29udHJvbGxlck5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyUHJveHkuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNjb3BlLm1vZGVsID0gY29udHJvbGxlclByb3h5Lm1vZGVsO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyUHJveHk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZGlzY29ubmVjdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFuaWxsYUNsaWVudENvbnRleHQuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgJGxvZy5kZWJ1ZygnRG9scGhpbiBQbGF0Zm9ybSBjb250ZXh0IGRpc2Nvbm5lY3RlZCcpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGRvbHBoaW5CaW5kaW5nLmluaXQodmFuaWxsYUNsaWVudENvbnRleHQuYmVhbk1hbmFnZXIpO1xuXG4gICAgJHdpbmRvdy5vbmJlZm9yZXVubG9hZCA9IGNsaWVudENvbnRleHQuZGlzY29ubmVjdDtcblxuICAgICRsb2cuZGVidWcoJ0RvbHBoaW4gUGxhdGZvcm0gY29udGV4dCBjcmVhdGVkJyk7XG5cbiAgICByZXR1cm4gY2xpZW50Q29udGV4dDtcbn1dKTtcbiJdfQ==
